<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<meta name="google-site-verification" content="aB8LkQegj94_TJPdrcJm2ldIRWyXY82Jp24Gtkdgyn0" />
<title>vipy.image API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vipy.image</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1-L2498" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import os
import PIL
import PIL.Image
import PIL.ImageFilter
import platform
import dill
import vipy.show
import vipy.globals
from vipy.globals import print
from vipy.util import isnumpy, isurl, isimageurl, \
    fileext, tempimage, mat2gray, imwrite, imwritegray, \
    tempjpg, filetail, isimagefile, remkdir, hasextension, \
    try_import, tolist, islistoflists, istupleoftuples, isstring, \
    istuple, islist, isnumber, isnumpyarray, string_to_pil_interpolation, toextension, iswebp
from vipy.geometry import BoundingBox, imagebox
import vipy.object
from vipy.object import greedy_assignment
import vipy.downloader
import urllib.request
import urllib.error
import urllib.parse
import http.client as httplib
import copy
from copy import deepcopy
import numpy as np
import shutil
import io
import matplotlib.pyplot as plt
import warnings
import base64
import types
import hashlib
import time


try:
    import torch  # pre-import
except:
    pass  # lazy load on demand

try:
    import ujson as json  # faster
except ImportError:
    import json


class Image(object):
    &#34;&#34;&#34;vipy.image.Image class
    
    The vipy image class provides a fluent, lazy interface for representing, transforming and visualizing images.
    The following constructors are supported:

    ```python
    im = vipy.image.Image(filename=&#34;/path/to/image.ext&#34;)
    ```
    
    All image file formats that are readable by PIL are supported here.

    ```python
    im = vipy.image.Image(url=&#34;http://domain.com/path/to/image.ext&#34;)
    ```
    
    The image will be downloaded from the provided url and saved to a temporary filename.
    The environment variable VIPY_CACHE controls the location of the directory used for saving images, otherwise this will be saved to the system temp directory.

    ```python
    im = vipy.image.Image(url=&#34;http://domain.com/path/to/image.ext&#34;, filename=&#34;/path/to/new/image.ext&#34;)
    ```

    The image will be downloaded from the provided url and saved to the provided filename.
    The url() method provides optional basic authentication set for username and password

    ```python
    im = vipy.image.Image(array=img, colorspace=&#39;rgb&#39;)
    ```

    The image will be constructed from a provided numpy array &#39;img&#39;, with an associated colorspace.  The numpy array and colorspace can be one of the following combinations:

    - &#39;rgb&#39;: uint8, three channel (red, green, blue)
    - &#39;rgba&#39;:  uint8, four channel (rgb + alpha)
    - &#39;bgr&#39;: uint8, three channel (blue, green, red), such as is returned from cv2.imread()
    - &#39;bgra&#39;:  uint8, four channel
    - &#39;hsv&#39;:  uint8, three channel (hue, saturation, value)
    - &#39;lum;:  uint8, one channel, luminance (8 bit grey level)
    - &#39;grey&#39;:  float32, one channel in range [0,1] (32 bit intensity)
    - &#39;float&#39;:  float32, any channel in range [-inf, +inf]
    
    The most general colorspace is &#39;float&#39; which is used to manipulate images prior to network encoding, such as applying bias. 
    
    Args:
        filename: a path to an image file that is readable by PIL
        url:  a url string to an image file that is readable by PIL
        array: a numpy array of type uint8 or float32 of shape HxWxC=height x width x channels
        colorspace:  a string in [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;lum&#39;]
        attributes:  a python dictionary that is passed by reference to the image.  This is useful for encoding metadata about the image.  Accessible as im.attributes

    Returns:
        A `vipy.image.Image` object

    &#34;&#34;&#34;

    def __init__(self, filename=None, url=None, array=None, colorspace=None, attributes=None):
        # Private attributes
        self._ignoreErrors = False  # ignore errors during fetch (broken links)
        self._urluser = None      # basic authentication set with url() method
        self._urlpassword = None  # basic authentication set with url() method
        self._urlsha1 = None      # file hash if known
        self._filename = None   # Local filename
        self._url = None        # URL to download
        self._loader = None     # lambda function to load an image, set with loader() method
        self._array = None
        self._colorspace = None
        
        # Initialization
        self._filename = filename
        if url is not None:
            assert isurl(url), &#39;Invalid URL&#39;
        self._url = url
        if array is not None:
            assert isnumpy(array), &#39;Invalid Array - Type &#34;%s&#34; must be np.array()&#39; % (str(type(array)))
        self.array(array)  # shallow copy

        # Guess RGB colorspace if three channel uint8 if colorspace is not provided
        colorspace = &#39;rgb&#39; if (self.isloaded() and self.channels() == 3 and self._array.dtype == np.uint8 and colorspace is None) else colorspace

        # Guess float colorspace if array is float32 and colorspace is not provided        
        colorspace = &#39;float&#39; if (self.isloaded() and self._array.dtype == np.float32 and colorspace is None) else colorspace
        self.colorspace(colorspace)
        
        # Public attributes: passed in as a dictionary
        self.attributes = {} 
        if attributes is not None:
            assert isinstance(attributes, dict), &#34;Attributes must be dictionary&#34;
            self.attributes = attributes

    @classmethod
    def cast(cls, im):
        &#34;&#34;&#34;Typecast the conformal vipy.image object im as `vipy.image.Image`.
        
        This is useful for downcasting `vipy.image.Scene` or `vipy.image.ImageDetection` down to an image.

        ```python
        ims = vipy.image.RandomScene()
        im = vipy.image.Image.cast(im)
        ```

        &#34;&#34;&#34;
        assert isinstance(im, vipy.image.Image), &#34;Invalid input - must derive from vipy.image.Image&#34;
        im.__class__ = vipy.image.Image
        return im
        
    @classmethod
    def from_json(cls, s):
        &#34;&#34;&#34;Import the JSON string s as an `vipy.image.Image` object.
        
        This will perform a round trip such that im1 == im2

        ```python
        im1 = vupy.image.RandomImage()
        im2 = vipy.image.Image.from_json(im1.json())
        assert im1 == im2
        ```
        
        &#34;&#34;&#34;
        d = json.loads(s)        
        return cls(filename=d[&#39;_filename&#39;],
                   url=d[&#39;_url&#39;],
                   array=np.array(d[&#39;_array&#39;], dtype=np.uint8) if d[&#39;_array&#39;] is not None else None,
                   colorspace=d[&#39;_colorspace&#39;],
                   attributes=d[&#39;attributes&#39;])
    
    def __eq__(self, other):
        &#34;&#34;&#34;Images are equivalent if they have the same filename, url and array&#34;&#34;&#34;
        return isinstance(other, Image) and other.filename()==self.filename() and other.url()==self.url() and np.all(other.array() == self.array())

    def __str__(self):
        return self.__repr__()

    def __iter__(self):
        &#34;&#34;&#34;Yield single image for consistency with videos&#34;&#34;&#34;
        yield self

    def __len__(self):
        &#34;&#34;&#34;Images have length 1 always&#34;&#34;&#34;
        return 1
    
    def __array__(self):
        &#34;&#34;&#34;Called on np.array(self) for custom array container, (requires numpy &gt;=1.16)&#34;&#34;&#34;
        return self.numpy()
    
    def __repr__(self):
        strlist = []
        if self.isloaded():
            strlist.append(&#34;height=%d, width=%d, color=%s&#34; % (self._array.shape[0], self._array.shape[1], self.colorspace()))
        if self.colorspace() == &#39;float&#39;:
            strlist.append(&#39;channels=%d&#39; % self.channels())
        if self.filename() is not None:
            strlist.append(&#39;filename=&#34;%s&#34;&#39; % (self.filename() if self.hasfilename() else &#39;&lt;NOTFOUND&gt;%s&lt;/NOTFOUND&gt;&#39; % self.filename()))
        if self.hasfilename():
            strlist.append(&#39;filename=&#34;%s&#34;&#39; % self.filename())
        if self.hasurl():
            strlist.append(&#39;url=&#34;%s&#34;&#39; % self.url())
        return str(&#39;&lt;vipy.image: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def sanitize(self):
        &#34;&#34;&#34;Remove all private keys from the attributes dictionary.
        
        The attributes dictionary is useful storage for arbitrary (key,value) pairs.  However, this storage may contain sensitive information that should be scrubbed from the media before serialization.  As a general rule, any key that is of the form &#39;__keyname&#39; prepended by two underscores is a private key.  This is analogous to private or reserved attributes in the python lanugage.  Users should reserve these keynames for those keys that should be sanitized and removed before any serialization of this object.
        
        ```python
        assert self.setattribute(&#39;__mykey&#39;, 1).sanitize().hasattribute(&#39;__mykey&#39;) == False
        ```

        &#34;&#34;&#34;
        self.attributes = {k:v for (k,v) in self.attributes.items() if not k.startswith(&#39;__&#39;)} if isinstance(self.atttributes, dict) else self.attributes
        return self
    
    def print(self, prefix=&#39;&#39;, verbose=True, sleep=None):
        &#34;&#34;&#34;Print the representation of the image and return self with an optional sleep=n seconds
        
        Useful for debugging in long fluent chains.
        &#34;&#34;&#34;
        if verbose:
            print(prefix+self.__repr__())
        if sleep is not None:
            assert isinstance(sleep, int) and sleep &gt; 0, &#34;Sleep must be a non-negative integer number of seconds&#34;
            time.sleep(sleep)
        return self

    def tile(self, tilewidth, tileheight, overlaprows=0, overlapcols=0):
        &#34;&#34;&#34;Generate an image tiling.
        
        A tiling is a decomposition of an image into overlapping or non-overlapping rectangular regions.  

        Args:
            tilewidth: [int] the image width of each tile
            tileheight: [int] the image height of each tile
            overlaprows: [int] the number of overlapping rows (height) for each tile
            overlapcols: [int] the number of overlapping width (width) for each tile
    
        Returns:
            A list of `vipy.image.Image` objects such that each image is a single tile and the set of these tiles forms the original image
            Each image in the returned list contains the &#39;tile&#39; attribute which encodes the crop used to create the tile.

        .. note:: 
            - `vipy.image.Image.tile` can be undone using `vipy.image.Image.untile`
            - The identity tiling is im.tile(im.widht(), im.height(), overlaprows=0, overlapcols=0)
            - Ragged tiles outside the image boundary are zero padded
            - All annotations are updated properly for each tile, when the source image is `vipy.image.Scene`
        &#34;&#34;&#34;
        assert tilewidth &gt; 0 and tileheight &gt; 0 and overlaprows &gt;= 0 and overlapcols &gt;= 0, &#34;Invalid input&#34;
        assert self.width() &gt;= tilewidth-overlapcols and self.height() &gt;= tileheight-overlaprows, &#34;Invalid input&#34; 
        bboxes = [BoundingBox(xmin=i, ymin=j, width=min(tilewidth, self.width()-i), height=min(tileheight, self.height()-j)) for i in range(0, self.width()-overlapcols, tilewidth-overlapcols) for j in range(0, self.height()-overlaprows, tileheight-overlaprows)]
        return [self.clone(shallow=True, attributes=True).setattribute(&#39;tile&#39;, {&#39;crop&#39;:bb, &#39;shape&#39;:self.shape()}).crop(bb) for bb in bboxes]

    def union(self, other):
        &#34;&#34;&#34;No-op for `vipy.image.Image`&#34;&#34;&#34;
        return self
    
    @classmethod
    def untile(cls, imlist):
        &#34;&#34;&#34;Undo an image tiling and recreate the original image.

        ```python
        tiles = im.tile(im.width()/2, im.height()/2, 0, 0)
        imdst = vipy.image.Image.untile(tiles)
        assert imdst == im
        ```

        Args:
            imlist: this must be the output of `vipy.image.Image.tile`
        
        Returns:
            A  new `vipy.image.Image` object reconstructed from the tiling, such that this is equivalent to the input to vipy.image.Image.tile` 
        
        .. note:: All annotations are updated properly for each tile, when the source image is `vipy.image.Scene`
        &#34;&#34;&#34;
        assert all([isinstance(im, vipy.image.Image) and im.hasattribute(&#39;tile&#39;) for im in imlist]), &#34;invalid image tile list&#34;        
        imc = None
        for im in imlist:
            if imc is None:
                imc = im.clone(shallow=True).array(np.zeros( (im.attributes[&#39;tile&#39;][&#39;shape&#39;][0], im.attributes[&#39;tile&#39;][&#39;shape&#39;][1], im.channels()), dtype=np.uint8))                
            imc = imc.splat(im.array(im.attributes[&#39;tile&#39;][&#39;crop&#39;].clone().to_origin().int().crop(im.array())), im.attributes[&#39;tile&#39;][&#39;crop&#39;])
            if hasattr(im, &#39;objectmap&#39;):
                im.objectmap(lambda o: o.set_origin(im.attributes[&#39;tile&#39;][&#39;crop&#39;]))  # FIXME: only for Scene()
            imc = imc.union(im)
        return imc
    
    def uncrop(self, bb, shape):
        &#34;&#34;&#34;Uncrop using provided bounding box and zeropad to shape=(Height, Width).

        An uncrop is the inverse operation for a crop, which preserves the cropped portion of the image in the correct location and replaces the rest with zeros out to shape.
    
        ```python
        im = vipy.image.RandomImage(128, 128)
        bb = vipy.geometry.BoundingBox(xmin=0, ymin=0, width=64, height=64)
        uncrop = im.crop(bb).uncrop(bb, shape=(128,128))
        ```

        Args:
            bb: [`vipy.geometry.BoundingBox`] the bounding box used to crop the image in self
            shape: [tuple] (height, width) of the uncropped image
    
        Returns:
            this `vipy.image.Image` object with the pixels uncropped.

        .. note:: NOT idempotent.  This will generate different results if run more than once.
        &#34;&#34;&#34;
        ((x,y,w,h), (H,W)) = (bb.xywh(), shape)
        ((dyb, dya), (dxb, dxa)) = ((int(y), int(H-(y+h))), (int(x), int(W-(x+w))))
        self._array = np.pad(self.load().array(),
                             ((dyb, dya), (dxb, dxa), (0, 0)) if
                             self.load().array().ndim == 3 else ((dyb, dya), (dxb, dxa)),
                             mode=&#39;constant&#39;)        
        return self

    def splat(self, im, bb):
        &#34;&#34;&#34;Replace pixels within boundingbox in self with pixels in im&#34;&#34;&#34;
        assert isinstance(im, vipy.image.Image), &#34;invalid image&#34;
        assert (im.width() == bb.width() and im.height() == bb.height()) or bb.isinterior(im.width(), im.height()) and bb.isinterior(self.width(), self.height()), &#34;Invalid bounding box &#39;%s&#39;&#34; % str(bb)
        (x,y,w,h) = bb.xywh()
        self._array[int(y):int(y+h), int(x):int(x+w)] = im.array() if (im.width() == bb.width() and im.height() == bb.height()) else im.array()[int(y):int(y+h), int(x):int(x+w)]
        return self            
        
    def store(self):
        &#34;&#34;&#34;Store the current image file as an attribute of this object.  Useful for archiving an object to be fully self contained without any external references.  
        
           -Remove this stored image using unstore()
           -Unpack this stored image and set up the filename using restore() 
           -This method is more efficient than load() followed by pkl(), as it stores the encoded image as a byte string.
           -Useful for creating a single self contained object for distributed processing.  

        ```python
        v == v.store().restore(v.filename()) 
        ```

        &#34;&#34;&#34;
        assert self.hasfilename(), &#34;Image file not found&#34;
        with open(self.filename(), &#39;rb&#39;) as f:
            self.attributes[&#39;__image__&#39;] = f.read()
        return self

    def unstore(self):
        &#34;&#34;&#34;Delete the currently stored image from store()&#34;&#34;&#34;
        return self.delattribute(&#39;__image__&#39;)

    def restore(self, filename):
        &#34;&#34;&#34;Save the currently stored image to filename, and set up filename&#34;&#34;&#34;
        assert self.hasattribute(&#39;__image__&#39;), &#34;Image not stored&#34;
        with open(filename, &#39;wb&#39;) as f:
            f.write(self.attributes[&#39;__image__&#39;])
        return self.filename(filename)                
    
    def abspath(self):
        &#34;&#34;&#34;Change the path of the filename from a relative path to an absolute path (not relocatable)&#34;&#34;&#34;
        return self.filename(os.path.normpath(os.path.abspath(os.path.expanduser(self.filename()))))

    def relpath(self, parent=None):
        &#34;&#34;&#34;Replace the filename with a relative path to parent (or current working directory if none)&#34;&#34;&#34;
        parent = parent if parent is not None else os.getcwd()
        assert parent in os.path.expanduser(self.filename()), &#34;Parent path &#39;%s&#39; not found in abspath &#39;%s&#39;&#34; % (parent, self.filename())
        return self.filename(PurePath(os.path.expanduser(self.filename())).relative_to(parent))

    def canload(self):
        &#34;&#34;&#34;Return True if the image can be loaded successfully, useful for filtering bad links or corrupt images&#34;&#34;&#34;
        if not self.isloaded():
            try:
                self.load()  # try to load
                return True
            except:
                return False
        else:
            return True
        
    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(s=None, encode=False)

    def json(self, s=None, encode=True):
        if s is None:
            d = {&#39;_filename&#39;:self._filename,
                 &#39;_url&#39;:self._url,
                 &#39;_loader&#39;:self._loader,
                 &#39;_array&#39;:self._array.tolist() if self._array is not None else None,
                 &#39;_colorspace&#39;:self._colorspace,
                 &#39;attributes&#39;:self.attributes}                        
            return json.dumps(d) if encode else d
        else:
            d = json.loads(s)
            self._filename = d[&#39;_filename&#39;]
            self._url = d[&#39;_url&#39;]
            self._loader = d[&#39;_loader&#39;]
            self._array = np.array(d[&#39;_array&#39;], dtype=np.uint8) if d[&#39;_array&#39;] is not None else None
            self._colorspace = d[&#39;_colorspace&#39;]
            self.attributes = d[&#39;attributes&#39;]            
            return self
        
    def loader(self, f):
        &#34;&#34;&#34;Lambda function to load an unsupported image filename to a numpy array.
        
        This lambda function will be executed during load and the result will be stored in self._array
        &#34;&#34;&#34;
        self._loader = f
        return self

    def load(self, ignoreErrors=False, verbose=False):
        &#34;&#34;&#34;Load image to cached private &#39;_array&#39; attribute.

        Args:
            ignoreErrors: [bool] If true, ignore any exceptions thrown during load and print the corresponding error messages.  This is useful for loading images distributed without throwing exceptions when some images may be corrupted.  In this case, the _array attribute will be None and `vipy.image.Image.isloaded` will return false to determine if the image is loaded, which can be used to filter out corrupted images gracefully. 
            verbose: [bool] If true, show additional useful printed output

        Returns:
            This `vipy.image.Image` object with the pixels loaded in self._array as a numpy array.

        .. note:: This loader supports any image file format supported by PIL.  A custom loader can be added using `vipy.image.Image.loader`.
        &#34;&#34;&#34;
        try:
            # Return if previously loaded image
            if self._array is not None:
                return self

            # Download URL to filename
            if self._url is not None:
                self.download(ignoreErrors=ignoreErrors, verbose=verbose)

            # Load filename to numpy array
            if self._loader is not None:
                self._array = self._loader(self._filename).astype(np.float32)  # forcing float32
                self.colorspace(&#39;float&#39;)
            elif isimagefile(self._filename):
                self._array = np.array(PIL.Image.open(self._filename))  # RGB order!
                if self.istransparent():
                    self.colorspace(&#39;rgba&#39;)  # must be before iscolor()
                elif self.iscolor():
                    self.colorspace(&#39;rgb&#39;)
                elif self.isgrey():
                    self.colorspace(&#39;grey&#39;)
                elif self.isluminance():
                    self.colorspace(&#39;lum&#39;)
                else:
                    warnings.warn(&#39;unknown colorspace for image &#34;%s&#34; - attempting to coerce to colorspace=float&#39; % str(self._filename))
                    self._array = np.float32(self._array)
                    self.colorspace(&#39;float&#39;)
            elif iswebp(self._filename):
                import vipy.video
                return vipy.video.Video(self._filename).load()  
            elif hasextension(self._filename):
                raise ValueError(&#39;Non-standard image extensions require a custom loader&#39;)
            else:
                # Attempting to open it anyway, may be an image file without an extension. Cross your fingers ...
                self._array = np.array(PIL.Image.open(self._filename))  # RGB order!

        except IOError:
            if self._ignoreErrors or ignoreErrors:
                if verbose is True:
                    warnings.warn(&#39;[vipy.image][WARNING]: IO error &#34;%s&#34; -&gt; &#34;%s&#34; - Ignoring. &#39; % (self.url(), self.filename()))
                self._array = None
            else:
                raise

        except KeyboardInterrupt:
            raise

        except Exception:
            if self._ignoreErrors or ignoreErrors:
                if verbose is True:
                    warnings.warn(&#39;[vipy.image][WARNING]: Load error for image &#34;%s&#34; - Ignoring&#39; % self.filename())
                self._array = None
            else:
                raise

        return self

    def download(self, ignoreErrors=False, timeout=10, verbose=False):
        &#34;&#34;&#34;Download URL to filename provided by constructor, or to temp filename.

        Args:
            ignoreErrors:  [bool] If true, do not throw an exception if the download of the URL fails for some reason.  Instead, print out a reason and return this image object.  The function `vipy.image.Image.hasfilename` will return false if the downloaded file does not exist and can be used to filter these failed downloads gracefully.
            timeout: [int]  The timeout in seconds for an http or https connection attempt.  See also [urllib.request.urlopen](https://docs.python.org/3/library/urllib.request.html).
            verbose: [bool] If true, output more helpful message.

        Returns:
            This `vipy.image.Image` object with the URL downloaded to `vipy.image.Image.filename` or to a `vipy.util.tempimage` filename which can be retrieved with `vipy.image.Image.filename`.
        &#34;&#34;&#34;
        if self._url is None and self._filename is not None:
            return self
        if self._url is None or not isurl(str(self._url)):
            raise ValueError(&#39;[vipy.image.download][ERROR]: &#39;
                             &#39;Invalid URL &#34;%s&#34; &#39; % self._url)

        if self._filename is None:
            if vipy.globals.cache() is not None:
                self._filename = os.path.join(remkdir(vipy.globals.cache()), filetail(self._url))
            elif isimageurl(self._url):
                self._filename = tempimage(fileext(self._url))
            else:
                self._filename = tempjpg()  # guess JPG for URLs with no file extension

        try:
            url_scheme = urllib.parse.urlparse(self._url)[0]
            if url_scheme in [&#39;http&#39;, &#39;https&#39;]:
                vipy.downloader.download(self._url,
                                         self._filename,
                                         verbose=verbose,
                                         timeout=timeout,
                                         sha1=self._urlsha1,
                                         username=self._urluser,
                                         password=self._urlpassword)
            elif url_scheme == &#39;file&#39;:
                shutil.copyfile(self._url, self._filename)
            elif url_scheme == &#39;s3&#39;:
                raise NotImplementedError(&#39;S3 support is in development&#39;)                
            else:
                raise NotImplementedError(
                    &#39;Invalid URL scheme &#34;%s&#34; for URL &#34;%s&#34;&#39; %
                    (url_scheme, self._url))

        except (httplib.BadStatusLine,
                urllib.error.URLError,
                urllib.error.HTTPError):
            if self._ignoreErrors or ignoreErrors:
                if verbose is True:
                    warnings.warn(&#39;[vipy.image][WARNING]: download failed - Ignoring image&#39;)
                self._array = None
            else:
                raise

        except IOError:
            if self._ignoreErrors or ignoreErrors:
                if verbose:
                    warnings.warn(&#39;[vipy.image][WARNING]: IO error downloading &#34;%s&#34; -&gt; &#34;%s&#34; - Ignoring&#39; % (self.url(), self.filename()))
                self._array = None
            else:
                raise

        except KeyboardInterrupt:
            raise

        except Exception:
            if self._ignoreErrors or ignoreErrors:
                if verbose:
                    warnings.warn(&#39;[vipy.image][WARNING]: load error for image &#34;%s&#34;&#39; % self.filename())
            else:
                raise

        return self

    def reload(self):
        &#34;&#34;&#34;Flush the image buffer to force reloading from file or URL&#34;&#34;&#34;
        return self.clone(flush=True).load()

    def isloaded(self):
        &#34;&#34;&#34;Return True if `vipy.image.Image.load` was successful in reading the image, or if the pixels are present in `vipy.image.Image.array`.&#34;&#34;&#34;
        return self._array is not None

    def channels(self):
        &#34;&#34;&#34;Return integer number of color channels&#34;&#34;&#34;
        return 1 if self.load().array().ndim == 2 else self.load().array().shape[2]

    def iscolor(self):
        &#34;&#34;&#34;Color images are three channel or four channel with transparency, float32 or uint8&#34;&#34;&#34;
        return self.channels() == 3 or self.channels() == 4

    def istransparent(self):
        &#34;&#34;&#34;Transparent images are four channel color images with transparency, float32 or uint8.  Return true if this image contains an alpha transparency channel&#34;&#34;&#34;
        return self.channels() == 4

    def isgrey(self):
        &#34;&#34;&#34;Grey images are one channel, float32&#34;&#34;&#34;
        return self.channels() == 1 and self.array().dtype == np.float32

    def isluminance(self):
        &#34;&#34;&#34;Luninance images are one channel, uint8&#34;&#34;&#34;
        return self.channels() == 1 and self.array().dtype == np.uint8

    def filesize(self):
        &#34;&#34;&#34;Return size of underlying image file, requires fetching metadata from filesystem&#34;&#34;&#34;
        assert self.hasfilename(), &#39;Invalid image filename&#39;
        return os.path.getsize(self._filename)

    def width(self):
        &#34;&#34;&#34;Return the width (columns) of the image in integer pixels.
        
        .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
        &#34;&#34;&#34;
        return self.load().array().shape[1]

    def height(self):
        &#34;&#34;&#34;Return the height (rows) of the image in integer pixels.
        
        .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
        &#34;&#34;&#34;        
        return self.load().array().shape[0]
    
    def shape(self):
        &#34;&#34;&#34;Return the (height, width) or equivalently (rows, cols) of the image.
        
        Returns:
            A tuple (height=int, width=int) of the image.

        .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
        &#34;&#34;&#34;
        return (self.load().height(), self.width())

    def aspectratio(self):
        &#34;&#34;&#34;Return the aspect ratio of the image as (width/height) ratio.

        Returns:
            A float equivalent to (`vipy.image.Image.width` / `vipy.image.Image.height`)

        .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
        &#34;&#34;&#34;
        return self.load().width() / float(self.height())

    def area(self):
        &#34;&#34;&#34;Return the area of the image as (width * height).

        Returns:
            An integer equivalent to (`vipy.image.Image.width` * `vipy.image.Image.height`)

        .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
        &#34;&#34;&#34;
        return self.width()*self.height()
    
    def centroid(self):
        &#34;&#34;&#34;Return the real valued center pixel coordinates of the image (col=x,row=y).
        
        The centroid is equivalent to half the `vipy.image.Image.shape`.

        Returns:
            A tuple (column, row) of the floating point center of the image.
        &#34;&#34;&#34;
        return (self.load().width() / 2.0, self.height() / 2.0)

    def centerpixel(self):
        &#34;&#34;&#34;Return the integer valued center pixel coordinates of the image (col=i,row=j)

        The centerpixel is equivalent to half the `vipy.image.Image.shape` floored to the nearest integer pixel coordinate.

        Returns:
            A tuple (int(column), int(row)) of the integer center of the image.
        &#34;&#34;&#34;
        c = np.round(self.centroid())
        return (int(c[0]), int(c[1]))
    
    def array(self, np_array=None, copy=False):
        &#34;&#34;&#34;Replace self._array with provided numpy array

        Args:
            np_array: [numpy array] A new array to use as the pixel buffer for this image.
            copy: [bool] If true, copy the buffer using np.copy(), else use a reference to this buffer.

        Returns:
            - If np_array is not None, return the `vipy.image.Image` object such that this object points to the provided numpy array as the pixel buffer
            - If np_array is None, then return the numpy array.

        .. notes:: 
            - If copy=False, then this `vipy.image.Image` object will share the pixel buffer with the owner of np_array.  Changes to pixels in this buffer will be shared.  
            - If copy=True, then this will significantly slow down processing for large images.  Use referneces wherevery possible.
        &#34;&#34;&#34;
        if np_array is None:
            return self._array if copy is False else np.copy(self._array)
        elif isnumpyarray(np_array):
            self._array = np.copy(np_array) if copy else np_array  # reference or copy
            assert self._array.dtype == np.float32 or self._array.dtype == np.uint8, &#34;Invalid input - array() must be type uint8 or float32 and not type=&#39;%s&#39;&#34; % (str(self._array.dtype))                        
            self.colorspace(None)  # must be set with colorspace() after array() but before _convert()
            return self
        else:
            raise ValueError(&#39;Invalid input - array() must be numpy array and not &#34;%s&#34;&#39; % (str(type(np_array))))

    def fromarray(self, data):
        &#34;&#34;&#34;Alias for `vipy.image.Image.array` with copy=True. This will set new numpy array as the pixel buffer with a numpy array copy&#34;&#34;&#34;
        return self.array(data, copy=True)
    
    def tonumpy(self):
        &#34;&#34;&#34;Alias for `vipy.image.Image.numpy&#34;&#34;&#34;
        return self.numpy()

    def numpy(self):
        &#34;&#34;&#34;Return a mutable numpy array for this `vipy.image.Image`.

        .. notes:: 
            - This will always return a writeable array with the &#39;WRITEABLE&#39; numpy flag set.  This is useful for returning a mutable numpy array as needed while keeping the original non-mutable numpy array (e.g. loaded from a video or PIL) as the underlying pixel buffer for efficiency reasons.
            - Triggers a `vipy.image.Image.load` if the pixel buffer has not been loaded
            - This will trigger a copy if the [&#39;WRITEABLE&#39; flag](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flags.html) is not set. 
        &#34;&#34;&#34;        
        self.load()
        self._array = np.copy(self._array) if not self._array.flags[&#39;WRITEABLE&#39;] else self._array  # triggers copy         
        return self._array
        
    def channel(self, k=None):
        &#34;&#34;&#34;Return a cloned Image() object for the kth channel, or return an iterator over channels if k=None.

        Iterate over channels as single channel luminance images:

        ```python
        for c in self.channel():
            print(c)
        ```

        Return the kth channel as a single channel luminance image:

        ```python
        c = self.channel(k=0)
        ```

        &#34;&#34;&#34;
        if k is None:
            return [self.channel(j) for j in range(0, self.channels())]
        elif k == 0 and self.channels() == 1:
            return self
        else:
            assert k &lt; self.channels() and k&gt;=0, &#34;Requested channel=%d must be within valid channels=%d&#34; % (k, self.channels())
            im = self.clone().load()
            im._array = im._array[:,:,k]
            im._colorspace = &#39;lum&#39;
            return im

    def red(self):
        &#34;&#34;&#34;Return red channel as a cloned single channel `vipy.image.Image` object.

        These are equivalent operations if the colorspace is &#39;rgb&#39; or &#39;rgba&#39;:
        
        ```python
        self.red() == self.channel(0) 
        ```

        These are equivalent operations if the colorspace is &#39;bgr&#39; or &#39;bgra&#39;:

        ```python
        self.red() == self.channel(3) 
        ```

        .. note:: OpenCV returns images in BGR colorspace.  Use this method to always return the desired channel by color.
        &#34;&#34;&#34;
        assert self.channels() &gt;= 3, &#34;Must be color image&#34;
        if self.colorspace() in [&#39;rgb&#39;, &#39;rgba&#39;]:
            return self.channel(0)
        elif self.colorspace() in [&#39;bgr&#39;, &#39;bgra&#39;]:
            return self.channel(3)
        else:
            raise ValueError(&#39;Invalid colorspace &#34;%s&#34; does not contain red channel&#39; % self.colorspace())

    def green(self):
        &#34;&#34;&#34;Return green channel as a cloned single channel `vipy.image.Image` object.

        These are equivalent operations if the colorspace is &#39;rgb&#39; or &#39;rgba&#39;:

        ```python
        self.green() == self.channel(1) 
        ```

        These are equivalent operations if the colorspace is &#39;bgr&#39; or &#39;bgra&#39;:

        ```python
        self.green() == self.channel(1) 
        ```

        .. note:: OpenCV returns images in BGR colorspace.  Use this method to always return the desired channel by color.
        &#34;&#34;&#34;
        assert self.channels() &gt;= 3, &#34;Must be three channel color image&#34;
        if self.colorspace() in [&#39;rgb&#39;, &#39;rgba&#39;]:
            return self.channel(1)
        elif self.colorspace() in [&#39;bgr&#39;, &#39;bgra&#39;]:
            return self.channel(1)
        else:
            raise ValueError(&#39;Invalid colorspace &#34;%s&#34; does not contain red channel&#39; % self.colorspace())

    def blue(self):
        &#34;&#34;&#34;Return blue channel as a cloned single channel `vipy.image.Image` object.

        These are equivalent operations if the colorspace is &#39;rgb&#39; or &#39;rgba&#39;:

        ```python
        self.vlue() == self.channel(2) 
        ```

        These are equivalent operations if the colorspace is &#39;bgr&#39; or &#39;bgra&#39;:

        ```python
        self.blue() == self.channel(0) 
        ```

        .. note:: OpenCV returns images in BGR colorspace.  Use this method to always return the desired channel by color.
        &#34;&#34;&#34;
        assert self.channels() &gt;= 3, &#34;Must be three channel color image&#34;
        if self.colorspace() in [&#39;rgb&#39;, &#39;rgba&#39;]:
            return self.channel(2)
        elif self.colorspace() in [&#39;bgr&#39;, &#39;bgra&#39;]:
            return self.channel(0)
        else:
            raise ValueError(&#39;Invalid colorspace &#34;%s&#34; does not contain red channel&#39; % self.colorspace())                

    def alpha(self):
        &#34;&#34;&#34;Return alpha (transparency) channel as a cloned single channel `vipy.image.Image` object&#34;&#34;&#34;
        assert self.channels() == 4 and self.colorspace() in [&#39;rgba&#39;, &#39;bgra&#39;], &#34;Must be four channnel color image&#34;
        return self.channel(3)
        
    def zeros(self):
        &#34;&#34;&#34;Set the pixel buffer to all zeros of the same shape and datatype as this `vipy.image.Image` object.
        
        These are equivalent operations for the resulting buffer shape: 
        
        ```python
        import numpy as np
        np.zeros( (self.width(), self.height(), self.channels()) ) == self.zeros().array()
        ```

        Returns:
           This `vipy.image.Image` object.

        .. note:: Triggers load() if the pixel buffer has not been loaded yet.
        &#34;&#34;&#34;
        self._array = 0*self.load()._array
        return self

    def pil(self):
        &#34;&#34;&#34;Convert vipy.image.Image to PIL Image.
        
        Returns:
            A [PIL image](https://pillow.readthedocs.io/en/stable/reference/Image.html) object, that shares the pixel buffer by reference
        &#34;&#34;&#34;
        assert self.channels() in [1,3,4] and (self.channels() == 1 or self.colorspace() != &#39;float&#39;), &#34;Incompatible with PIL&#34;
        return PIL.Image.fromarray(self.numpy(), mode=&#39;RGB&#39; if self.colorspace()==&#39;rgb&#39; else None)  # FIXME: mode=&#39;RGB&#39; triggers slow tobytes() conversion, need RGBA or RGBX

    def blur(self, sigma=3):
        &#34;&#34;&#34;Apply a Gaussian blur with Gaussian kernel radius=sigma to the pixel buffer.
        
        Args:
            sigma: [float &gt;0] The gaussian blur kernel radius.

        Returns:
            This `vipy.image.Image` object with the pixel buffer blurred in place.
        &#34;&#34;&#34;
        assert sigma &gt; 0
        return self.array(np.array(self.pil().filter(PIL.ImageFilter.GaussianBlur(radius=sigma))))
        
    def torch(self, order=&#39;CHW&#39;):
        &#34;&#34;&#34;Convert the batch of 1 HxWxC images to a CxHxW torch tensor.

        Args:
            order: [&#39;CHW&#39;, &#39;HWC&#39;, &#39;NCHW&#39;, &#39;NHWC&#39;].  The axis order of the torch tensor (channels, height, width) or (height, width, channels) or (1, channels, height, width) or (1, height, width, channels)

        Returns:
            A CxHxW or HxWxC or 1xCxHxW or 1xHxWxC [torch tensor](https://pytorch.org/docs/stable/tensors.html) that shares the pixel buffer of this image object by reference.
        &#34;&#34;&#34;
        try_import(&#39;torch&#39;); import torch
        assert order.lower() in [&#39;chw&#39;, &#39;hwc&#39;, &#39;nchw&#39;, &#39;nhwc&#39;]
        img = self.numpy() if self.iscolor() else np.expand_dims(self.numpy(), 2)  # HxW -&gt; HxWx1
        img = img.transpose(2,0,1) if order.lower() in [&#39;chw&#39;, &#39;nchw&#39;]  else img   # HxWxC or CxHxW        
        img = np.expand_dims(img,0) if order.lower() in [&#39;nhwc&#39;, &#39;nchw&#39;] else img  # HxWxC -&gt; 1xHxWxC
        return torch.from_numpy(img)  

    @staticmethod
    def fromtorch(x):
        &#34;&#34;&#34;Convert a 1xCxHxW or CxHxW torch tensor (or numpy array with torch channel order) to HxWxC numpy array, returns new `vipy.image.Image` with inferred colorspace corresponding to data type in x&#34;&#34;&#34;
        try_import(&#39;torch&#39;); import torch        
        assert isinstance(x, torch.Tensor) or isinstance(x, np.ndarray), &#34;Invalid input type &#39;%s&#39;- must be torch.Tensor&#34; % (str(type(x)))
        assert (x.ndim == 4 and x.shape[0] == 1) or x.ndim == 3, &#34;Torch tensor must be shape 1xCxHxW or CxHxW&#34;
        x = x.squeeze(0) if (x.ndim == 4 and x.shape[0] == 1) else x
        img = np.copy(np.squeeze(x.permute(1,2,0).detach().numpy() if torch.is_tensor(x) else x.transpose(1,2,0)))   # CxHxW -&gt; HxWxC, copied
        colorspace = &#39;float&#39; if img.dtype == np.float32 else None
        colorspace = &#39;rgb&#39; if img.dtype == np.uint8 and img.shape[2] == 3 else colorspace  # assumed
        colorspace = &#39;lum&#39; if img.dtype == np.uint8 and img.shape[2] == 1 else colorspace        
        return Image(array=img, colorspace=colorspace)
    
    def nofilename(self):
        self._filename = None
        return self

    def filename(self, newfile=None):
        &#34;&#34;&#34;Return or set image filename&#34;&#34;&#34;
        if newfile is None:
            return self._filename
        else:
            self._filename = newfile
            return self

    def nourl(self):
        self._url = None
        return self

    def url(self, url=None, username=None, password=None, sha1=None, ignoreUrlErrors=None):
        &#34;&#34;&#34;Image URL and URL download properties&#34;&#34;&#34;
        if url is not None:
            self._url = url  # this does not change anything else (e.g. the associated filename), better to use constructor 
        if username is not None:
            self._urluser = username  # basic authentication
        if password is not None:
            self._urlpassword = password  # basic authentication
        if sha1 is not None:
            self._urlsha1 = sha1  # file integrity
        if ignoreUrlErrors is not None:
            self._ignoreErrors = ignoreUrlErrors
        if url is None and username is None and password is None and sha1 is None and ignoreUrlErrors is None:
            return self._url
        else:
            return self
    
    def colorspace(self, colorspace=None):
        &#34;&#34;&#34;Return or set the colorspace as [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;lum&#39;]&#34;&#34;&#34;
        if colorspace is None:
            return self._colorspace
        else:
            assert str(colorspace).lower() in [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;], &#34;Invalid colorspace &#39;%s&#39;. Allowable is [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;]&#34; % colorspace 
            img = self.array()
            if self.isloaded():
                colorspace = str(colorspace).lower()
                if self.array().dtype == np.float32:
                    assert colorspace in [&#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;], &#34;Invalid colorspace &#39;%s&#39; for float32 array()&#34; % colorspace
                elif self.array().dtype == np.uint8:
                    assert colorspace in  [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;lum&#39;], &#34;Invalid colorspace &#39;%s&#39; for uint8 array(). Allowable is [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;lum&#39;]&#34; % colorspace
                else:
                    raise ValueError(&#39;unupported array() datatype &#34;%s&#34;.  Allowable is [np.float32, np.uint8]&#39; % colorspace)  # should never get here as long as array() is used to set _array
                if self.channels() == 1:
                    assert colorspace in [&#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;], &#34;Invalid colorspace &#39;%s; for single channel array.  Allowable is [&#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;]&#34; % colorspace
                elif self.channels() == 3:
                    assert colorspace in [&#39;float&#39;, &#39;rgb&#39;, &#39;bgr&#39;, &#39;hsv&#39;], &#34;Invalid colorspace &#39;%s; for three channel array. Allowable is [&#39;float&#39;, &#39;rgb&#39;, &#39;bgr&#39;, &#39;hsv&#39;]&#34; % colorspace
                elif self.channels() == 4:
                    assert colorspace in [&#39;float&#39;, &#39;rgba&#39;, &#39;bgra&#39;], &#34;Invalid colorspace &#39;%s; for four channel array. Allowable is [&#39;float&#39;, &#39;rgba&#39;, &#39;bgra&#39;]&#34; % colorspace                    
                elif colorspace != &#39;float&#39;:
                    raise ValueError(&#34;Invalid colorspace &#39;%s&#39; for image channels=%d, type=%s&#34; % (colorspace, self.channels(), str(self.array().dtype)))
                if colorspace in [&#39;grey&#39;, &#39;gray&#39;]:
                    assert self.max() &lt;= 1 and self.min() &gt;= 0, &#34;Colorspace &#39;grey&#39; image must be np.float32 in range [0,1].  Use colorspace &#39;lum&#39; for np.uint8 in range [0,255], or colorspace &#39;float&#39; for unconstrained np.float32 [-inf, +inf]&#34;
                    colorspace = &#39;grey&#39;  # standardize
            self._colorspace = str(colorspace).lower()
            return self

    def uri(self):
        &#34;&#34;&#34;Return the URI of the image object, either the URL or the filename, raise exception if neither defined&#34;&#34;&#34;
        if self.hasurl():
            return self.url()
        elif self.hasfilename():
            return self.filename()
        else:
            raise ValueError(&#39;No URI defined&#39;)

    def setattribute(self, key, value):
        &#34;&#34;&#34;Set element self.attributes[key]=value&#34;&#34;&#34;
        if self.attributes is None:
            self.attributes = {key: value}
        else:
            self.attributes[key] = value
        return self

    def setattributes(self, newattr):
        &#34;&#34;&#34;Set many attributes at once by providing a dictionary to be merged with current attributes&#34;&#34;&#34;
        assert isinstance(newattr, dict), &#34;New attributes must be dictionary&#34;
        self.attributes.update(newattr)
        return self
    
    def getattribute(self, k):
        &#34;&#34;&#34;Return the key k in the attributes dictionary (self.attributes) if present, else None&#34;&#34;&#34;        
        return self.attributes[k] if k in self.attributes else None        

    def hasattribute(self, key):
        return self.attributes is not None and key in self.attributes

    def delattribute(self, k):
        if k in self.attributes:
            self.attributes.pop(k)
        return self

    def hasurl(self):
        return self._url is not None and isurl(self._url)

    def hasfilename(self):
        return self._filename is not None and os.path.exists(self._filename)

    def clone(self, flushforward=False, flushbackward=False, flush=False, shallow=False, attributes=False):
        &#34;&#34;&#34;Create deep copy of object, flushing the original buffer if requested and returning the cloned object.
        Flushing is useful for distributed memory management to free the buffer from this object, and pass along a cloned 
        object which can be used for encoding and will be garbage collected.
        
            * flushforward: copy the object, and set the cloned object array() to None.  This flushes the video buffer for the clone, not the object
            * flushbackward:  copy the object, and set the object array() to None.  This flushes the video buffer for the object, not the clone.
            * flush:  set the object array() to None and clone the object.  This flushes the video buffer for both the clone and the object.

        &#34;&#34;&#34;
        if flush or (flushforward and flushbackward):
            self._array = None  # flushes buffer on object and clone
            im = copy.deepcopy(self)  # object and clone are flushed
        elif flushbackward:
            im = copy.deepcopy(self)  # propagates _array to clone
            self._array = None   # object flushed, clone not flushed
        elif flushforward:
            array = self._array;
            self._array = None
            im = copy.deepcopy(self)   # does not propagate _array to clone
            self._array = array    # object not flushed
            im._array = None   # clone flushed
        elif shallow:
            im = copy.copy(self)  # shallow copy
            im._array = np.asarray(self._array) if self._array is not None else None  # shared pixels            
        else:
            im = copy.deepcopy(self)
        if attributes:
            im.attributes = copy.deepcopy(self.attributes)
        return im

    def flush(self):
        &#34;&#34;&#34;Alias for clone(flush=True), returns self not clone&#34;&#34;&#34;
        self._array = None  # flushes buffer on object and clone
        return self

        
    # Spatial transformations
    def resize(self, cols=None, rows=None, width=None, height=None, interp=&#39;bilinear&#39;, fast=False):
        &#34;&#34;&#34;Resize the image buffer to (rows x cols) with bilinear interpolation.  If rows or cols is provided, rescale image maintaining aspect ratio&#34;&#34;&#34;
        assert not (cols is not None and width is not None), &#34;Define either width or cols&#34;
        assert not (rows is not None and height is not None), &#34;Define either height or rows&#34;
        rows = rows if height is None else height
        cols = cols if width is None else width
        if cols is None or rows is None:
            if cols is None:
                scale = float(rows) / float(self.height())
            else:
                scale = float(cols) / float(self.width())
            self.rescale(scale)
        elif rows == self.height() and cols == self.width():
            return self  
        elif self.colorspace() == &#39;float&#39;:
            self._array = np.dstack([np.array(im.pil().resize((cols, rows), string_to_pil_interpolation(interp))) for im in self.channel()])
        else:
            self._array = np.asarray(self.load().pil().resize((cols, rows), string_to_pil_interpolation(interp), reducing_gap=2 if fast else None))  
        return self

    def resize_like(self, im, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize image buffer to be the same size as the provided vipy.image.Image()&#34;&#34;&#34;
        assert isinstance(im, Image), &#34;Invalid input - Must be vipy.image.Image()&#34;
        return self.resize(im.width(), im.height(), interp=interp)
    
    def rescale(self, scale=1, interp=&#39;bilinear&#39;, fast=False):
        &#34;&#34;&#34;Scale the image buffer by the given factor - NOT idempotent&#34;&#34;&#34;
        (height, width) = self.load().shape()
        if scale == 1:
            return self
        elif self.colorspace() == &#39;float&#39;:
            self._array = np.dstack([np.asarray(im.pil().resize((int(np.round(scale * width)), int(np.round(scale * height))), string_to_pil_interpolation(interp))) for im in self.channel()])
        else: 
            self._array = np.asarray(self.pil().resize((int(np.round(scale * width)), int(np.round(scale * height))), string_to_pil_interpolation(interp), reducing_gap=2 if fast else None))
        return self

    def maxdim(self, dim=None, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize image preserving aspect ratio so that maximum dimension of image = dim, or return maxdim()&#34;&#34;&#34;
        return self.rescale(float(dim) / float(np.maximum(self.height(), self.width())), interp=interp) if dim is not None else max(self.shape())

    def mindim(self, dim=None, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize image preserving aspect ratio so that minimum dimension of image = dim, or return mindim()&#34;&#34;&#34;
        if dim is None:
            return np.minimum(self.height(), self.width())
        else:
            s = float(dim) / float(np.minimum(self.height(), self.width()))
            return self.rescale(s, interp=interp) if dim is not None else min(self.shape())

    def _pad(self, dx, dy, mode=&#39;edge&#39;):
        &#34;&#34;&#34;Pad image using np.pad mode, dx=padwidth, dy=padheight, thin wrapper for numpy.pad&#34;&#34;&#34;
        self._array = np.pad(self.load().array(),
                             ((dy, dy), (dx, dx), (0, 0)) if
                             self.load().array().ndim == 3 else ((dy, dy), (dx, dx)),
                             mode=mode)
        return self

    def zeropad(self, padwidth, padheight):
        &#34;&#34;&#34;Pad image using np.pad constant by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding&#34;&#34;&#34;
        if not isinstance(padwidth, tuple):
            padwidth = (padwidth, padwidth)
        if not isinstance(padheight, tuple):
            padheight = (padheight, padheight)
        if self.iscolor():
            pad_shape = (padheight, padwidth, (0, 0))
        else:
            pad_shape = (padheight, padwidth)

        assert all([x&gt;=0 for x in padheight]) and all([x&gt;=0 for x in padwidth]), &#34;padding must be positive&#34;
        if padwidth[0]&gt;0 or padwidth[1]&gt;0 or padheight[0]&gt;0 or padheight[1]&gt;0:
            self._array = np.pad(self.load().array(), pad_width=pad_shape, mode=&#39;constant&#39;, constant_values=0)  # this is still slow due to the required copy, but fast-ish in np &gt;= 1.17
            
        return self

    def zeropadlike(self, width, height):
        &#34;&#34;&#34;Zero pad the image balancing the border so that the resulting image size is (width, height)&#34;&#34;&#34;
        assert width &gt;= self.width() and height &gt;= self.height(), &#34;Invalid input - final (width=%d, height=%d) must be greater than current image size (width=%d, height=%d)&#34; % (width, height, self.width(), self.height())
        return self.zeropad( (int(np.floor((width - self.width())/2)), int(np.ceil((width - self.width())/2))),
                             (int(np.floor((height - self.height())/2)), int(np.ceil((height - self.height())/2))))
                            
    def meanpad(self, padwidth, padheight, mu=None):
        &#34;&#34;&#34;Pad image using np.pad constant=image mean by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding&#34;&#34;&#34;        
        if not isinstance(padwidth, tuple):
            padwidth = (padwidth, padwidth)
        if not isinstance(padheight, tuple):
            padheight = (padheight, padheight)
        assert all([x&gt;=0 for x in padheight]) and all([x&gt;=0 for x in padwidth]), &#34;padding must be positive&#34;
        mu = self.meanchannel() if mu is None else mu
        self._array = np.squeeze(np.dstack([np.pad(img,
                                                   pad_width=(padheight,padwidth),
                                                   mode=&#39;constant&#39;,
                                                   constant_values=c) for (img,c) in zip(self.channel(), mu)]))
        return self

    def alphapad(self, padwidth, padheight):
        &#34;&#34;&#34;Pad image using alpha transparency by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding&#34;&#34;&#34;
        assert self.colorspace() == &#39;rgba&#39;, &#34;Colorspace must be RGBA for padding with transparency&#34;
        return self.meanpad(padwidth, padheight, mu=np.array([0,0,0,0]))
    
    def minsquare(self):
        &#34;&#34;&#34;Crop image of size (HxW) to (min(H,W), min(H,W)), keeping upper left corner constant&#34;&#34;&#34;
        S = np.min(self.load().shape())
        return self._crop(BoundingBox(xmin=0, ymin=0, width=int(S), height=int(S)))

    def maxsquare(self, S=None):
        &#34;&#34;&#34;Crop image of size (HxW) to (max(H,W), max(H,W)) with zeropadding or (S,S) if provided, keeping upper left corner constant&#34;&#34;&#34;
        S = np.max(self.load().shape()) if S is None else int(S)
        (H, W) = self.shape()
        (dW, dH) = (max(0, S - W), max(0, S - H))
        if S != W or S != H:
            self._crop(BoundingBox(0, 0, width=min(W, S), height=min(H, S)))
            if (dW &gt; 0 or dH &gt; 0):
                self.zeropad((0,dW), (0,dH))  # crop then zeropad
        return self

    def maxmatte(self):
        &#34;&#34;&#34;Crop image of size (HxW) to (max(H,W), max(H,W)) with balanced zeropadding forming a letterbox with top/bottom matte or pillarbox with left/right matte&#34;&#34;&#34;
        S = np.max(self.load().shape())
        dW = S - self.width()
        dH = S - self.height()
        return self.zeropad((int(np.floor(dW//2)), int(np.ceil(dW//2))), (int(np.floor(dH//2)), int(np.ceil(dH//2))))._crop(BoundingBox(0, 0, width=int(S), height=int(S)))
    
    def centersquare(self):
        &#34;&#34;&#34;Crop image of size (NxN) in the center, such that N=min(width,height), keeping the image centroid constant&#34;&#34;&#34;
        N = int(np.min(self.shape()))
        return self._crop(BoundingBox(xcentroid=float(self.width() / 2.0), ycentroid=float(self.height() / 2.0), width=N, height=N))

    def centercrop(self, height, width):
        &#34;&#34;&#34;Crop image of size (height x width) in the center, keeping the image centroid constant&#34;&#34;&#34;
        return self._crop(BoundingBox(xcentroid=float(self.width() / 2.0), ycentroid=float(self.height() / 2.0), width=int(width), height=int(height)))

    def cornercrop(self, height, width):
        &#34;&#34;&#34;Crop image of size (height x width) from the upper left corner&#34;&#34;&#34;
        return self._crop(BoundingBox(xmin=0, ymin=0, width=int(width), height=int(height)))
    
    def _crop(self, bbox):
        &#34;&#34;&#34;Crop the image buffer using the supplied bounding box object, clipping the box to the image rectangle&#34;&#34;&#34;
        assert isinstance(bbox, BoundingBox) and bbox.valid(), &#34;Invalid input - Must be vipy.geometry.BoundingBox() not &#39;%s&#39;&#34; % (str(type(bbox)))
        if not bbox.isdegenerate() and bbox.hasoverlap(self.load().array()):
            bbox = bbox.imclip(self.load().array()).int()
            self._array = self.array()[bbox.ymin():bbox.ymax(),
                                       bbox.xmin():bbox.xmax()]
        else:
            warnings.warn(&#39;BoundingBox for crop() does not intersect image rectangle - Ignoring&#39;)
        return self

    def crop(self, bbox):
        return self._crop(bbox)
    
    def fliplr(self):
        &#34;&#34;&#34;Mirror the image buffer about the vertical axis - Not idempotent&#34;&#34;&#34;
        self._array = np.fliplr(self.load().array())
        return self

    def flipud(self):
        &#34;&#34;&#34;Mirror the image buffer about the horizontal axis - Not idempotent&#34;&#34;&#34;
        self._array = np.flipud(self.load().array())
        return self
    
    def imagebox(self):
        &#34;&#34;&#34;Return the bounding box for the image rectangle&#34;&#34;&#34;
        return BoundingBox(xmin=0, ymin=0, width=int(self.width()), height=int(self.height()))

    def border_mask(self, pad):
        &#34;&#34;&#34;Return a binary uint8 image the same size as self, with a border of pad pixels in width or height around the edge&#34;&#34;&#34;
        img = np.zeros( (self.height(), self.width()), dtype=np.uint8)
        img[0:pad,:] = 1
        img[-pad:,:] = 1
        img[:,0:pad] = 1
        img[:,-pad:] = 1
        return img
    
    # Color conversion
    def _convert(self, to):
        &#34;&#34;&#34;Supported colorspaces are rgb, rgbab, bgr, bgra, hsv, grey, lum, float&#34;&#34;&#34;
        to = to if to != &#39;gray&#39; else &#39;grey&#39;  # standardize &#39;gray&#39; -&gt; &#39;grey&#39; internally
        self.load()
        if self.colorspace() == to:
            return self
        elif to == &#39;float&#39;:
            img = self.load().array()  # any type
            self._array = np.array(img).astype(np.float32)  # typecast to float32
        elif self.colorspace() == &#39;lum&#39;:
            img = self.load().array()  # single channel, uint8 [0,255]
            assert img.dtype == np.uint8
            img = np.squeeze(img, axis=2) if img.ndim == 3 and img.shape[2] == 1 else img  # remove singleton channel            
            self._array = np.array(PIL.Image.fromarray(img, mode=&#39;L&#39;).convert(&#39;RGB&#39;))  # uint8 luminance [0,255] -&gt; uint8 RGB
            self.colorspace(&#39;rgb&#39;)
            self._convert(to)
        elif self.colorspace() in [&#39;gray&#39;, &#39;grey&#39;]:
            img = self.load().array()  # single channel float32 [0,1]
            img = np.squeeze(img, axis=2) if img.ndim == 3 and img.shape[2] == 1 else img  # remove singleton channel                        
            self._array = np.array(PIL.Image.fromarray(255.0 * img, mode=&#39;F&#39;).convert(&#39;RGB&#39;))  # float32 gray [0,1] -&gt; float32 gray [0,255] -&gt; uint8 RGB
            self.colorspace(&#39;rgb&#39;)
            self._convert(to)
        elif self.colorspace() == &#39;rgba&#39;:
            img = self.load().array()  # uint8 RGBA
            if to == &#39;bgra&#39;:
                self._array = np.array(img)[:,:,::-1]  # uint8 RGBA -&gt; uint8 ABGR
                self._array = self._array[:,:,[1,2,3,0]]  # uint8 ABGR -&gt; uint8 BGRA
            elif to == &#39;rgb&#39;:
                self._array = self._array[:,:,0:-1]  # uint8 RGBA -&gt; uint8 RGB
            else:
                self._array = self._array[:,:,0:-1]  # uint8 RGBA -&gt; uint8 RGB
                self.colorspace(&#39;rgb&#39;)
                self._convert(to)
        elif self.colorspace() == &#39;rgb&#39;:
            img = self.load().array()  # uint8 RGB
            if to in [&#39;grey&#39;, &#39;gray&#39;]:
                self._array = (1.0 / 255.0) * np.array(PIL.Image.fromarray(img).convert(&#39;L&#39;)).astype(np.float32)  # uint8 RGB -&gt; float32 Grey [0,255] -&gt; float32 Grey [0,1]
            elif to == &#39;bgr&#39;:
                self._array = np.array(img)[:,:,::-1]  # uint8 RGB -&gt; uint8 BGR
            elif to == &#39;hsv&#39;:
                self._array = np.array(PIL.Image.fromarray(img).convert(&#39;HSV&#39;))  # uint8 RGB -&gt; uint8 HSV
            elif to == &#39;lum&#39;:
                self._array = np.array(PIL.Image.fromarray(img).convert(&#39;L&#39;))  # uint8 RGB -&gt; uint8 Luminance (integer grey)
            elif to == &#39;rgba&#39;:
                self._array = np.dstack((img, 255*np.ones((img.shape[0], img.shape[1]), dtype=np.uint8)))
            elif to == &#39;bgra&#39;:
                self._array = np.array(img)[:,:,::-1]  # uint8 RGB -&gt; uint8 BGR
                self._array = np.dstack((self._array, np.zeros((img.shape[0], img.shape[1]), dtype=np.uint8)))  # uint8 BGR -&gt; uint8 BGRA
        elif self.colorspace() == &#39;bgr&#39;:
            img = self.load().array()  # uint8 BGR
            self._array = np.array(img)[:,:,::-1]  # uint8 BGR -&gt; uint8 RGB
            self.colorspace(&#39;rgb&#39;)
            self._convert(to)
        elif self.colorspace() == &#39;bgra&#39;:
            img = self.load().array()  # uint8 BGRA
            self._array = np.array(img)[:,:,::-1]  # uint8 BGRA -&gt; uint8 ARGB
            self._array = self._array[:,:,[1,2,3,0]]  # uint8 ARGB -&gt; uint8 RGBA
            self.colorspace(&#39;rgba&#39;)
            self._convert(to)
        elif self.colorspace() == &#39;hsv&#39;:
            img = self.load().array()  # uint8 HSV
            self._array = np.array(PIL.Image.fromarray(img, mode=&#39;HSV&#39;).convert(&#39;RGB&#39;))  # uint8 HSV -&gt; uint8 RGB
            self.colorspace(&#39;rgb&#39;)
            self._convert(to)
        elif self.colorspace() == &#39;float&#39;:
            img = self.load().array()  # float32
            if np.max(img) &gt; 1 or np.min(img) &lt; 0:
                warnings.warn(&#39;Converting float image to &#34;%s&#34; will be rescaled with self.mat2gray() into the range float32 [0,1]&#39; % to)
                img = self.mat2gray().array()
            if not self.channels() in [1,2,3]:
                raise ValueError(&#39;Float image must be single channel or three channel RGB in the range float32 [0,1] prior to conversion&#39;)
            if self.channels() == 3:  # assumed RGB
                self._array = np.uint8(255 * self.array())   # float32 RGB [0,1] -&gt; uint8 RGB [0,255]
                self.colorspace(&#39;rgb&#39;)
            else:
                self._array = (1.0 / 255.0) * np.array(PIL.Image.fromarray(np.uint8(255 * np.squeeze(self.array()))).convert(&#39;L&#39;)).astype(np.float32)  # float32 RGB [0,1] -&gt; float32 gray [0,1]                
                self.colorspace(&#39;grey&#39;)
            self._convert(to)
        elif self.colorspace() is None:
            raise ValueError(&#39;Colorspace must be initialized by constructor or colorspace() to allow for colorspace conversion&#39;)
        else:
            raise ValueError(&#39;unsupported colorspace &#34;%s&#34;&#39; % self.colorspace())

        self.colorspace(to)
        return self

    def affine_transform(self, A):
        &#34;&#34;&#34;Apply a 3x3 affine geometric transformation to the image. 

        See also `vipy.geometry.affine_transform`

        .. note:: The image will be loaded and converted to float() prior to applying the affine transformation.  
        .. note:: This will transform only the pixels
        &#34;&#34;&#34;
        assert isnumpy(A) or isinstance(img, vipy.image.Image), &#34;invalid input&#34;
        assert A.shape == (3,3), &#34;The affine transformation matrix should be the output of vipy.geometry.affine_transformation&#34;
        self._array = vipy.geometry.imtransform(self.load().float().array(), A.astype(np.float32))
        return self

    def rotate(self, r):
        &#34;&#34;&#34;Apply a rotation in radians to the pixels, with origin in upper left &#34;&#34;&#34;
        return self.affine_transform(vipy.geometry.affine_transform(r=r))
    
    def rgb(self):
        &#34;&#34;&#34;Convert the image buffer to three channel RGB uint8 colorspace&#34;&#34;&#34;
        return self._convert(&#39;rgb&#39;)

    def rgba(self):
        &#34;&#34;&#34;Convert the image buffer to four channel RGBA uint8 colorspace&#34;&#34;&#34;
        return self._convert(&#39;rgba&#39;)

    def hsv(self):
        &#34;&#34;&#34;Convert the image buffer to three channel HSV uint8 colorspace&#34;&#34;&#34;
        return self._convert(&#39;hsv&#39;)

    def bgr(self):
        &#34;&#34;&#34;Convert the image buffer to three channel BGR uint8 colorspace&#34;&#34;&#34;
        return self._convert(&#39;bgr&#39;)

    def bgra(self):
        &#34;&#34;&#34;Convert the image buffer to four channel BGR uint8 colorspace&#34;&#34;&#34;
        return self._convert(&#39;bgra&#39;)

    def float(self):
        &#34;&#34;&#34;Convert the image buffer to float32&#34;&#34;&#34;
        return self._convert(&#39;float&#39;)

    def greyscale(self):
        &#34;&#34;&#34;Convert the image buffer to single channel grayscale float32 in range [0,1]&#34;&#34;&#34;
        return self._convert(&#39;gray&#39;)

    def grayscale(self):
        &#34;&#34;&#34;Alias for greyscale()&#34;&#34;&#34;
        return self.greyscale()

    def grey(self):
        &#34;&#34;&#34;Alias for greyscale()&#34;&#34;&#34;
        return self.greyscale()

    def gray(self):
        &#34;&#34;&#34;Alias for greyscale()&#34;&#34;&#34;
        return self.greyscale()

    def luminance(self):
        &#34;&#34;&#34;Convert the image buffer to single channel uint8 in range [0,255] corresponding to the luminance component&#34;&#34;&#34;
        return self._convert(&#39;lum&#39;)

    def lum(self):
        &#34;&#34;&#34;Alias for luminance()&#34;&#34;&#34;
        return self._convert(&#39;lum&#39;)

    def _apply_colormap(self, cm):
        &#34;&#34;&#34;Convert an image to greyscale, then convert to RGB image with matplotlib colormap&#34;&#34;&#34;
        &#34;&#34;&#34;https://matplotlib.org/tutorials/colors/colormaps.html&#34;&#34;&#34;
        cm = plt.get_cmap(cm)
        img = self.grey().numpy()
        self._array = np.uint8(255 * cm(img)[:,:,:3])
        self.colorspace(&#39;rgb&#39;)
        return self

    def jet(self):
        &#34;&#34;&#34;Apply jet colormap to greyscale image and save as RGB&#34;&#34;&#34;
        return self._apply_colormap(&#39;jet&#39;)

    def rainbow(self):
        &#34;&#34;&#34;Apply rainbow colormap to greyscale image and convert to RGB&#34;&#34;&#34;
        return self._apply_colormap(&#39;gist_rainbow&#39;)

    def hot(self):
        &#34;&#34;&#34;Apply hot colormap to greyscale image and convert to RGB&#34;&#34;&#34;
        return self._apply_colormap(&#39;hot&#39;)

    def bone(self):
        &#34;&#34;&#34;Apply bone colormap to greyscale image and convert to RGB&#34;&#34;&#34;
        return self._apply_colormap(&#39;bone&#39;)

    def saturate(self, min, max):
        &#34;&#34;&#34;Saturate the image buffer to be clipped between [min,max], types of min/max are specified by _array type&#34;&#34;&#34;
        return self.array(np.minimum(np.maximum(self.load().array(), min), max))

    def intensity(self):
        &#34;&#34;&#34;Convert image to float32 with [min,max] to range [0,1], force colormap to be &#39;float&#39;.  Equivalent to self.mat2gray()&#34;&#34;&#34;
        self.array((self.load().float().array()) - float(self.min()) / float(self.max() - self.min()))
        return self.colorspace(&#39;float&#39;)

    def mat2gray(self, min=None, max=None):
        &#34;&#34;&#34;Convert the image buffer so that [min,max] -&gt; [0,1], forces conversion to &#39;float&#39; colorspace.  This does not change the number of color channels&#34;&#34;&#34;
        self.array(mat2gray(np.float32(self.load().float().array()), min, max))
        return self.colorspace(&#39;float&#39;)
        return self

    def gain(self, g):
        &#34;&#34;&#34;Elementwise multiply gain to image array, Gain should be broadcastable to array().  This forces the colospace to &#39;float&#39;&#34;&#34;&#34;
        return self.array(np.multiply(self.load().float().array(), g)).colorspace(&#39;float&#39;) if g != 1 else self

    def bias(self, b):
        &#34;&#34;&#34;Add a bias to the image array.  Bias should be broadcastable to array().  This forces the colorspace to &#39;float&#39;&#34;&#34;&#34;
        self.array(self.load().float().array() + b)
        return self.colorspace(&#39;float&#39;)

    def normalize(self, gain, bias):
        &#34;&#34;&#34;Apply a multiplicative gain g and additive bias b, such that self.array() == gain*self.array() + bias.

        This is useful for applying a normalization of an image prior to calling `vipy.image.Image.torch`.

        The following operations are equivalent.

        ```python
        im = vipy.image.RandomImage()
        im.normalize(1/255.0, 0.5) == im.gain(1/255.0).bias(-0.5)
        ```
        
        .. note:: This will force the colorspace to &#39;float&#39;
        &#34;&#34;&#34;
        self.array(gain*self.load().float().array() + bias)
        return self.colorspace(&#39;float&#39;)
    
    # Image statistics
    def stats(self):
        print(self)
        print(&#39;  Channels: %d&#39; % self.channels())
        print(&#39;  Shape: %s&#39; % str(self.shape()))
        print(&#39;  min: %s&#39; % str(self.min()))
        print(&#39;  max: %s&#39; % str(self.max()))
        print(&#39;  mean: %s&#39; % str(self.mean()))
        print(&#39;  channel mean: %s&#39; % str(self.meanchannel()))        
    
    def min(self):
        return np.min(self.load().array().flatten())

    def max(self):
        return np.max(self.load().array().flatten())

    def mean(self):
        &#34;&#34;&#34;Mean over all pixels&#34;&#34;&#34;
        return np.mean(self.load().array().flatten())

    def meanchannel(self, k=None):
        &#34;&#34;&#34;Mean per channel over all pixels.  If channel k is provided, return just the mean for that channel&#34;&#34;&#34;
        C = np.mean(self.load().array(), axis=(0, 1)).flatten()
        return C[k] if k is not None else C
    
    def sum(self):
        return np.sum(self.load().array().flatten())

    # Image visualization
    def closeall(self):
        &#34;&#34;&#34;Close all open figure windows&#34;&#34;&#34;
        vipy.show.closeall()
        return self
    
    def close(self, fignum=None):
        &#34;&#34;&#34;Close the requested figure number, or close all of fignum=None&#34;&#34;&#34;
        if fignum is None:
            return self.closeall()
        else:
            vipy.show.close(fignum)
            return self
    
    def show(self, figure=1, nowindow=False, timestamp=None, timestampfacecolor=&#39;white&#39;, timestampcolor=&#39;black&#39;, mutator=None):
        &#34;&#34;&#34;Display image on screen in provided figure number (clone and convert to RGB colorspace to show), return object&#34;&#34;&#34;
        assert self.load().isloaded(), &#39;Image not loaded&#39;
        im = self.clone() if not mutator else mutator(self.clone())        
        vipy.show.imshow(im.rgb().numpy(), fignum=figure, nowindow=nowindow, timestamp=timestamp, timestampfacecolor=timestampfacecolor, flush=True, timestampcolor=timestampcolor)
        return self

    def save(self, filename):
        &#34;&#34;&#34;Save the current image to a new filename and return the image object&#34;&#34;&#34;
        assert filename is not None, &#34;Invalid filename - must be path to new image filename&#34;
        return self.filename(self.saveas(filename))
        
        
    # Image export
    def pkl(self, pklfile=None):
        &#34;&#34;&#34;save the object to a pickle file and return the object, useful for intermediate saving in long fluent chains&#34;&#34;&#34;
        pklfile = pklfile if pklfile is not None else toextension(self.filename(), &#39;.pkl&#39;)
        remkdir(filepath(pklfile))
        vipy.util.save(self, pklfile)
        return self

    def pklif(self, b, pklfile=None):
        &#34;&#34;&#34;Save the object to the provided pickle file only if b=True. Uuseful for conditional intermediate saving in long fluent chains&#34;&#34;&#34;
        assert isinstance(b, bool)
        return self.pkl(pklfile) if b else self

    def saveas(self, filename=None, writeas=None):
        &#34;&#34;&#34;Save current buffer (not including drawing overlays) to new filename and return filename.  If filename is not provided, use a temporary JPEG filename.&#34;&#34;&#34;
        filename = tempjpg() if filename is None else filename
        if self.colorspace() in [&#39;gray&#39;]:
            imwritegray(self.grayscale()._array, filename)
        elif self.colorspace() != &#39;float&#39;:
            imwrite(self.load().array(), filename, writeas=writeas)
        else:
            raise ValueError(&#39;Convert float image to RGB or gray first. Try self.mat2gray()&#39;)
        return filename

    def saveastmp(self):
        &#34;&#34;&#34;Save current buffer to temp JPEG filename and return filename.  Alias for savetmp()&#34;&#34;&#34;
        return self.saveas(tempjpg())

    def savetmp(self):
        &#34;&#34;&#34;Save current buffer to temp JPEG filename and return filename.   Alias for saveastmp()&#34;&#34;&#34;
        return self.saveastmp()

    def base64(self):
        &#34;&#34;&#34;Export a base64 encoding of the image suitable for embedding in an html page&#34;&#34;&#34;
        buf = io.BytesIO()
        self.clone().rgb().pil().save(buf, format=&#39;JPEG&#39;)
        return base64.b64encode(buf.getvalue())
        
    def ascii(self):
        &#34;&#34;&#34;Export a base64 ascii encoding of the image suitable for embedding in an &lt;img&gt; tag&#34;&#34;&#34;
        return self.base64().decode(&#39;ascii&#39;)

    def html(self, alt=None, id=None, attributes={&#39;loading&#39;:&#39;lazy&#39;}):
        &#34;&#34;&#34;Export a base64 encoding of the image suitable for embedding in an html page, enclosed in &lt;img&gt; tag
           
           Returns:
              -string:  &lt;img src=&#34;data:image/jpeg;charset=utf-8;base64,%s&#34; alt=&#34;%s&#34; loading=&#34;lazy&#34;&gt; containing base64 encoded JPEG and alt text with lazy loading
        &#34;&#34;&#34;
        assert isinstance(attributes, dict)
        b = self.base64().decode(&#39;ascii&#39;)
        alt_text = alt if alt is not None else self.filename()
        id = id if id is not None else self.filename()
        attr = &#39; &#39;.join([&#39;%s=&#34;%s&#34;&#39; % (str(k),str(v)) for (k,v) in attributes.items()])
        return &#39;&lt;img %ssrc=&#34;data:image/jpeg;charset=utf-8;base64,%s&#34; alt=&#34;%s&#34; %s&gt;&#39; % ((&#39;id=&#34;%s&#34; &#39; % id) if id is not None else &#39;&#39;, b, str(alt_text), attr)

    def annotate(self, timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None):
        &#34;&#34;&#34;Change pixels of this image to include rendered annotation and return an image object&#34;&#34;&#34;
        # FIXME: for k in range(0,10): self.annotate().show(figure=k), this will result in cumulative figures
        return self.array(self.savefig(timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, mutator=mutator, fontsize=fontsize).rgb().array()).downcast()

    def savefig(self, filename=None, figure=1, timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None):
        &#34;&#34;&#34;Save last figure output from self.show() with drawing overlays to provided filename and return filename&#34;&#34;&#34;
        self.show(figure=figure, nowindow=True, timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, mutator=mutator)  # sets figure dimensions, does not display window
        (W,H) = plt.figure(figure).canvas.get_width_height()  # fast
        buf = io.BytesIO()
        plt.figure(1).canvas.print_raw(buf)  # fast
        img = np.frombuffer(buf.getbuffer(), dtype=np.uint8).reshape((H, W, 4))  # RGBA
        vipy.show.close(figure)
        t = vipy.image.Image(array=img, colorspace=&#39;rgba&#39;)
        if filename is not None:
            t.rgb().saveas(os.path.abspath(os.path.expanduser(filename)))
        return t

    def map(self, func):
        &#34;&#34;&#34;Apply lambda function to our numpy array img, such that newimg=f(img), then replace newimg -&gt; self.array().  The output of this lambda function must be a numpy array and if the channels or dtype changes, the colorspace is set to &#39;float&#39;&#34;&#34;&#34;
        assert isinstance(func, types.LambdaType), &#34;Input must be lambda function (e.g. f = lambda img: 255.0-img)&#34;
        oldimg = self.array()  # reference
        newimg = func(self.array())  # in-place
        assert isnumpy(newimg), &#34;Lambda function output must be numpy array&#34;
        self.array(newimg)  # reference
        if newimg.dtype != oldimg.dtype or newimg.shape != oldimg.shape:
            self.colorspace(&#39;float&#39;)  # unknown colorspace after transformation, set generic
        return self

    def downcast(self):
        &#34;&#34;&#34;Cast the class to the base class (vipy.image.Image)&#34;&#34;&#34;
        self.__class__ = vipy.image.Image
        return self

    def perceptualhash(self, bits=128, asbinary=False, asbytes=False):
        &#34;&#34;&#34;Perceptual differential hash function

        This function converts to greyscale, resizes with linear interpolation to small image based on desired bit encoding, compute vertical and horizontal gradient signs.
        
        Args:
            bits: [int]  longer hashes have lower TAR (true accept rate, some near dupes are missed), but lower FAR (false accept rate), shorter hashes have higher TAR (fewer near-dupes are missed) but higher FAR (more non-dupes are declared as dupes).
            asbinary: [bool] If true, return a binary array
            asbytes: [bool] if true return a byte array

        Returns:
            A hash string encoding the perceptual hash such that `vipy.image.Image.perceptualhash_distance` can be used to compute a hash distance
            asbytes: a bytes array
            asbinary: a numpy binary array            

        .. notes::
            - Can be used for near duplicate detection by unpacking the returned hex string to binary and computing hamming distance, or performing hamming based nearest neighbor indexing.  Equivalently, `vipy.image.Image.perceptualhash_distance`.
            - The default packed hex output can be converted to binary as: np.unpackbits(bytearray().fromhex(h)
        &#34;&#34;&#34;        
        allowablebits = [2*k*k for k in range(2, 17)]
        assert bits in allowablebits, &#34;Bits must be in %s&#34; % str(allowablebits)
        sq = int(np.ceil(np.sqrt(bits/2.0)))
        im = self.clone()
        b = (np.dstack(np.gradient(im.resize(cols=sq+1, rows=sq+1).greyscale().numpy()))[0:-1, 0:-1] &gt; 0).flatten()
        return bytes(np.packbits(b)).hex() if not (asbytes or asbinary) else bytes(np.packbits(b)) if asbytes else b

    @staticmethod
    def perceptualhash_distance(h1, h2):
        &#34;&#34;&#34;Hamming distance between two perceptual hashes&#34;&#34;&#34;
        assert len(h1) == len(h2)
        return np.sum(np.unpackbits(bytearray().fromhex(h1)) != np.unpackbits(bytearray().fromhex(h2)))
    

    def rot90cw(self):
        &#34;&#34;&#34;Rotate the scene 90 degrees clockwise&#34;&#34;&#34;
        self.array(np.rot90(self.numpy(), 3))
        return self

    def rot90ccw(self):
        &#34;&#34;&#34;Rotate the scene 90 degrees counterclockwise&#34;&#34;&#34;
        self.array(np.rot90(self.numpy(), 1))
        return self

    
class ImageCategory(Image):
    &#34;&#34;&#34;vipy ImageCategory class

    This class provides a representation of a vipy.image.Image with a category. 

    Valid constructors include all provided by vipy.image.Image with the additional kwarg &#39;category&#39; (or alias &#39;label&#39;)

    ```python
    im = vipy.image.ImageCategory(filename=&#39;/path/to/dog_image.ext&#39;, category=&#39;dog&#39;)
    im = vipy.image.ImageCategory(url=&#39;http://path/to/dog_image.ext&#39;, category=&#39;dog&#39;)
    im = vipy.image.ImageCategory(array=dog_img, colorspace=&#39;rgb&#39;, category=&#39;dog&#39;)
    ```

    &#34;&#34;&#34;
    
    def __init__(self, filename=None, url=None, category=None, label=None,
                 attributes=None, array=None, colorspace=None):
        # Image class inheritance
        super().__init__(filename=filename,
                         url=url,
                         attributes=attributes,
                         array=array,
                         colorspace=colorspace)
        assert not (category is not None and label is not None), &#34;Define either category or label kwarg, not both&#34;
        self._category = category if category is not None else label

    @classmethod
    def cast(cls, im, flush=False):
        assert isinstance(im, vipy.image.Image)
        im.__class__ = vipy.image.ImageCategory
        im._category = None if flush or not hasattr(im, &#39;_category&#39;) else im._category
        return im

    @classmethod
    def from_json(obj, s):
        im = super().from_json(s)
        im._category = json.loads(s)[&#39;_category&#39;]
        return im

    def json(self, s=None, encode=True):
        if s is None:
            d = json.loads(super().json())
            d[&#39;_category&#39;] = self._category
            return json.dumps(d) if encode else d
        else:
            super().json(s)
            d = json.loads(s)            
            self._category = d[&#39;_category&#39;]
            return self
    
    def __repr__(self):
        strlist = []
        if self.isloaded():
            strlist.append(&#34;height=%d, width=%d, color=%s&#34; % (self.height(), self.width(), self.colorspace()))
        if self.filename() is not None:
            strlist.append(&#39;filename=&#34;%s&#34;&#39; % (self.filename() if self.hasfilename() else &#39;&lt;NOTFOUND&gt;%s&lt;/NOTFOUND&gt;&#39; % self.filename()))
        if self.hasurl():
            strlist.append(&#39;url=&#34;%s&#34;&#39; % self.url())
        if self.category() is not None:
            strlist.append(&#39;category=&#34;%s&#34;&#39; % self.category())
        return str(&#39;&lt;vipy.imagecategory: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def __eq__(self, other):
        return self._category.lower() == other._category.lower() if isinstance(other, ImageCategory) else False

    def __ne__(self, other):
        return self._category.lower() != other._category.lower()

    def is_(self, other):
        return self.__eq__(other)

    def is_not(self, other):
        return self.__ne__(other)

    def nocategory(self):
        self._category = None
        return self

    def category(self, newcategory=None):
        &#34;&#34;&#34;Return or update the category&#34;&#34;&#34;
        if newcategory is None:
            return self._category
        else:
            self._category = newcategory
            return self

    def label(self, newlabel=None):
        &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
        return self.category(newlabel)
    
    def score(self, newscore=None):
        &#34;&#34;&#34;Real valued score for categorization, larger is better&#34;&#34;&#34;
        if newscore is None:
            return self.getattribute(&#39;score&#39;)
        else:
            self.setattribute(&#39;score&#39;, newscore)
            return self

    def probability(self, newprob=None):
        &#34;&#34;&#34;Real valued probability for categorization, [0,1]&#34;&#34;&#34;
        if newprob is None:
            return self.getattribute(&#39;probability&#39;)
        else:
            self.setattribute(&#39;probability&#39;, newprob)
            self.setattribute(&#39;RawDetectionProbability&#39;, newprob)
            return self
    

class Scene(ImageCategory):
    &#34;&#34;&#34;vipy.image.Scene class

    This class provides a representation of a vipy.image.ImageCategory with one or more vipy.object.Detections.  The goal of this class is to provide a unified representation for all objects in a scene.

    Valid constructors include all provided by vipy.image.Image() and vipy.image.ImageCategory() with the additional kwarg &#39;objects&#39;, which is a list of vipy.object.Detections()

    ```python
    im = vipy.image.Scene(filename=&#39;/path/to/city_image.ext&#39;, category=&#39;city&#39;, objects=[vipy.object.Detection(category=&#39;vehicle&#39;, xmin=0, ymin=0, width=100, height=100)])
    im = vipy.image.Scene(filename=&#39;/path/to/city_image.ext&#39;, category=&#39;city&#39;).objects([vipy.object.Detection(category=&#39;vehicle&#39;, xmin=0, ymin=0, width=100, height=100)])
    im = vipy.image.Scene(filename=&#39;/path/to/city_image.ext&#39;, category=&#39;office&#39;, boxlabels=&#39;face&#39;, xywh=[0,0,100,100])
    im = vipy.image.Scene(filename=&#39;/path/to/city_image.ext&#39;, category=&#39;office&#39;, boxlabels=&#39;face&#39;, xywh=[[0,0,100,100], [100,100,200,200]])
    im = vipy.image.Scene(filename=&#39;/path/to/city_image.ext&#39;, category=&#39;office&#39;, boxlabels=[&#39;face&#39;, &#39;desk&#39;] xywh=[[0,0,100,100], [200,200,300,300]])
    ```

    &#34;&#34;&#34;
    def __init__(self, filename=None, url=None, category=None, attributes=None, objects=None, xywh=None, boxlabels=None, array=None, colorspace=None):
        super().__init__(filename=filename, url=url, attributes=attributes, category=category, array=array, colorspace=colorspace)   # ImageCategory class inheritance
        self._objectlist = []

        if objects is not None:
            if not (isinstance(objects, list) and all([isinstance(bb, vipy.object.Detection) for bb in objects])):
                raise ValueError(&#34;Invalid object list - Input must be [vipy.object.Detection(), ...]&#34;)
            self._objectlist = objects

        detlist = []
        if xywh is not None:
            if (islistoflists(xywh) or istupleoftuples(xywh)) and all([len(bb)==4 for bb in xywh]):
                detlist = [vipy.object.Detection(category=None, xywh=bb) for bb in xywh]
            elif (islist(xywh) or istuple(xywh)) and len(xywh)==4 and all([isnumber(bb) for bb in xywh]):
                detlist = [vipy.object.Detection(category=None, xywh=xywh)]
            else:
                raise ValueError(&#34;Invalid xywh list - Input must be [[x1,y1,w1,h1], ...&#34;)            
        if boxlabels is not None:
            if isstring(boxlabels):
                label = boxlabels
                detlist = [d.category(label) for d in detlist]
            elif (istuple(boxlabels) or islist(boxlabels)) and len(boxlabels) == len(xywh):
                detlist = [d.category(label) for (d,label) in zip(detlist, boxlabels)]
            else:
                raise ValueError(&#34;Invalid boxlabels list - len(boxlabels) must be len(xywh) with corresponding labels for each xywh box  [label1, label2, ...]&#34;)

        self._objectlist = self._objectlist + detlist

    @classmethod
    def cast(cls, im):
        assert isinstance(im, vipy.image.Image), &#34;Invalid input - must be derived from vipy.image.Image&#34;
        if im.__class__ != vipy.image.Image:
            im.__class__ = vipy.image.Image
            im._category = None if not hasattr(im, &#39;_category&#39;) else im._category
            im._objectlist = [] if not hasattr(im, &#39;_objectlist&#39;) else im._objectlist  
        return im
        
    @classmethod
    def from_json(obj, s):
        im = super().from_json(s)
        d = json.loads(s)
        im._objectlist = [vipy.object.Detection.from_json(s) for s in d[&#39;_objectlist&#39;]]        
        return im

    def json(self, s=None, encode=True):
        if s is None:
            d = json.loads(super().json())
            d[&#39;_objectlist&#39;] = [bb.json(encode=False) for bb in self._objectlist]
            return json.dumps(d) if encode else d
        else:
            super().json(s)
            d = json.loads(s)            
            self._objectlist = [vipy.object.Detection.from_json(s) for s in d[&#39;_objectlist&#39;]]
            return self
    
    def __eq__(self, other):
        &#34;&#34;&#34;Scene equality requires equality of all objects in the scene, assumes a total order of objects&#34;&#34;&#34;
        return isinstance(other, Scene) and len(self)==len(other) and all([obj1 == obj2 for (obj1, obj2) in zip(self, other)])

    def __repr__(self):
        strlist = []
        if self.isloaded():
            strlist.append(&#34;height=%d, width=%d, color=%s&#34; % (self.height(), self.width(), self.colorspace()))
        if self.filename() is not None:
            strlist.append(&#39;filename=&#34;%s&#34;&#39; % (self.filename() if self.hasfilename() else &#39;&lt;NOTFOUND&gt;%s&lt;/NOTFOUND&gt;&#39; % self.filename()))
        if self.hasurl():
            strlist.append(&#39;url=%s&#39; % self.url())
        if self.category() is not None:
            strlist.append(&#39;category=&#34;%s&#34;&#39; % self.category())
        if len(self.objects()) &gt; 0:
            strlist.append(&#39;objects=%d&#39; % len(self.objects()))
        return str(&#39;&lt;vipy.image.scene: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def __len__(self):
        &#34;&#34;&#34;The length of a scene is equal to the number of objects present in the scene&#34;&#34;&#34;
        return len(self._objectlist)

    def __iter__(self):
        &#34;&#34;&#34;Iterate over each ImageDetection() in the scene&#34;&#34;&#34;
        for (k, im) in enumerate(self._objectlist):
            yield self.__getitem__(k)

    def __getitem__(self, k):
        &#34;&#34;&#34;Return the kth object in the scene as an ImageDetection&#34;&#34;&#34;
        assert isinstance(k, int), &#34;Indexing by object in scene must be integer&#34;
        obj = self._objectlist[k].clone()
        return (ImageDetection(array=self.array(), filename=self.filename(), url=self.url(), colorspace=self.colorspace(), bbox=obj, category=obj.category(), attributes=obj.attributes))

    def append(self, imdet):
        &#34;&#34;&#34;Append the provided vipy.object.Detection object to the scene object list&#34;&#34;&#34;
        assert isinstance(imdet, vipy.object.Detection), &#34;Invalid input&#34;
        self._objectlist.append(imdet)
        return self

    def add(self, imdet):
        &#34;&#34;&#34;Alias for append&#34;&#34;&#34;        
        return self.append(imdet)
    
    def objects(self, objectlist=None):
        if objectlist is None:
            return self._objectlist
        else:
            assert isinstance(objectlist, list) and (len(objectlist) == 0 or all([isinstance(bb, vipy.object.Detection) for bb in objectlist])), &#34;Invalid object list&#34;
            self._objectlist = objectlist
            return self

    def objectmap(self, f):
        &#34;&#34;&#34;Apply lambda function f to each object.  If f is a list of lambda, apply one to one with the objects&#34;&#34;&#34;
        assert callable(f)
        self._objectlist = [f(obj)  for obj in self._objectlist] if not isinstance(f, list) else [g(obj) for (g,obj) in zip(f, self._objectlist)]
        assert all([isinstance(a, vipy.object.Detection) for a in self.objects()]), &#34;Lambda function must return vipy.object.Detection&#34;
        return self

    def objectfilter(self, f):
        &#34;&#34;&#34;Apply lambda function f to each object and keep if filter is True&#34;&#34;&#34;
        assert callable(f)
        self._objectlist = [obj for obj in self._objectlist if f(obj) is True]
        return self

    def nms(self, conf, iou, cover=0.8):
        &#34;&#34;&#34;Non-maximum supporession of objects() by category based on confidence and spatial IoU and cover thresholds&#34;&#34;&#34;
        return self.objects( vipy.object.non_maximum_suppression(self.objects(), conf=conf, iou=iou, cover=cover, bycategory=True) )

    def intersection(self, other, miniou, bycategory=True):
        &#34;&#34;&#34;Return a Scene() containing the objects in both self and other, that overlap by miniou with greedy assignment&#34;&#34;&#34;
        assert isinstance(other, Scene), &#34;Invalid input&#34;
        v = self.clone()
        v._objectlist = [v._objectlist[k] for (k,d) in enumerate(greedy_assignment(v.objects(), other.objects(), miniou, bycategory=bycategory)) if d is not None]
        return v

    def difference(self, other, miniou):
        &#34;&#34;&#34;Return a Scene() containing the objects in self but not other, that overlap by miniou with greedy assignment&#34;&#34;&#34;
        assert isinstance(other, Scene), &#34;Invalid input&#34;
        v = self.clone()
        v._objectlist = [v._objectlist[k] for (k,d) in enumerate(greedy_assignment(self.objects(), other.objects(), miniou, bycategory=True)) if d is None]
        return v
        
    def union(self, other, miniou=None):
        &#34;&#34;&#34;Combine the objects of the scene with other and self with no duplicate checking unless miniou is not None&#34;&#34;&#34;
        if isinstance(other, Scene):
            self.objects(self.objects()+other.objects())
        return self

    def uncrop(self, bb, shape):
        &#34;&#34;&#34;Uncrop a previous crop(bb) called with the supplied bb=BoundingBox(), and zeropad to shape=(H,W)&#34;&#34;&#34;
        super().uncrop(bb, shape)
        return self.objectmap(lambda o: o.translate(bb.xmin(), bb.ymin()))
        
    def clear(self):
        &#34;&#34;&#34;Remove all objects from this scene.&#34;&#34;&#34;
        return self.objects([])
    
    def boundingbox(self):
        &#34;&#34;&#34;The boundingbox of a scene is the union of all object bounding boxes, or None if there are no objects&#34;&#34;&#34;
        boxes = self.objects()
        bb = boxes[0].clone() if len(boxes) &gt;= 1 else None
        return bb.union(boxes[1:]) if len(boxes) &gt;= 2 else bb

    def categories(self):
        &#34;&#34;&#34;Return list of unique object categories in scene&#34;&#34;&#34;
        return list(set([obj.category() for obj in self._objectlist]))
    
    # Spatial transformation
    def imclip(self):
        &#34;&#34;&#34;Clip all bounding boxes to the image rectangle, silently rejecting those boxes that are degenerate or outside the image&#34;&#34;&#34;
        self._objectlist = [bb.imclip(self.numpy()) for bb in self._objectlist if bb.hasoverlap(self.numpy())]
        return self

    def rescale(self, scale=1, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Rescale image buffer and all bounding boxes - Not idempotent&#34;&#34;&#34;
        self = super().rescale(scale, interp=interp)
        self._objectlist = [bb.rescale(scale) for bb in self._objectlist]
        return self

    def resize(self, cols=None, rows=None, height=None, width=None, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize image buffer to (height=rows, width=cols) and transform all bounding boxes accordingly.  If cols or rows is None, then scale isotropically&#34;&#34;&#34;
        assert not (cols is not None and width is not None), &#34;Define either width or cols&#34;
        assert not (rows is not None and height is not None), &#34;Define either height or rows&#34;
        rows = rows if height is None else height
        cols = cols if width is None else width        
        assert cols is not None or rows is not None, &#34;Invalid input&#34;
        
        sx = (float(cols) / self.width()) if cols is not None else None
        sy = (float(rows) / self.height()) if rows is not None else None
        sx = sy if sx is None else sx
        sy = sx if sy is None else sy        
        self._objectlist = [bb.scalex(sx).scaley(sy) for bb in self._objectlist]        
        if sx == sy:
            self = super().rescale(sx, interp=interp)  # FIXME: if we call resize here, inheritance is screweed up
        else:
            self = super().resize(cols, rows, interp=interp)
        return self

    def centersquare(self):
        &#34;&#34;&#34;Crop the image of size (H,W) to be centersquare (min(H,W), min(H,W)) preserving center, and update bounding boxes&#34;&#34;&#34;
        (H,W) = self.shape()
        self = super().centersquare()
        (dy, dx) = ((H - self.height())/2.0, (W - self.width())/2.0)
        self._objectlist = [bb.translate(-dx, -dy) for bb in self._objectlist]
        return self
    
    def fliplr(self):
        &#34;&#34;&#34;Mirror buffer and all bounding box around vertical axis&#34;&#34;&#34;
        self._objectlist = [bb.fliplr(self.numpy()) for bb in self._objectlist]
        self = super().fliplr()
        return self

    def flipud(self):
        &#34;&#34;&#34;Mirror buffer and all bounding box around vertical axis&#34;&#34;&#34;
        self._objectlist = [bb.flipud(self.numpy()) for bb in self._objectlist]
        self = super().flipud()
        return self
    
    def dilate(self, s):
        &#34;&#34;&#34;Dilate all bounding boxes by scale factor, dilated boxes may be outside image rectangle&#34;&#34;&#34;
        self._objectlist = [bb.dilate(s) for bb in self._objectlist]
        return self

    def zeropad(self, padwidth, padheight):
        &#34;&#34;&#34;Zero pad image with padwidth cols before and after and padheight rows before and after, then update bounding box offsets&#34;&#34;&#34;
        self = super().zeropad(padwidth, padheight)
        dx = padwidth[0] if isinstance(padwidth, tuple) and len(padwidth) == 2 else padwidth
        dy = padheight[0] if isinstance(padheight, tuple) and len(padheight) == 2 else padheight
        self._objectlist = [bb.translate(dx, dy) for bb in self._objectlist]
        return self

    def meanpad(self, padwidth, padheight, mu=None):
        &#34;&#34;&#34;Mean pad (image color mean) image with padwidth cols before and after and padheight rows before and after, then update bounding box offsets&#34;&#34;&#34;
        self = super().meanpad(padwidth, padheight, mu=mu)
        dx = padwidth[0] if isinstance(padwidth, tuple) and len(padwidth) == 2 else padwidth
        dy = padheight[0] if isinstance(padheight, tuple) and len(padheight) == 2 else padheight
        self._objectlist = [bb.translate(dx, dy) for bb in self._objectlist]
        return self

    def rot90cw(self):
        &#34;&#34;&#34;Rotate the scene 90 degrees clockwise, and update objects&#34;&#34;&#34;
        (H,W) = self.shape()        
        self.array(np.rot90(self.numpy(), 3))
        self._objectlist = [bb.rot90cw(H, W) for bb in self._objectlist]
        return self

    def rot90ccw(self):
        &#34;&#34;&#34;Rotate the scene 90 degrees counterclockwise, and update objects&#34;&#34;&#34;
        (H,W) = self.shape()
        self.array(np.rot90(self.numpy(), 1))
        self._objectlist = [bb.rot90ccw(H, W) for bb in self._objectlist]
        return self

    def maxdim(self, dim=None, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize scene preserving aspect ratio so that maximum dimension of image = dim, update all objects&#34;&#34;&#34;
        return super().maxdim(dim, interp=interp) if dim is not None else max(self.shape())  # will call self.rescale() which will update boxes

    def mindim(self, dim=None, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize scene preserving aspect ratio so that minimum dimension of image = dim, update all objects&#34;&#34;&#34;
        return super().mindim(dim, interp=interp) if dim is not None else min(self.shape())  # will call self.rescale() which will update boxes

    def crop(self, bbox=None):
        &#34;&#34;&#34;Crop the image buffer using the supplied bounding box object (or the only object if bbox=None), clipping the box to the image rectangle, update all scene objects&#34;&#34;&#34;
        assert bbox is not None or (len(self) == 1), &#34;Bounding box must be provided if number of objects != 1&#34;
        bbox = bbox if bbox is not None else self._objectlist[0]
        self = super()._crop(bbox)        
        (dx, dy) = (bbox.xmin(), bbox.ymin())
        self._objectlist = [bb.translate(-dx, -dy) for bb in self._objectlist]
        return self

    def objectcrop(self, dilate=1.0, maxsquare=False):
        &#34;&#34;&#34;Crop image using the `vipy.image.Scene.boundingbox` with dilation factor, setting to maxsquare prior to crop as requested.  Crop will be zeropadded if outside the image rectangle.&#34;&#34;&#34;
        bb = self.boundingbox()
        return self.padcrop(bb.dilate(dilate).maxsquareif(maxsquare)) if bb is not None else self
    
    def centercrop(self, height, width):
        &#34;&#34;&#34;Crop image of size (height x width) in the center, keeping the image centroid constant&#34;&#34;&#34;
        return self.crop(BoundingBox(xcentroid=float(self.width() / 2.0), ycentroid=float(self.height() / 2.0), width=int(width), height=int(height)))

    def cornercrop(self, height, width):
        &#34;&#34;&#34;Crop image of size (height x width) from the upper left corner, returning valid pixels only&#34;&#34;&#34;
        return self.crop(BoundingBox(xmin=0, ymin=0, width=int(width), height=int(height)))
    
    def padcrop(self, bbox):
        &#34;&#34;&#34;Crop the image buffer using the supplied bounding box object, zero padding if box is outside image rectangle, update all scene objects&#34;&#34;&#34;
        self.zeropad(bbox.int().width(), bbox.int().height())  # FIXME: this is inefficient
        (dx, dy) = (bbox.width(), bbox.height())
        bbox = bbox.translate(dx, dy)
        self._objectlist = [bb.translate(-dx, -dy) for bb in self._objectlist]        
        self = super()._crop(bbox)        
        (dx, dy) = (bbox.xmin(), bbox.ymin())
        return self

    def cornerpadcrop(self, height, width):
        &#34;&#34;&#34;Crop image of size (height x width) from the upper left corner, returning zero padded result out to (height, width)&#34;&#34;&#34;
        return self.padcrop(BoundingBox(xmin=0, ymin=0, width=width, height=height))
    
    # Image export
    def rectangular_mask(self, W=None, H=None):
        &#34;&#34;&#34;Return a binary array of the same size as the image (or using the
        provided image width and height (W,H) size to avoid an image load),
        with ones inside the bounding box&#34;&#34;&#34;
        if (W is None or H is None):
            (H, W) = (int(np.round(self.height())),
                      int(np.round(self.width())))
        immask = np.zeros((H, W)).astype(np.uint8)
        for bb in self._objectlist:
            if bb.hasoverlap(immask):
                bbm = bb.clone().imclip(self.numpy()).int()
                immask[bbm.ymin():bbm.ymax(), bbm.xmin():bbm.xmax()] = 1
        return immask

    def binarymask(self):
        &#34;&#34;&#34;Alias for rectangular_mask with in-place update&#34;&#34;&#34;
        mask = self.rectangular_mask() if self.channels() == 1 else np.expand_dims(self.rectangular_mask(), axis=2)
        img = self.numpy()
        img[:] = mask[:]  # in-place update
        return self
        
    def bgmask(self):
        &#34;&#34;&#34;Set all pixels outside the bounding box to zero&#34;&#34;&#34;
        mask = self.rectangular_mask() if self.channels() == 1 else np.expand_dims(self.rectangular_mask(), axis=2)
        img = self.numpy()
        img[:] = np.multiply(img, mask)  # in-place update
        return self  

    def fgmask(self):
        &#34;&#34;&#34;Set all pixels inside the bounding box to zero&#34;&#34;&#34;
        mask = self.rectangular_mask() if self.channels() == 1 else np.expand_dims(self.rectangular_mask(), axis=2)
        img = self.numpy()
        img[:] = np.multiply(img, 1.0-mask)  # in-place update
        return self
    
    def setzero(self):
        return self.fgmask()
    
    def pixelmask(self, pixelsize=8):
        &#34;&#34;&#34;Replace pixels within all foreground objects with a privacy preserving pixelated foreground with larger pixels (e.g. like privacy glass)&#34;&#34;&#34;
        assert pixelsize &gt; 1, &#34;Pixelsize is a scale factor such that pixels within the foreground are pixelsize times larger than the background&#34;
        (img, mask) = (self.numpy(), self.rectangular_mask())  # force writeable
        img[mask &gt; 0] = self.clone().rescale(1.0/pixelsize, interp=&#39;nearest&#39;).resize_like(self, interp=&#39;nearest&#39;).numpy()[mask &gt; 0]  # in-place update
        return self

    def pixelize(self, radius=16):
        &#34;&#34;&#34;Alias for pixelmask&#34;&#34;&#34;
        return self.pixelmask(pixelsize=radius)
    def pixelate(self, radius=16):
        &#34;&#34;&#34;Alias for pixelmask&#34;&#34;&#34;
        return self.pixelmask(pixelsize=radius)
        
    
    def blurmask(self, radius=7):
        &#34;&#34;&#34;Replace pixels within all foreground objects with a privacy preserving blurred foreground&#34;&#34;&#34;
        assert radius &gt; 1, &#34;Pixelsize is a scale factor such that pixels within the foreground are pixelsize times larger than the background&#34;
        (img, mask) = (self.numpy(), self.rectangular_mask())  # force writeable
        img[mask &gt; 0] = self.clone().blur(radius).numpy()[mask &gt; 0]  # in-place update
        return self

    def replace(self, newim, broadcast=False):
        &#34;&#34;&#34;Set all image values within the bounding box equal to the provided img, triggers load() and imclip()&#34;&#34;&#34;
        assert isinstance(newim, vipy.image.Image), &#34;Invalid replacement image - Must be vipy.image.Image&#34;
        img = self.numpy()        
        newimg = newim.array()
        for d in self._objectlist:
            d.imclip(newimg).imclip(img)
            img[int(d.ymin()):int(d.ymax()),
                int(d.xmin()):int(d.xmax())] = newimg[int(d.ymin()):int(d.ymax()),
                                                      int(d.xmin()):int(d.xmax())] if not broadcast else newim.clone().resize(int(d.width()), int(d.height())).array()
        return self
    
    def meanmask(self):
        &#34;&#34;&#34;Replace pixels within the foreground objects with the mean pixel color&#34;&#34;&#34;
        img = self.numpy()  # force writeable
        img[self.rectangular_mask() &gt; 0] = self.meanchannel()  # in-place update
        return self

    def perceptualhash(self, bits=128, asbinary=False, asbytes=False, objmask=False):
        &#34;&#34;&#34;Perceptual differential hash function.

        This function sets foreground objects to mean color, convert to greyscale, resize with linear interpolation to small image based on desired bit encoding, compute vertical and horizontal gradient signs.
        
        Args:
            bits: [int]  longer hashes have lower TAR (true accept rate, some near dupes are missed), but lower FAR (false accept rate), shorter hashes have higher TAR (fewer near-dupes are missed) but higher FAR (more non-dupes are declared as dupes).
            objmask: [bool] if true, replace the foreground object masks with the mean color prior to computing
            asbinary: [bool] If true, return a binary array
            asbytes: [bool] if true return a byte array

        Returns:
            A hash string encoding the perceptual hash such that `vipy.image.Image.perceptualhash_distance` can be used to compute a hash distance
            asbytes: a bytes array
            asbinary: a numpy binary array            

        .. notes::
            - Can be used for near duplicate detection of background scenes by unpacking the returned hex string to binary and computing hamming distance, or performing hamming based nearest neighbor indexing.  Equivalently, `vipy.image.Image.perceptualhash_distance`.
            - The default packed hex output can be converted to binary as: np.unpackbits(bytearray().fromhex( bghash() )) which is equivalent to perceptualhash(asbinary=True)
       
        &#34;&#34;&#34;        
        allowablebits = [2*k*k for k in range(2, 17)]
        assert bits in allowablebits, &#34;Bits must be in %s&#34; % str(allowablebits)
        sq = int(np.ceil(np.sqrt(bits/2.0)))
        im = self.clone() if not objmask else self.clone().meanmask()        
        b = (np.dstack(np.gradient(im.resize(cols=sq+1, rows=sq+1).greyscale().numpy()))[0:-1, 0:-1] &gt; 0).flatten()
        return bytes(np.packbits(b)).hex() if not (asbytes or asbinary) else bytes(np.packbits(b)) if asbytes else b

    def fghash(self, bits=8, asbinary=False, asbytes=False):
        &#34;&#34;&#34;Perceptual differential hash function, computed for each foreground region independently&#34;&#34;&#34;
        return [im.crop().perceptualhash(bits=bits, asbinary=asbinary, asbytes=asbytes, objmask=False)  for im in self]

    
    def bghash(self, bits=128, asbinary=False, asbytes=False):
        &#34;&#34;&#34;Percetual differential hash function, masking out foreground regions&#34;&#34;&#34;
        return self.clone().greyscale().perceptualhash(bits=bits, asbinary=asbinary, asbytes=asbytes, objmask=True)
        
    def isduplicate(self, im, threshold, bits=128):
        &#34;&#34;&#34;Background hash near duplicate detection, returns true if self and im are near duplicate images using bghash&#34;&#34;&#34;
        assert isinstance(im, Image), &#34;Invalid input&#34;
        return vipy.image.Image.perceptualhash_distance(self.bghash(bits=bits), im.bghash(bits=bits)) &lt; threshold 
    
        
    def show(self, categories=None, figure=1, nocaption=False, nocaption_withstring=[], fontsize=10, boxalpha=0.25, d_category2color={&#39;Person&#39;:&#39;green&#39;, &#39;Vehicle&#39;:&#39;blue&#39;, &#39;Object&#39;:&#39;red&#39;}, captionoffset=(0,0), nowindow=False, textfacecolor=&#39;white&#39;, textfacealpha=1.0, shortlabel=True, timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None, timestampoffset=(0,0)):
        &#34;&#34;&#34;Show scene detection 

        Args:
           - categories: [list]  List of category (or shortlabel) names in the scene to show
           - fontsize: [int] or [str]: Size of the font, fontsize=int for points, fontsize=&#39;NN:scaled&#39; to scale the font relative to the image size
           - figure: [int] Figure number, show the image in the provided figure=int numbered window
           - nocaption: [bool]  Show or do not show the text caption in the upper left of the box 
           - nocaption_withstring: [list]:  Do not show captions for those detection categories (or shortlabels) containing any of the strings in the provided list
           - boxalpha (float, [0,1]):  Set the text box background to be semi-transparent with an alpha
           - d_category2color (dict):  Define a dictionary of required mapping of specific category() to box colors.  Non-specified categories are assigned a random named color from vipy.show.colorlist()
           - caption_offset (int, int): The relative position of the caption to the upper right corner of the box.
           - nowindow (bool):  Display or not display the image
           - textfacecolor (str): One of the named colors from vipy.show.colorlist() for the color of the textbox background
           - textfacealpha (float, [0,1]):  The textbox background transparency
           - shortlabel (bool):  Whether to show the shortlabel or the full category name in the caption
           - mutator (lambda):  A lambda function with signature lambda im: f(im) which will modify this image prior to show.  Useful for changing labels on the fly
           - timestampoffset (tuple): (x,y) coordinate offsets to shift the upper left corner timestamp
        &#34;&#34;&#34;
        colors = vipy.show.colorlist()
        im = self.clone() if not mutator else mutator(self.clone())
        valid_detections = [obj.clone() for obj in im._objectlist if categories is None or obj.category() in tolist(categories)]  # Detections with valid category
        valid_detections = [obj.imclip(self.numpy()) for obj in valid_detections if obj.hasoverlap(self.numpy())]  # Detections within image rectangle
        valid_detections = [obj.category(obj.shortlabel()) for obj in valid_detections] if shortlabel else valid_detections  # Display name as shortlabel?               
        d_categories2color = {d.category():colors[int(hashlib.sha1(d.category().split(&#39; &#39;)[-1].encode(&#39;utf-8&#39;)).hexdigest(), 16) % len(colors)] for d in valid_detections}   # consistent color mapping by category suffix (space separated)
        d_categories2color.update(d_category2color)  # requested color mapping
        detection_color = [d_categories2color[d.category()] for d in valid_detections]                
        valid_detections = [d if not any([c in d.category() for c in tolist(nocaption_withstring)]) else d.nocategory() for d in valid_detections]  # Detections requested to show without caption
        imdisplay = self.clone().rgb() if self.colorspace() != &#39;rgb&#39; else self  # convert to RGB for show() if necessary
        fontsize_scaled = float(fontsize.split(&#39;:&#39;)[0])*(min(imdisplay.shape())/640.0) if isstring(fontsize) else fontsize
        imdisplay = mutator(imdisplay) if mutator is not None else imdisplay        
        vipy.show.imdetection(imdisplay._array, valid_detections, bboxcolor=detection_color, textcolor=detection_color, fignum=figure, do_caption=(nocaption==False), facealpha=boxalpha, fontsize=fontsize_scaled,
                              captionoffset=captionoffset, nowindow=nowindow, textfacecolor=textfacecolor, textfacealpha=textfacealpha, timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, timestampoffset=timestampoffset)
        return self

    def annotate(self, outfile=None, categories=None, figure=1, nocaption=False, fontsize=10, boxalpha=0.25, d_category2color={&#39;person&#39;:&#39;green&#39;, &#39;vehicle&#39;:&#39;blue&#39;, &#39;object&#39;:&#39;red&#39;}, captionoffset=(0,0), dpi=200, textfacecolor=&#39;white&#39;, textfacealpha=1.0, shortlabel=True, nocaption_withstring=[], timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None, timestampoffset=(0,0)):
        &#34;&#34;&#34;Alias for savefig&#34;&#34;&#34;
        return self.savefig(outfile=outfile, 
                            categories=categories, 
                            figure=figure, 
                            nocaption=nocaption, 
                            fontsize=fontsize, 
                            boxalpha=boxalpha, 
                            d_category2color=d_category2color,
                            captionoffset=captionoffset, 
                            dpi=dpi, 
                            textfacecolor=textfacecolor, 
                            textfacealpha=textfacealpha, 
                            shortlabel=shortlabel, 
                            nocaption_withstring=nocaption_withstring, 
                            timestamp=timestamp, 
                            timestampcolor=timestampcolor, 
                            timestampfacecolor=timestampfacecolor,
                            timestampoffset=timestampoffset,
                            mutator=mutator)

    def savefig(self, outfile=None, categories=None, figure=1, nocaption=False, fontsize=10, boxalpha=0.25, d_category2color={&#39;person&#39;:&#39;green&#39;, &#39;vehicle&#39;:&#39;blue&#39;, &#39;object&#39;:&#39;red&#39;}, captionoffset=(0,0), dpi=200, textfacecolor=&#39;white&#39;, textfacealpha=1.0, shortlabel=True, nocaption_withstring=[], timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None, timestampoffset=(0,0)):
        &#34;&#34;&#34;Save show() output to given file or return buffer without popping up a window&#34;&#34;&#34;
        fignum = figure if figure is not None else 1        
        self.show(categories=categories, figure=fignum, nocaption=nocaption, fontsize=fontsize, boxalpha=boxalpha, 
                  d_category2color=d_category2color, captionoffset=captionoffset, nowindow=True, textfacecolor=textfacecolor, 
                  textfacealpha=textfacealpha, shortlabel=shortlabel, nocaption_withstring=nocaption_withstring, timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, mutator=mutator, timestampoffset=timestampoffset)
        
        if outfile is None:
            buf = io.BytesIO()
            (W,H) = plt.figure(num=fignum).canvas.get_width_height()  # fast(ish)
            plt.figure(num=fignum).canvas.print_raw(buf)  # fast(ish)
            img = np.frombuffer(buf.getbuffer(), dtype=np.uint8).reshape((H, W, 4))
            if figure is None:
                vipy.show.close(plt.gcf().number)   # memory cleanup (useful for video annotation on last frame)
            return vipy.image.Image(array=img, colorspace=&#39;rgba&#39;)
        else:
            vipy.show.savefig(os.path.abspath(os.path.expanduser(outfile)), figure, dpi=dpi, bbox_inches=&#39;tight&#39;, pad_inches=0)
            return outfile

    
class ImageDetection(Scene, BoundingBox):
    &#34;&#34;&#34;vipy.image.ImageDetection class

    This class provides a representation of a vipy.image.Image with a single object detection with a category and a vipy.geometry.BoundingBox

    This class inherits all methods of Scene and BoundingBox.  Be careful with overloaded methods clone(), width() and height() which will 
    correspond to these methods for Scene() and not BoundingBox().  Use bbclone(), bbwidth() or bbheight() to access the subclass. 

    Valid constructors include all provided by vipy.image.Image with the additional kwarg &#39;category&#39; (or alias &#39;label&#39;), and BoundingBox coordinates

    ```python
    im = vipy.image.ImageDetection(filename=&#39;/path/to/dog_image.ext&#39;, category=&#39;dog&#39;, xmin=0, ymin=0, width=100, height=100)
    im = vipy.image.ImageDetection(filename=&#39;/path/to/dog_image.ext&#39;, category=&#39;dog&#39;, xmin=0, ymin=0, xmax=100, ymax=100)
    im = vipy.image.ImageDetection(filename=&#39;/path/to/dog_image.ext&#39;, category=&#39;dog&#39;, xcentroid=50, ycentroid=50, width=100, height=100)
    im = vipy.image.ImageDetection(filename=&#39;/path/to/dog_image.ext&#39;, category=&#39;dog&#39;, bbox=vipy.geometry.BoundingBox(xmin=0, ymin=0, width=100, height=100))
    im = vipy.image.ImageCategory(url=&#39;http://path/to/dog_image.ext&#39;, category=&#39;dog&#39;).boundingbox(xmin=0, ymin=0, width=100, height=100)
    im = vipy.image.ImageCategory(array=dog_img, colorspace=&#39;rgb&#39;, category=&#39;dog&#39;,  xmin=0, ymin=0, width=100, height=100)
    ```

    &#34;&#34;&#34;
    
    def __init__(self, filename=None, url=None, category=None, attributes=None,
                 xmin=None, xmax=None, ymin=None, ymax=None,
                 width=None, bbwidth=None, height=None, bbheight=None,
                 bbox=None, array=None, colorspace=None,
                 xcentroid=None, ycentroid=None):

        # Construction options
        (width, height) = (bbwidth if bbwidth is not None else width, bbheight if bbheight is not None else height)  # alias
        if bbox is not None:
            assert isinstance(bbox, BoundingBox), &#34;Invalid bounding box&#34;
            bbox = vipy.object.Detection.cast(bbox)
            bbox.category(category)
        elif xmin is not None and ymin is not None and xmax is not None and ymax is not None:
            bbox = vipy.object.Detection(xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax, category=category)
        elif xmin is not None and ymin is not None and width is not None and height is not None:
            bbox = vipy.object.Detection(xmin=xmin, ymin=ymin, width=width, height=height, category=category)
        elif xcentroid is not None and ycentroid is not None and width is not None and height is not None:
            bbox = vipy.object.Detection(xcentroid=xcentroid, ycentroid=ycentroid, width=width, height=height, category=category)
        elif (xmin is None and xmax is None and ymin is None and ymax is None and
              width is None and bbwidth is None and height is None and bbheight is None and
              bbox is None and xcentroid is None and ycentroid is None):
            # Empty box to be updated with boundingbox() method
            bbox = vipy.object.Detection(xmin=0, ymin=0, width=0, height=0, category=category)
        else:
            raise ValueError(&#39;Incomplete constructor&#39;)

        # ImageCategory class inheritance
        super().__init__(filename=filename,
                         url=url,
                         category=category,
                         attributes=attributes,
                         objects=[bbox],
                         array=array,
                         colorspace=colorspace)

        self._asbbox = False
        
    def __getattribute__(self, item):
        if item == &#39;bbox&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;
            return self._objectlist[0]
        elif item == &#39;_xmin&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;            
            return self._objectlist[0]._xmin
        elif item == &#39;_ymin&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;            
            return self._objectlist[0]._ymin
        elif item == &#39;_xmax&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;            
            return self._objectlist[0]._xmax
        elif item == &#39;_ymax&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;            
            return self._objectlist[0]._ymax        
        else:
            return super().__getattribute__(item)            

    def __getattr__(self, item):
        if item == &#39;bbox&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;
            return self._objectlist[0]
        else:
            return super().__getattribute__(item)
    
    @classmethod
    def cast(cls, im, flush=True):
        imc = super().cast(im, flush=flush)
    
    def __repr__(self):
        strlist = []
        if self.isloaded():
            strlist.append(&#34;height=%d, width=%d, color=%s&#34; % (self.height(), self.width(), self.colorspace()))
        if self.filename() is not None:
            strlist.append(&#39;filename=&#34;%s&#34;&#39; % (self.filename() if self.hasfilename() else &#39;&lt;NOTFOUND&gt;%s&lt;/NOTFOUND&gt;&#39; % self.filename()))
        if self.hasurl():
            strlist.append(&#39;url=&#34;%s&#34;&#39; % self.url())
        if self.category() is not None:
            strlist.append(&#39;category=&#34;%s&#34;&#39; % self.category())
        if self.bbox.isvalid():
            strlist.append(&#39;bbox=(xmin=%1.1f, ymin=%1.1f, width=%1.1f, height=%1.1f)&#39; %
                           (self.bbox.xmin(), self.bbox.ymin(),self.bbox.width(), self.bbox.height()))
        return str(&#39;&lt;vipy.image.imagedetection: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    
    def __eq__(self, other):
        &#34;&#34;&#34;ImageDetection equality is defined as equivalent categories and boxes (not pixels)&#34;&#34;&#34;
        return self._category.lower() == other._category.lower() and self.bbox == other.bbox if isinstance(other, ImageDetection) else False

    def boundingbox(self, xmin=None, xmax=None, ymin=None, ymax=None,
                    bbox=None, width=None, height=None, dilate=None,
                    xcentroid=None, ycentroid=None):
        &#34;&#34;&#34;Modify the bounding box using the provided parameters, or return the box if no parameters provided&#34;&#34;&#34;
        if (xmin is None and xmax is None and ymin is None and ymax is None
            and bbox is None and width is None and height is None
                and dilate is None and xcentroid is None and ycentroid is None):
            return self.bbox
        elif (xmin is not None and xmax is not None
              and ymin is not None and ymax is not None):
            self.bbox.ulbr((xmin, ymin, xmax, ymax))
        elif bbox is not None:
            assert isinstance(bbox, BoundingBox)
            self.bbox.ulbr(bbox.ulbr())
        elif (xmin is not None and ymin is not None
              and width is not None and height is not None):
            self.bbox.xywh((xmin, ymin, width, height))
        elif (xcentroid is not None and ycentroid is not None
              and width is not None and height is not None):
            self.bbox.cxywh((xcentroid, ycentroid, width, height))
        elif (dilate is None):
            raise ValueError(&#39;Invalid bounding box&#39;)

        if dilate is not None:
            self.bbox.dilate(dilate)

        return self

    def asimage(self):
        self._asbbox = False
        return self

    def asbbox(self):
        self._asbbox = True
        return self

    def boxmap(self, f):
        &#34;&#34;&#34;Apply the lambda function f to the bounding box, and return the imagedetection&#34;&#34;&#34;
        assert callable(f)
        bb = f(self.bbox)
        assert isinstance(bb, BoundingBox), &#34;Lambda function must return BoundingBox()&#34;
        return self
    
    def crop(self, bbox=None):
        &#34;&#34;&#34;Crop the image using the bounding box&#34;&#34;&#34;
        return super().crop(self.boundingbox() if bbox is None else bbox)
    
    def append(self, im):
        raise ValueError(&#39;Unsupported for vipy.image.ImageDetection - use vipy.image.Scene instead&#39;)

    def detection(self):
        return self.boundingbox()

    def isinterior(self, W=None, H=None):
        &#34;&#34;&#34;Is the bounding box fully within the image rectangle?  Use provided image width and height (W,H) to avoid lots of reloads in some conditions&#34;&#34;&#34;
        (W, H) = (W if W is not None else self.width(),
                  H if H is not None else self.height())
        return (self.bbox.xmin() &gt;= 0 and self.bbox.ymin() &gt;= 0
                and self.bbox.xmax() &lt;= W and self.bbox.ymax() &lt;= H)

def mutator_show_trackid(n_digits_in_trackid=5):
    &#34;&#34;&#34;Mutate the image to show track ID with a fixed number of digits appended to the shortlabel as (####)&#34;&#34;&#34;
    return lambda im, k=None: (im.objectmap(lambda o: o.shortlabel(&#39;%s (%s)&#39; % (o.shortlabel(), o.attributes[&#39;__trackid&#39;][0:n_digits_in_trackid]))
                                            if o.hasattribute(&#39;__trackid&#39;) else o))

def mutator_show_jointlabel():
    &#34;&#34;&#34;Deprecated&#34;&#34;&#34;
    return mutator_capitalize()

def mutator_show_trackindex():
    &#34;&#34;&#34;Mutate the image to show track index appended to the shortlabel as (####)&#34;&#34;&#34;
    return lambda im, k=None: (im.objectmap(lambda o: o.shortlabel(&#39;%s (%d)&#39; % (o.shortlabel(), int(o.attributes[&#39;__trackindex&#39;]))) if o.hasattribute(&#39;__trackindex&#39;) else o))

def mutator_show_trackonly():
    &#34;&#34;&#34;Mutate the image to show track as a consistently colored box with no shortlabels&#34;&#34;&#34;
    f = mutator_show_trackindex()
    return lambda im, k=None, f=f: f(im).objectmap(lambda o: o.shortlabel(&#39;__%s&#39; % o.shortlabel()))  # prepending __shortlabel will not show it, but will color boxes correctly
    
def mutator_show_userstring(strlist):
    &#34;&#34;&#34;Mutate the image to show user supplied strings in the shortlabel.  The list be the same length oas the number of objects in the image.  This is not checked.  This is passed to show()&#34;&#34;&#34;
    assert isinstance(strlist, list), &#34;Invalid input&#34;
    return lambda im, k=None, strlist=strlist: im.objectmap([lambda o,s=s: o.shortlabel(s) for s in strlist])

def mutator_show_noun_only(nocaption=False):
    &#34;&#34;&#34;Mutate the image to show the noun only.  
    
    Args:
        nocaption: [bool] If true, then do not display the caption, only consistently colored boxes for the noun. 
    
    ..note:: To color boxes by track rather than noun, use `vipy.image.mutator_show_trackonly`
    &#34;&#34;&#34;
    return lambda im, k=None: (im.objectmap(lambda o: o.shortlabel(&#39;\n&#39;.join([(&#39;__&#39;+n if nocaption else n) for (n,v) in o.attributes[&#39;__noun verb&#39;]])) if o.hasattribute(&#39;__noun verb&#39;) else o))

def mutator_show_nounonly(nocaption=False):
    &#34;&#34;&#34;Alias for `vipy.image.mutator_show_noun_only`&#34;&#34;&#34;
    return mutator_show_noun_only(nocaption=nocaption)

def mutator_show_verb_only():
    &#34;&#34;&#34;Mutate the image to show the verb only&#34;&#34;&#34;
    return lambda im, k=None: (im.objectmap(lambda o: o.shortlabel(&#39;\n&#39;.join([v for (n,v) in o.attributes[&#39;__noun verb&#39;]])) if o.hasattribute(&#39;__noun verb&#39;) else o))

def mutator_show_noun_or_verb():
    &#34;&#34;&#34;Mutate the image to show the verb only if it is non-zero else noun&#34;&#34;&#34;
    return lambda im: (im.objectmap(lambda o: o.shortlabel(&#39;\n&#39;.join([v if len(v)&gt;0 else n for (n,v) in o.attributes[&#39;__noun verb&#39;]])) if o.hasattribute(&#39;__noun verb&#39;) else o))

def mutator_capitalize():
    &#34;&#34;&#34;Mutate the image to show the shortlabel as &#39;Noun Verb1\nNoun Verb2&#39;&#34;&#34;&#34;
    return lambda im, k=None: (im.objectmap(lambda o: o.shortlabel(&#39;\n&#39;.join([&#39;%s %s&#39; % (n.capitalize(), v.capitalize()) for (n,v) in o.attributes[&#39;__noun verb&#39;]])) if o.hasattribute(&#39;__noun verb&#39;) else o))
    
def mutator_show_activityonly():
    return lambda im, k=None: im.objectmap(lambda o: o.shortlabel(&#39;&#39;) if (len(o.attributes[&#39;__noun verb&#39;]) == 1 and len(o.attributes[&#39;__noun verb&#39;][0][1]) == 0) else o)

def mutator_show_trackindex_activityonly():
    &#34;&#34;&#34;Mutate the image to show boxes colored by track index, and only show &#39;noun verb&#39; captions&#34;&#34;&#34;
    f = mutator_show_trackindex()
    return lambda im, k=None, f=f: f(im).objectmap(lambda o: o.shortlabel(&#39;__%s&#39; % o.shortlabel()) if (len(o.attributes[&#39;__noun verb&#39;]) == 1 and len(o.attributes[&#39;__noun verb&#39;][0][1]) == 0) else o)

def mutator_show_trackindex_verbonly(confidence=True, significant_digits=2):
    &#34;&#34;&#34;Mutate the image to show boxes colored by track index, and only show &#39;verb&#39; captions with activity confidence, sorted in decreasing order&#34;&#34;&#34;
    f = mutator_show_trackindex()
    return lambda im, k=None, f=f: f(im).objectmap(lambda o: o.shortlabel(&#39;__%s&#39; % o.shortlabel()) if (len(o.attributes[&#39;__noun verb&#39;]) == 1 and len(o.attributes[&#39;__noun verb&#39;][0][1]) == 0) else o.shortlabel(&#39;\n&#39;.join([&#39;%s %s&#39; % (v, (&#39;(%1.2f)&#39;%float(c)) if (confidence is True and c is not None) else &#39;&#39;) for ((n,v),c) in sorted(zip(o.attributes[&#39;__noun verb&#39;], o.attributes[&#39;__activityconf&#39;]), key=lambda x: float(x[1]), reverse=True)])))


def RandomImage(rows=None, cols=None):
    &#34;&#34;&#34;Return a uniform random color `vipy.image.Image` of size (rows, cols)&#34;&#34;&#34;
    rows = np.random.randint(128, 1024) if rows is None else rows
    cols = np.random.randint(128, 1024) if cols is None else cols
    return Image(array=np.uint8(255 * np.random.rand(rows, cols, 3)), colorspace=&#39;rgb&#39;)


def RandomImageDetection(rows=None, cols=None):
    &#34;&#34;&#34;Return a uniform random color `vipy.image.ImageDetection` of size (rows, cols) with a random bounding box&#34;&#34;&#34;
    rows = np.random.randint(128, 1024) if rows is None else rows
    cols = np.random.randint(128, 1024) if cols is None else cols
    return ImageDetection(array=np.uint8(255 * np.random.rand(rows, cols, 3)), colorspace=&#39;rgb&#39;, category=&#39;RandomImageDetection&#39;,
                          xmin=np.random.randint(0,cols - 16), ymin=np.random.randint(0,rows - 16),
                          bbwidth=np.random.randint(16,cols), bbheight=np.random.randint(16,rows))

def RandomScene(rows=None, cols=None, num_objects=16, url=None):
    &#34;&#34;&#34;Return a uniform random color `vipy.image.Scene` of size (rows, cols) with a specified number of vipy.object.Detection` objects&#34;&#34;&#34;    
    im = RandomImage(rows, cols) if url is None else Image(url=url)
    (rows, cols) = im.shape()
    ims = Scene(array=im.array(), colorspace=&#39;rgb&#39;, category=&#39;scene&#39;, objects=[vipy.object.Detection(&#39;obj%d&#39; % k, xmin=np.random.randint(0,cols - 16), ymin=np.random.randint(0,rows - 16),
                                                                                                     width=np.random.randint(16,cols), height=np.random.randint(16,rows))
                                                                               for k in range(0,num_objects)])
    return ims
    

def owl():
    &#34;&#34;&#34;Return a superb owl image for testing&#34;&#34;&#34;
    return Scene(url=&#39;https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Bubo_virginianus_06.jpg/1920px-Bubo_virginianus_06.jpg&#39;,
                 category=&#39;Nature&#39;,
                 objects=[vipy.object.Detection(&#39;Great Horned Owl&#39;, xmin=350, ymin=320, width=1400, height=2100)]).mindim(512)

def squareowl():
    &#34;&#34;&#34;Return a superb owl with no objects, cropped square at 512x512 resolution&#34;&#34;&#34;
    return owl().clear().centersquare().mindim(512)


def Owl():
    &#34;&#34;&#34;Return superb owl centersquare, mindim=512&#34;&#34;&#34;
    return owl().centersquare().mindim(512)

def vehicles():
    &#34;&#34;&#34;Return a highway scene with the four highest confidence vehicle detections for testing&#34;&#34;&#34;
    return Scene(url=&#39;https://upload.wikimedia.org/wikipedia/commons/3/3e/I-80_Eastshore_Fwy.jpg&#39;,
                 category=&#39;Highway&#39;,
                 objects=[vipy.object.Detection(category=&#34;car&#34;, xywh=(473.0, 592.2, 92.4, 73.4)),
                          vipy.object.Detection(category=&#34;car&#34;, xywh=(1410.0, 756.1, 175.2, 147.3)),
                          vipy.object.Detection(category=&#34;car&#34;, xywh=(316.9, 640.1, 119.4, 119.5)),
                          vipy.object.Detection(category=&#34;car&#34;, xywh=(886.9, 892.9, 223.8, 196.6))]).mindim(512)

def people():
    &#34;&#34;&#34;Return a crowd scene with the four highest confidence person detections for testing&#34;&#34;&#34;
    return Scene(url=&#39;https://upload.wikimedia.org/wikipedia/commons/b/be/July_4_crowd_at_Vienna_Metro_station.jpg&#39;,
                 category=&#39;crowd&#39;,
                 objects=[vipy.object.Detection(category=&#34;person&#34;, xywh=(1.8, 1178.7, 574.1, 548.0)),
                          vipy.object.Detection(category=&#34;person&#34;, xywh=(1589.4, 828.3, 363.0, 887.7)),
                          vipy.object.Detection(category=&#34;person&#34;, xywh=(1902.9, 783.1, 250.8, 825.8)),
                          vipy.object.Detection(category=&#34;person&#34;, xywh=(228.2, 948.7, 546.8, 688.5))]).mindim(512)

def show(img, mindim=512, figure=1):
    &#34;&#34;&#34;Fast visualization of a numpy array img
        
    ```python
    im = vipy.image.show(np.random.rand(16,16,3))
    ```

    &#34;&#34;&#34;
    assert isnumpy(img)
    return vipy.image.Image(array=np.array(img).astype(np.float32), colorspace=&#39;float&#39;).mindim(mindim, interp=&#39;nearest&#39;).show(figure=figure)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vipy.image.Owl"><code class="name flex">
<span>def <span class="ident">Owl</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return superb owl centersquare, mindim=512</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2467-L2469" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def Owl():
    &#34;&#34;&#34;Return superb owl centersquare, mindim=512&#34;&#34;&#34;
    return owl().centersquare().mindim(512)</code></pre>
</details>
</dd>
<dt id="vipy.image.RandomImage"><code class="name flex">
<span>def <span class="ident">RandomImage</span></span>(<span>rows=None, cols=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a uniform random color <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> of size (rows, cols)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2431-L2435" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def RandomImage(rows=None, cols=None):
    &#34;&#34;&#34;Return a uniform random color `vipy.image.Image` of size (rows, cols)&#34;&#34;&#34;
    rows = np.random.randint(128, 1024) if rows is None else rows
    cols = np.random.randint(128, 1024) if cols is None else cols
    return Image(array=np.uint8(255 * np.random.rand(rows, cols, 3)), colorspace=&#39;rgb&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.RandomImageDetection"><code class="name flex">
<span>def <span class="ident">RandomImageDetection</span></span>(<span>rows=None, cols=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a uniform random color <code><a title="vipy.image.ImageDetection" href="#vipy.image.ImageDetection">ImageDetection</a></code> of size (rows, cols) with a random bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2438-L2444" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def RandomImageDetection(rows=None, cols=None):
    &#34;&#34;&#34;Return a uniform random color `vipy.image.ImageDetection` of size (rows, cols) with a random bounding box&#34;&#34;&#34;
    rows = np.random.randint(128, 1024) if rows is None else rows
    cols = np.random.randint(128, 1024) if cols is None else cols
    return ImageDetection(array=np.uint8(255 * np.random.rand(rows, cols, 3)), colorspace=&#39;rgb&#39;, category=&#39;RandomImageDetection&#39;,
                          xmin=np.random.randint(0,cols - 16), ymin=np.random.randint(0,rows - 16),
                          bbwidth=np.random.randint(16,cols), bbheight=np.random.randint(16,rows))</code></pre>
</details>
</dd>
<dt id="vipy.image.RandomScene"><code class="name flex">
<span>def <span class="ident">RandomScene</span></span>(<span>rows=None, cols=None, num_objects=16, url=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a uniform random color <code><a title="vipy.image.Scene" href="#vipy.image.Scene">Scene</a></code> of size (rows, cols) with a specified number of vipy.object.Detection` objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2446-L2453" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def RandomScene(rows=None, cols=None, num_objects=16, url=None):
    &#34;&#34;&#34;Return a uniform random color `vipy.image.Scene` of size (rows, cols) with a specified number of vipy.object.Detection` objects&#34;&#34;&#34;    
    im = RandomImage(rows, cols) if url is None else Image(url=url)
    (rows, cols) = im.shape()
    ims = Scene(array=im.array(), colorspace=&#39;rgb&#39;, category=&#39;scene&#39;, objects=[vipy.object.Detection(&#39;obj%d&#39; % k, xmin=np.random.randint(0,cols - 16), ymin=np.random.randint(0,rows - 16),
                                                                                                     width=np.random.randint(16,cols), height=np.random.randint(16,rows))
                                                                               for k in range(0,num_objects)])
    return ims</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_capitalize"><code class="name flex">
<span>def <span class="ident">mutator_capitalize</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate the image to show the shortlabel as 'Noun Verb1
Noun Verb2'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2413-L2415" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_capitalize():
    &#34;&#34;&#34;Mutate the image to show the shortlabel as &#39;Noun Verb1\nNoun Verb2&#39;&#34;&#34;&#34;
    return lambda im, k=None: (im.objectmap(lambda o: o.shortlabel(&#39;\n&#39;.join([&#39;%s %s&#39; % (n.capitalize(), v.capitalize()) for (n,v) in o.attributes[&#39;__noun verb&#39;]])) if o.hasattribute(&#39;__noun verb&#39;) else o))</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_activityonly"><code class="name flex">
<span>def <span class="ident">mutator_show_activityonly</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2417-L2418" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_activityonly():
    return lambda im, k=None: im.objectmap(lambda o: o.shortlabel(&#39;&#39;) if (len(o.attributes[&#39;__noun verb&#39;]) == 1 and len(o.attributes[&#39;__noun verb&#39;][0][1]) == 0) else o)</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_jointlabel"><code class="name flex">
<span>def <span class="ident">mutator_show_jointlabel</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2373-L2375" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_jointlabel():
    &#34;&#34;&#34;Deprecated&#34;&#34;&#34;
    return mutator_capitalize()</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_noun_only"><code class="name flex">
<span>def <span class="ident">mutator_show_noun_only</span></span>(<span>nocaption=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate the image to show the noun only.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nocaption</code></strong></dt>
<dd>[bool] If true, then do not display the caption, only consistently colored boxes for the noun. </dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;To color boxes by track rather than noun, use <code><a title="vipy.image.mutator_show_trackonly" href="#vipy.image.mutator_show_trackonly">mutator_show_trackonly()</a></code></p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2391-L2399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_noun_only(nocaption=False):
    &#34;&#34;&#34;Mutate the image to show the noun only.  
    
    Args:
        nocaption: [bool] If true, then do not display the caption, only consistently colored boxes for the noun. 
    
    ..note:: To color boxes by track rather than noun, use `vipy.image.mutator_show_trackonly`
    &#34;&#34;&#34;
    return lambda im, k=None: (im.objectmap(lambda o: o.shortlabel(&#39;\n&#39;.join([(&#39;__&#39;+n if nocaption else n) for (n,v) in o.attributes[&#39;__noun verb&#39;]])) if o.hasattribute(&#39;__noun verb&#39;) else o))</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_noun_or_verb"><code class="name flex">
<span>def <span class="ident">mutator_show_noun_or_verb</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate the image to show the verb only if it is non-zero else noun</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2409-L2411" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_noun_or_verb():
    &#34;&#34;&#34;Mutate the image to show the verb only if it is non-zero else noun&#34;&#34;&#34;
    return lambda im: (im.objectmap(lambda o: o.shortlabel(&#39;\n&#39;.join([v if len(v)&gt;0 else n for (n,v) in o.attributes[&#39;__noun verb&#39;]])) if o.hasattribute(&#39;__noun verb&#39;) else o))</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_nounonly"><code class="name flex">
<span>def <span class="ident">mutator_show_nounonly</span></span>(<span>nocaption=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.image.mutator_show_noun_only" href="#vipy.image.mutator_show_noun_only">mutator_show_noun_only()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2401-L2403" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_nounonly(nocaption=False):
    &#34;&#34;&#34;Alias for `vipy.image.mutator_show_noun_only`&#34;&#34;&#34;
    return mutator_show_noun_only(nocaption=nocaption)</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_trackid"><code class="name flex">
<span>def <span class="ident">mutator_show_trackid</span></span>(<span>n_digits_in_trackid=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate the image to show track ID with a fixed number of digits appended to the shortlabel as (####)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2368-L2371" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_trackid(n_digits_in_trackid=5):
    &#34;&#34;&#34;Mutate the image to show track ID with a fixed number of digits appended to the shortlabel as (####)&#34;&#34;&#34;
    return lambda im, k=None: (im.objectmap(lambda o: o.shortlabel(&#39;%s (%s)&#39; % (o.shortlabel(), o.attributes[&#39;__trackid&#39;][0:n_digits_in_trackid]))
                                            if o.hasattribute(&#39;__trackid&#39;) else o))</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_trackindex"><code class="name flex">
<span>def <span class="ident">mutator_show_trackindex</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate the image to show track index appended to the shortlabel as (####)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2377-L2379" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_trackindex():
    &#34;&#34;&#34;Mutate the image to show track index appended to the shortlabel as (####)&#34;&#34;&#34;
    return lambda im, k=None: (im.objectmap(lambda o: o.shortlabel(&#39;%s (%d)&#39; % (o.shortlabel(), int(o.attributes[&#39;__trackindex&#39;]))) if o.hasattribute(&#39;__trackindex&#39;) else o))</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_trackindex_activityonly"><code class="name flex">
<span>def <span class="ident">mutator_show_trackindex_activityonly</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate the image to show boxes colored by track index, and only show 'noun verb' captions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2420-L2423" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_trackindex_activityonly():
    &#34;&#34;&#34;Mutate the image to show boxes colored by track index, and only show &#39;noun verb&#39; captions&#34;&#34;&#34;
    f = mutator_show_trackindex()
    return lambda im, k=None, f=f: f(im).objectmap(lambda o: o.shortlabel(&#39;__%s&#39; % o.shortlabel()) if (len(o.attributes[&#39;__noun verb&#39;]) == 1 and len(o.attributes[&#39;__noun verb&#39;][0][1]) == 0) else o)</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_trackindex_verbonly"><code class="name flex">
<span>def <span class="ident">mutator_show_trackindex_verbonly</span></span>(<span>confidence=True, significant_digits=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate the image to show boxes colored by track index, and only show 'verb' captions with activity confidence, sorted in decreasing order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2425-L2428" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_trackindex_verbonly(confidence=True, significant_digits=2):
    &#34;&#34;&#34;Mutate the image to show boxes colored by track index, and only show &#39;verb&#39; captions with activity confidence, sorted in decreasing order&#34;&#34;&#34;
    f = mutator_show_trackindex()
    return lambda im, k=None, f=f: f(im).objectmap(lambda o: o.shortlabel(&#39;__%s&#39; % o.shortlabel()) if (len(o.attributes[&#39;__noun verb&#39;]) == 1 and len(o.attributes[&#39;__noun verb&#39;][0][1]) == 0) else o.shortlabel(&#39;\n&#39;.join([&#39;%s %s&#39; % (v, (&#39;(%1.2f)&#39;%float(c)) if (confidence is True and c is not None) else &#39;&#39;) for ((n,v),c) in sorted(zip(o.attributes[&#39;__noun verb&#39;], o.attributes[&#39;__activityconf&#39;]), key=lambda x: float(x[1]), reverse=True)])))</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_trackonly"><code class="name flex">
<span>def <span class="ident">mutator_show_trackonly</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate the image to show track as a consistently colored box with no shortlabels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2381-L2384" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_trackonly():
    &#34;&#34;&#34;Mutate the image to show track as a consistently colored box with no shortlabels&#34;&#34;&#34;
    f = mutator_show_trackindex()
    return lambda im, k=None, f=f: f(im).objectmap(lambda o: o.shortlabel(&#39;__%s&#39; % o.shortlabel()))  # prepending __shortlabel will not show it, but will color boxes correctly</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_userstring"><code class="name flex">
<span>def <span class="ident">mutator_show_userstring</span></span>(<span>strlist)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate the image to show user supplied strings in the shortlabel.
The list be the same length oas the number of objects in the image.
This is not checked.
This is passed to show()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2386-L2389" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_userstring(strlist):
    &#34;&#34;&#34;Mutate the image to show user supplied strings in the shortlabel.  The list be the same length oas the number of objects in the image.  This is not checked.  This is passed to show()&#34;&#34;&#34;
    assert isinstance(strlist, list), &#34;Invalid input&#34;
    return lambda im, k=None, strlist=strlist: im.objectmap([lambda o,s=s: o.shortlabel(s) for s in strlist])</code></pre>
</details>
</dd>
<dt id="vipy.image.mutator_show_verb_only"><code class="name flex">
<span>def <span class="ident">mutator_show_verb_only</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate the image to show the verb only</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2405-L2407" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mutator_show_verb_only():
    &#34;&#34;&#34;Mutate the image to show the verb only&#34;&#34;&#34;
    return lambda im, k=None: (im.objectmap(lambda o: o.shortlabel(&#39;\n&#39;.join([v for (n,v) in o.attributes[&#39;__noun verb&#39;]])) if o.hasattribute(&#39;__noun verb&#39;) else o))</code></pre>
</details>
</dd>
<dt id="vipy.image.owl"><code class="name flex">
<span>def <span class="ident">owl</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a superb owl image for testing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2456-L2460" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def owl():
    &#34;&#34;&#34;Return a superb owl image for testing&#34;&#34;&#34;
    return Scene(url=&#39;https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Bubo_virginianus_06.jpg/1920px-Bubo_virginianus_06.jpg&#39;,
                 category=&#39;Nature&#39;,
                 objects=[vipy.object.Detection(&#39;Great Horned Owl&#39;, xmin=350, ymin=320, width=1400, height=2100)]).mindim(512)</code></pre>
</details>
</dd>
<dt id="vipy.image.people"><code class="name flex">
<span>def <span class="ident">people</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a crowd scene with the four highest confidence person detections for testing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2480-L2487" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def people():
    &#34;&#34;&#34;Return a crowd scene with the four highest confidence person detections for testing&#34;&#34;&#34;
    return Scene(url=&#39;https://upload.wikimedia.org/wikipedia/commons/b/be/July_4_crowd_at_Vienna_Metro_station.jpg&#39;,
                 category=&#39;crowd&#39;,
                 objects=[vipy.object.Detection(category=&#34;person&#34;, xywh=(1.8, 1178.7, 574.1, 548.0)),
                          vipy.object.Detection(category=&#34;person&#34;, xywh=(1589.4, 828.3, 363.0, 887.7)),
                          vipy.object.Detection(category=&#34;person&#34;, xywh=(1902.9, 783.1, 250.8, 825.8)),
                          vipy.object.Detection(category=&#34;person&#34;, xywh=(228.2, 948.7, 546.8, 688.5))]).mindim(512)</code></pre>
</details>
</dd>
<dt id="vipy.image.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>img, mindim=512, figure=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Fast visualization of a numpy array img</p>
<pre><code class="language-python">im = vipy.image.show(np.random.rand(16,16,3))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2489-L2498" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def show(img, mindim=512, figure=1):
    &#34;&#34;&#34;Fast visualization of a numpy array img
        
    ```python
    im = vipy.image.show(np.random.rand(16,16,3))
    ```

    &#34;&#34;&#34;
    assert isnumpy(img)
    return vipy.image.Image(array=np.array(img).astype(np.float32), colorspace=&#39;float&#39;).mindim(mindim, interp=&#39;nearest&#39;).show(figure=figure)</code></pre>
</details>
</dd>
<dt id="vipy.image.squareowl"><code class="name flex">
<span>def <span class="ident">squareowl</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a superb owl with no objects, cropped square at 512x512 resolution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2462-L2464" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def squareowl():
    &#34;&#34;&#34;Return a superb owl with no objects, cropped square at 512x512 resolution&#34;&#34;&#34;
    return owl().clear().centersquare().mindim(512)</code></pre>
</details>
</dd>
<dt id="vipy.image.vehicles"><code class="name flex">
<span>def <span class="ident">vehicles</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a highway scene with the four highest confidence vehicle detections for testing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2471-L2478" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def vehicles():
    &#34;&#34;&#34;Return a highway scene with the four highest confidence vehicle detections for testing&#34;&#34;&#34;
    return Scene(url=&#39;https://upload.wikimedia.org/wikipedia/commons/3/3e/I-80_Eastshore_Fwy.jpg&#39;,
                 category=&#39;Highway&#39;,
                 objects=[vipy.object.Detection(category=&#34;car&#34;, xywh=(473.0, 592.2, 92.4, 73.4)),
                          vipy.object.Detection(category=&#34;car&#34;, xywh=(1410.0, 756.1, 175.2, 147.3)),
                          vipy.object.Detection(category=&#34;car&#34;, xywh=(316.9, 640.1, 119.4, 119.5)),
                          vipy.object.Detection(category=&#34;car&#34;, xywh=(886.9, 892.9, 223.8, 196.6))]).mindim(512)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vipy.image.Image"><code class="flex name class">
<span>class <span class="ident">Image</span></span>
<span>(</span><span>filename=None, url=None, array=None, colorspace=None, attributes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.image.Image class</p>
<p>The vipy image class provides a fluent, lazy interface for representing, transforming and visualizing images.
The following constructors are supported:</p>
<pre><code class="language-python">im = vipy.image.Image(filename=&quot;/path/to/image.ext&quot;)
</code></pre>
<p>All image file formats that are readable by PIL are supported here.</p>
<pre><code class="language-python">im = vipy.image.Image(url=&quot;http://domain.com/path/to/image.ext&quot;)
</code></pre>
<p>The image will be downloaded from the provided url and saved to a temporary filename.
The environment variable VIPY_CACHE controls the location of the directory used for saving images, otherwise this will be saved to the system temp directory.</p>
<pre><code class="language-python">im = vipy.image.Image(url=&quot;http://domain.com/path/to/image.ext&quot;, filename=&quot;/path/to/new/image.ext&quot;)
</code></pre>
<p>The image will be downloaded from the provided url and saved to the provided filename.
The url() method provides optional basic authentication set for username and password</p>
<pre><code class="language-python">im = vipy.image.Image(array=img, colorspace='rgb')
</code></pre>
<p>The image will be constructed from a provided numpy array 'img', with an associated colorspace.
The numpy array and colorspace can be one of the following combinations:</p>
<ul>
<li>'rgb': uint8, three channel (red, green, blue)</li>
<li>'rgba':
uint8, four channel (rgb + alpha)</li>
<li>'bgr': uint8, three channel (blue, green, red), such as is returned from cv2.imread()</li>
<li>'bgra':
uint8, four channel</li>
<li>'hsv':
uint8, three channel (hue, saturation, value)</li>
<li>'lum;:
uint8, one channel, luminance (8 bit grey level)</li>
<li>'grey':
float32, one channel in range [0,1] (32 bit intensity)</li>
<li>'float':
float32, any channel in range [-inf, +inf]</li>
</ul>
<p>The most general colorspace is 'float' which is used to manipulate images prior to network encoding, such as applying bias. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>a path to an image file that is readable by PIL</dd>
<dt><strong><code>url</code></strong></dt>
<dd>a url string to an image file that is readable by PIL</dd>
<dt><strong><code>array</code></strong></dt>
<dd>a numpy array of type uint8 or float32 of shape HxWxC=height x width x channels</dd>
<dt><strong><code>colorspace</code></strong></dt>
<dd>a string in ['rgb', 'rgba', 'bgr', 'bgra', 'hsv', 'float', 'grey', 'lum']</dd>
<dt><strong><code>attributes</code></strong></dt>
<dd>a python dictionary that is passed by reference to the image.
This is useful for encoding metadata about the image.
Accessible as im.attributes</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L47-L1583" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Image(object):
    &#34;&#34;&#34;vipy.image.Image class
    
    The vipy image class provides a fluent, lazy interface for representing, transforming and visualizing images.
    The following constructors are supported:

    ```python
    im = vipy.image.Image(filename=&#34;/path/to/image.ext&#34;)
    ```
    
    All image file formats that are readable by PIL are supported here.

    ```python
    im = vipy.image.Image(url=&#34;http://domain.com/path/to/image.ext&#34;)
    ```
    
    The image will be downloaded from the provided url and saved to a temporary filename.
    The environment variable VIPY_CACHE controls the location of the directory used for saving images, otherwise this will be saved to the system temp directory.

    ```python
    im = vipy.image.Image(url=&#34;http://domain.com/path/to/image.ext&#34;, filename=&#34;/path/to/new/image.ext&#34;)
    ```

    The image will be downloaded from the provided url and saved to the provided filename.
    The url() method provides optional basic authentication set for username and password

    ```python
    im = vipy.image.Image(array=img, colorspace=&#39;rgb&#39;)
    ```

    The image will be constructed from a provided numpy array &#39;img&#39;, with an associated colorspace.  The numpy array and colorspace can be one of the following combinations:

    - &#39;rgb&#39;: uint8, three channel (red, green, blue)
    - &#39;rgba&#39;:  uint8, four channel (rgb + alpha)
    - &#39;bgr&#39;: uint8, three channel (blue, green, red), such as is returned from cv2.imread()
    - &#39;bgra&#39;:  uint8, four channel
    - &#39;hsv&#39;:  uint8, three channel (hue, saturation, value)
    - &#39;lum;:  uint8, one channel, luminance (8 bit grey level)
    - &#39;grey&#39;:  float32, one channel in range [0,1] (32 bit intensity)
    - &#39;float&#39;:  float32, any channel in range [-inf, +inf]
    
    The most general colorspace is &#39;float&#39; which is used to manipulate images prior to network encoding, such as applying bias. 
    
    Args:
        filename: a path to an image file that is readable by PIL
        url:  a url string to an image file that is readable by PIL
        array: a numpy array of type uint8 or float32 of shape HxWxC=height x width x channels
        colorspace:  a string in [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;lum&#39;]
        attributes:  a python dictionary that is passed by reference to the image.  This is useful for encoding metadata about the image.  Accessible as im.attributes

    Returns:
        A `vipy.image.Image` object

    &#34;&#34;&#34;

    def __init__(self, filename=None, url=None, array=None, colorspace=None, attributes=None):
        # Private attributes
        self._ignoreErrors = False  # ignore errors during fetch (broken links)
        self._urluser = None      # basic authentication set with url() method
        self._urlpassword = None  # basic authentication set with url() method
        self._urlsha1 = None      # file hash if known
        self._filename = None   # Local filename
        self._url = None        # URL to download
        self._loader = None     # lambda function to load an image, set with loader() method
        self._array = None
        self._colorspace = None
        
        # Initialization
        self._filename = filename
        if url is not None:
            assert isurl(url), &#39;Invalid URL&#39;
        self._url = url
        if array is not None:
            assert isnumpy(array), &#39;Invalid Array - Type &#34;%s&#34; must be np.array()&#39; % (str(type(array)))
        self.array(array)  # shallow copy

        # Guess RGB colorspace if three channel uint8 if colorspace is not provided
        colorspace = &#39;rgb&#39; if (self.isloaded() and self.channels() == 3 and self._array.dtype == np.uint8 and colorspace is None) else colorspace

        # Guess float colorspace if array is float32 and colorspace is not provided        
        colorspace = &#39;float&#39; if (self.isloaded() and self._array.dtype == np.float32 and colorspace is None) else colorspace
        self.colorspace(colorspace)
        
        # Public attributes: passed in as a dictionary
        self.attributes = {} 
        if attributes is not None:
            assert isinstance(attributes, dict), &#34;Attributes must be dictionary&#34;
            self.attributes = attributes

    @classmethod
    def cast(cls, im):
        &#34;&#34;&#34;Typecast the conformal vipy.image object im as `vipy.image.Image`.
        
        This is useful for downcasting `vipy.image.Scene` or `vipy.image.ImageDetection` down to an image.

        ```python
        ims = vipy.image.RandomScene()
        im = vipy.image.Image.cast(im)
        ```

        &#34;&#34;&#34;
        assert isinstance(im, vipy.image.Image), &#34;Invalid input - must derive from vipy.image.Image&#34;
        im.__class__ = vipy.image.Image
        return im
        
    @classmethod
    def from_json(cls, s):
        &#34;&#34;&#34;Import the JSON string s as an `vipy.image.Image` object.
        
        This will perform a round trip such that im1 == im2

        ```python
        im1 = vupy.image.RandomImage()
        im2 = vipy.image.Image.from_json(im1.json())
        assert im1 == im2
        ```
        
        &#34;&#34;&#34;
        d = json.loads(s)        
        return cls(filename=d[&#39;_filename&#39;],
                   url=d[&#39;_url&#39;],
                   array=np.array(d[&#39;_array&#39;], dtype=np.uint8) if d[&#39;_array&#39;] is not None else None,
                   colorspace=d[&#39;_colorspace&#39;],
                   attributes=d[&#39;attributes&#39;])
    
    def __eq__(self, other):
        &#34;&#34;&#34;Images are equivalent if they have the same filename, url and array&#34;&#34;&#34;
        return isinstance(other, Image) and other.filename()==self.filename() and other.url()==self.url() and np.all(other.array() == self.array())

    def __str__(self):
        return self.__repr__()

    def __iter__(self):
        &#34;&#34;&#34;Yield single image for consistency with videos&#34;&#34;&#34;
        yield self

    def __len__(self):
        &#34;&#34;&#34;Images have length 1 always&#34;&#34;&#34;
        return 1
    
    def __array__(self):
        &#34;&#34;&#34;Called on np.array(self) for custom array container, (requires numpy &gt;=1.16)&#34;&#34;&#34;
        return self.numpy()
    
    def __repr__(self):
        strlist = []
        if self.isloaded():
            strlist.append(&#34;height=%d, width=%d, color=%s&#34; % (self._array.shape[0], self._array.shape[1], self.colorspace()))
        if self.colorspace() == &#39;float&#39;:
            strlist.append(&#39;channels=%d&#39; % self.channels())
        if self.filename() is not None:
            strlist.append(&#39;filename=&#34;%s&#34;&#39; % (self.filename() if self.hasfilename() else &#39;&lt;NOTFOUND&gt;%s&lt;/NOTFOUND&gt;&#39; % self.filename()))
        if self.hasfilename():
            strlist.append(&#39;filename=&#34;%s&#34;&#39; % self.filename())
        if self.hasurl():
            strlist.append(&#39;url=&#34;%s&#34;&#39; % self.url())
        return str(&#39;&lt;vipy.image: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def sanitize(self):
        &#34;&#34;&#34;Remove all private keys from the attributes dictionary.
        
        The attributes dictionary is useful storage for arbitrary (key,value) pairs.  However, this storage may contain sensitive information that should be scrubbed from the media before serialization.  As a general rule, any key that is of the form &#39;__keyname&#39; prepended by two underscores is a private key.  This is analogous to private or reserved attributes in the python lanugage.  Users should reserve these keynames for those keys that should be sanitized and removed before any serialization of this object.
        
        ```python
        assert self.setattribute(&#39;__mykey&#39;, 1).sanitize().hasattribute(&#39;__mykey&#39;) == False
        ```

        &#34;&#34;&#34;
        self.attributes = {k:v for (k,v) in self.attributes.items() if not k.startswith(&#39;__&#39;)} if isinstance(self.atttributes, dict) else self.attributes
        return self
    
    def print(self, prefix=&#39;&#39;, verbose=True, sleep=None):
        &#34;&#34;&#34;Print the representation of the image and return self with an optional sleep=n seconds
        
        Useful for debugging in long fluent chains.
        &#34;&#34;&#34;
        if verbose:
            print(prefix+self.__repr__())
        if sleep is not None:
            assert isinstance(sleep, int) and sleep &gt; 0, &#34;Sleep must be a non-negative integer number of seconds&#34;
            time.sleep(sleep)
        return self

    def tile(self, tilewidth, tileheight, overlaprows=0, overlapcols=0):
        &#34;&#34;&#34;Generate an image tiling.
        
        A tiling is a decomposition of an image into overlapping or non-overlapping rectangular regions.  

        Args:
            tilewidth: [int] the image width of each tile
            tileheight: [int] the image height of each tile
            overlaprows: [int] the number of overlapping rows (height) for each tile
            overlapcols: [int] the number of overlapping width (width) for each tile
    
        Returns:
            A list of `vipy.image.Image` objects such that each image is a single tile and the set of these tiles forms the original image
            Each image in the returned list contains the &#39;tile&#39; attribute which encodes the crop used to create the tile.

        .. note:: 
            - `vipy.image.Image.tile` can be undone using `vipy.image.Image.untile`
            - The identity tiling is im.tile(im.widht(), im.height(), overlaprows=0, overlapcols=0)
            - Ragged tiles outside the image boundary are zero padded
            - All annotations are updated properly for each tile, when the source image is `vipy.image.Scene`
        &#34;&#34;&#34;
        assert tilewidth &gt; 0 and tileheight &gt; 0 and overlaprows &gt;= 0 and overlapcols &gt;= 0, &#34;Invalid input&#34;
        assert self.width() &gt;= tilewidth-overlapcols and self.height() &gt;= tileheight-overlaprows, &#34;Invalid input&#34; 
        bboxes = [BoundingBox(xmin=i, ymin=j, width=min(tilewidth, self.width()-i), height=min(tileheight, self.height()-j)) for i in range(0, self.width()-overlapcols, tilewidth-overlapcols) for j in range(0, self.height()-overlaprows, tileheight-overlaprows)]
        return [self.clone(shallow=True, attributes=True).setattribute(&#39;tile&#39;, {&#39;crop&#39;:bb, &#39;shape&#39;:self.shape()}).crop(bb) for bb in bboxes]

    def union(self, other):
        &#34;&#34;&#34;No-op for `vipy.image.Image`&#34;&#34;&#34;
        return self
    
    @classmethod
    def untile(cls, imlist):
        &#34;&#34;&#34;Undo an image tiling and recreate the original image.

        ```python
        tiles = im.tile(im.width()/2, im.height()/2, 0, 0)
        imdst = vipy.image.Image.untile(tiles)
        assert imdst == im
        ```

        Args:
            imlist: this must be the output of `vipy.image.Image.tile`
        
        Returns:
            A  new `vipy.image.Image` object reconstructed from the tiling, such that this is equivalent to the input to vipy.image.Image.tile` 
        
        .. note:: All annotations are updated properly for each tile, when the source image is `vipy.image.Scene`
        &#34;&#34;&#34;
        assert all([isinstance(im, vipy.image.Image) and im.hasattribute(&#39;tile&#39;) for im in imlist]), &#34;invalid image tile list&#34;        
        imc = None
        for im in imlist:
            if imc is None:
                imc = im.clone(shallow=True).array(np.zeros( (im.attributes[&#39;tile&#39;][&#39;shape&#39;][0], im.attributes[&#39;tile&#39;][&#39;shape&#39;][1], im.channels()), dtype=np.uint8))                
            imc = imc.splat(im.array(im.attributes[&#39;tile&#39;][&#39;crop&#39;].clone().to_origin().int().crop(im.array())), im.attributes[&#39;tile&#39;][&#39;crop&#39;])
            if hasattr(im, &#39;objectmap&#39;):
                im.objectmap(lambda o: o.set_origin(im.attributes[&#39;tile&#39;][&#39;crop&#39;]))  # FIXME: only for Scene()
            imc = imc.union(im)
        return imc
    
    def uncrop(self, bb, shape):
        &#34;&#34;&#34;Uncrop using provided bounding box and zeropad to shape=(Height, Width).

        An uncrop is the inverse operation for a crop, which preserves the cropped portion of the image in the correct location and replaces the rest with zeros out to shape.
    
        ```python
        im = vipy.image.RandomImage(128, 128)
        bb = vipy.geometry.BoundingBox(xmin=0, ymin=0, width=64, height=64)
        uncrop = im.crop(bb).uncrop(bb, shape=(128,128))
        ```

        Args:
            bb: [`vipy.geometry.BoundingBox`] the bounding box used to crop the image in self
            shape: [tuple] (height, width) of the uncropped image
    
        Returns:
            this `vipy.image.Image` object with the pixels uncropped.

        .. note:: NOT idempotent.  This will generate different results if run more than once.
        &#34;&#34;&#34;
        ((x,y,w,h), (H,W)) = (bb.xywh(), shape)
        ((dyb, dya), (dxb, dxa)) = ((int(y), int(H-(y+h))), (int(x), int(W-(x+w))))
        self._array = np.pad(self.load().array(),
                             ((dyb, dya), (dxb, dxa), (0, 0)) if
                             self.load().array().ndim == 3 else ((dyb, dya), (dxb, dxa)),
                             mode=&#39;constant&#39;)        
        return self

    def splat(self, im, bb):
        &#34;&#34;&#34;Replace pixels within boundingbox in self with pixels in im&#34;&#34;&#34;
        assert isinstance(im, vipy.image.Image), &#34;invalid image&#34;
        assert (im.width() == bb.width() and im.height() == bb.height()) or bb.isinterior(im.width(), im.height()) and bb.isinterior(self.width(), self.height()), &#34;Invalid bounding box &#39;%s&#39;&#34; % str(bb)
        (x,y,w,h) = bb.xywh()
        self._array[int(y):int(y+h), int(x):int(x+w)] = im.array() if (im.width() == bb.width() and im.height() == bb.height()) else im.array()[int(y):int(y+h), int(x):int(x+w)]
        return self            
        
    def store(self):
        &#34;&#34;&#34;Store the current image file as an attribute of this object.  Useful for archiving an object to be fully self contained without any external references.  
        
           -Remove this stored image using unstore()
           -Unpack this stored image and set up the filename using restore() 
           -This method is more efficient than load() followed by pkl(), as it stores the encoded image as a byte string.
           -Useful for creating a single self contained object for distributed processing.  

        ```python
        v == v.store().restore(v.filename()) 
        ```

        &#34;&#34;&#34;
        assert self.hasfilename(), &#34;Image file not found&#34;
        with open(self.filename(), &#39;rb&#39;) as f:
            self.attributes[&#39;__image__&#39;] = f.read()
        return self

    def unstore(self):
        &#34;&#34;&#34;Delete the currently stored image from store()&#34;&#34;&#34;
        return self.delattribute(&#39;__image__&#39;)

    def restore(self, filename):
        &#34;&#34;&#34;Save the currently stored image to filename, and set up filename&#34;&#34;&#34;
        assert self.hasattribute(&#39;__image__&#39;), &#34;Image not stored&#34;
        with open(filename, &#39;wb&#39;) as f:
            f.write(self.attributes[&#39;__image__&#39;])
        return self.filename(filename)                
    
    def abspath(self):
        &#34;&#34;&#34;Change the path of the filename from a relative path to an absolute path (not relocatable)&#34;&#34;&#34;
        return self.filename(os.path.normpath(os.path.abspath(os.path.expanduser(self.filename()))))

    def relpath(self, parent=None):
        &#34;&#34;&#34;Replace the filename with a relative path to parent (or current working directory if none)&#34;&#34;&#34;
        parent = parent if parent is not None else os.getcwd()
        assert parent in os.path.expanduser(self.filename()), &#34;Parent path &#39;%s&#39; not found in abspath &#39;%s&#39;&#34; % (parent, self.filename())
        return self.filename(PurePath(os.path.expanduser(self.filename())).relative_to(parent))

    def canload(self):
        &#34;&#34;&#34;Return True if the image can be loaded successfully, useful for filtering bad links or corrupt images&#34;&#34;&#34;
        if not self.isloaded():
            try:
                self.load()  # try to load
                return True
            except:
                return False
        else:
            return True
        
    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(s=None, encode=False)

    def json(self, s=None, encode=True):
        if s is None:
            d = {&#39;_filename&#39;:self._filename,
                 &#39;_url&#39;:self._url,
                 &#39;_loader&#39;:self._loader,
                 &#39;_array&#39;:self._array.tolist() if self._array is not None else None,
                 &#39;_colorspace&#39;:self._colorspace,
                 &#39;attributes&#39;:self.attributes}                        
            return json.dumps(d) if encode else d
        else:
            d = json.loads(s)
            self._filename = d[&#39;_filename&#39;]
            self._url = d[&#39;_url&#39;]
            self._loader = d[&#39;_loader&#39;]
            self._array = np.array(d[&#39;_array&#39;], dtype=np.uint8) if d[&#39;_array&#39;] is not None else None
            self._colorspace = d[&#39;_colorspace&#39;]
            self.attributes = d[&#39;attributes&#39;]            
            return self
        
    def loader(self, f):
        &#34;&#34;&#34;Lambda function to load an unsupported image filename to a numpy array.
        
        This lambda function will be executed during load and the result will be stored in self._array
        &#34;&#34;&#34;
        self._loader = f
        return self

    def load(self, ignoreErrors=False, verbose=False):
        &#34;&#34;&#34;Load image to cached private &#39;_array&#39; attribute.

        Args:
            ignoreErrors: [bool] If true, ignore any exceptions thrown during load and print the corresponding error messages.  This is useful for loading images distributed without throwing exceptions when some images may be corrupted.  In this case, the _array attribute will be None and `vipy.image.Image.isloaded` will return false to determine if the image is loaded, which can be used to filter out corrupted images gracefully. 
            verbose: [bool] If true, show additional useful printed output

        Returns:
            This `vipy.image.Image` object with the pixels loaded in self._array as a numpy array.

        .. note:: This loader supports any image file format supported by PIL.  A custom loader can be added using `vipy.image.Image.loader`.
        &#34;&#34;&#34;
        try:
            # Return if previously loaded image
            if self._array is not None:
                return self

            # Download URL to filename
            if self._url is not None:
                self.download(ignoreErrors=ignoreErrors, verbose=verbose)

            # Load filename to numpy array
            if self._loader is not None:
                self._array = self._loader(self._filename).astype(np.float32)  # forcing float32
                self.colorspace(&#39;float&#39;)
            elif isimagefile(self._filename):
                self._array = np.array(PIL.Image.open(self._filename))  # RGB order!
                if self.istransparent():
                    self.colorspace(&#39;rgba&#39;)  # must be before iscolor()
                elif self.iscolor():
                    self.colorspace(&#39;rgb&#39;)
                elif self.isgrey():
                    self.colorspace(&#39;grey&#39;)
                elif self.isluminance():
                    self.colorspace(&#39;lum&#39;)
                else:
                    warnings.warn(&#39;unknown colorspace for image &#34;%s&#34; - attempting to coerce to colorspace=float&#39; % str(self._filename))
                    self._array = np.float32(self._array)
                    self.colorspace(&#39;float&#39;)
            elif iswebp(self._filename):
                import vipy.video
                return vipy.video.Video(self._filename).load()  
            elif hasextension(self._filename):
                raise ValueError(&#39;Non-standard image extensions require a custom loader&#39;)
            else:
                # Attempting to open it anyway, may be an image file without an extension. Cross your fingers ...
                self._array = np.array(PIL.Image.open(self._filename))  # RGB order!

        except IOError:
            if self._ignoreErrors or ignoreErrors:
                if verbose is True:
                    warnings.warn(&#39;[vipy.image][WARNING]: IO error &#34;%s&#34; -&gt; &#34;%s&#34; - Ignoring. &#39; % (self.url(), self.filename()))
                self._array = None
            else:
                raise

        except KeyboardInterrupt:
            raise

        except Exception:
            if self._ignoreErrors or ignoreErrors:
                if verbose is True:
                    warnings.warn(&#39;[vipy.image][WARNING]: Load error for image &#34;%s&#34; - Ignoring&#39; % self.filename())
                self._array = None
            else:
                raise

        return self

    def download(self, ignoreErrors=False, timeout=10, verbose=False):
        &#34;&#34;&#34;Download URL to filename provided by constructor, or to temp filename.

        Args:
            ignoreErrors:  [bool] If true, do not throw an exception if the download of the URL fails for some reason.  Instead, print out a reason and return this image object.  The function `vipy.image.Image.hasfilename` will return false if the downloaded file does not exist and can be used to filter these failed downloads gracefully.
            timeout: [int]  The timeout in seconds for an http or https connection attempt.  See also [urllib.request.urlopen](https://docs.python.org/3/library/urllib.request.html).
            verbose: [bool] If true, output more helpful message.

        Returns:
            This `vipy.image.Image` object with the URL downloaded to `vipy.image.Image.filename` or to a `vipy.util.tempimage` filename which can be retrieved with `vipy.image.Image.filename`.
        &#34;&#34;&#34;
        if self._url is None and self._filename is not None:
            return self
        if self._url is None or not isurl(str(self._url)):
            raise ValueError(&#39;[vipy.image.download][ERROR]: &#39;
                             &#39;Invalid URL &#34;%s&#34; &#39; % self._url)

        if self._filename is None:
            if vipy.globals.cache() is not None:
                self._filename = os.path.join(remkdir(vipy.globals.cache()), filetail(self._url))
            elif isimageurl(self._url):
                self._filename = tempimage(fileext(self._url))
            else:
                self._filename = tempjpg()  # guess JPG for URLs with no file extension

        try:
            url_scheme = urllib.parse.urlparse(self._url)[0]
            if url_scheme in [&#39;http&#39;, &#39;https&#39;]:
                vipy.downloader.download(self._url,
                                         self._filename,
                                         verbose=verbose,
                                         timeout=timeout,
                                         sha1=self._urlsha1,
                                         username=self._urluser,
                                         password=self._urlpassword)
            elif url_scheme == &#39;file&#39;:
                shutil.copyfile(self._url, self._filename)
            elif url_scheme == &#39;s3&#39;:
                raise NotImplementedError(&#39;S3 support is in development&#39;)                
            else:
                raise NotImplementedError(
                    &#39;Invalid URL scheme &#34;%s&#34; for URL &#34;%s&#34;&#39; %
                    (url_scheme, self._url))

        except (httplib.BadStatusLine,
                urllib.error.URLError,
                urllib.error.HTTPError):
            if self._ignoreErrors or ignoreErrors:
                if verbose is True:
                    warnings.warn(&#39;[vipy.image][WARNING]: download failed - Ignoring image&#39;)
                self._array = None
            else:
                raise

        except IOError:
            if self._ignoreErrors or ignoreErrors:
                if verbose:
                    warnings.warn(&#39;[vipy.image][WARNING]: IO error downloading &#34;%s&#34; -&gt; &#34;%s&#34; - Ignoring&#39; % (self.url(), self.filename()))
                self._array = None
            else:
                raise

        except KeyboardInterrupt:
            raise

        except Exception:
            if self._ignoreErrors or ignoreErrors:
                if verbose:
                    warnings.warn(&#39;[vipy.image][WARNING]: load error for image &#34;%s&#34;&#39; % self.filename())
            else:
                raise

        return self

    def reload(self):
        &#34;&#34;&#34;Flush the image buffer to force reloading from file or URL&#34;&#34;&#34;
        return self.clone(flush=True).load()

    def isloaded(self):
        &#34;&#34;&#34;Return True if `vipy.image.Image.load` was successful in reading the image, or if the pixels are present in `vipy.image.Image.array`.&#34;&#34;&#34;
        return self._array is not None

    def channels(self):
        &#34;&#34;&#34;Return integer number of color channels&#34;&#34;&#34;
        return 1 if self.load().array().ndim == 2 else self.load().array().shape[2]

    def iscolor(self):
        &#34;&#34;&#34;Color images are three channel or four channel with transparency, float32 or uint8&#34;&#34;&#34;
        return self.channels() == 3 or self.channels() == 4

    def istransparent(self):
        &#34;&#34;&#34;Transparent images are four channel color images with transparency, float32 or uint8.  Return true if this image contains an alpha transparency channel&#34;&#34;&#34;
        return self.channels() == 4

    def isgrey(self):
        &#34;&#34;&#34;Grey images are one channel, float32&#34;&#34;&#34;
        return self.channels() == 1 and self.array().dtype == np.float32

    def isluminance(self):
        &#34;&#34;&#34;Luninance images are one channel, uint8&#34;&#34;&#34;
        return self.channels() == 1 and self.array().dtype == np.uint8

    def filesize(self):
        &#34;&#34;&#34;Return size of underlying image file, requires fetching metadata from filesystem&#34;&#34;&#34;
        assert self.hasfilename(), &#39;Invalid image filename&#39;
        return os.path.getsize(self._filename)

    def width(self):
        &#34;&#34;&#34;Return the width (columns) of the image in integer pixels.
        
        .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
        &#34;&#34;&#34;
        return self.load().array().shape[1]

    def height(self):
        &#34;&#34;&#34;Return the height (rows) of the image in integer pixels.
        
        .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
        &#34;&#34;&#34;        
        return self.load().array().shape[0]
    
    def shape(self):
        &#34;&#34;&#34;Return the (height, width) or equivalently (rows, cols) of the image.
        
        Returns:
            A tuple (height=int, width=int) of the image.

        .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
        &#34;&#34;&#34;
        return (self.load().height(), self.width())

    def aspectratio(self):
        &#34;&#34;&#34;Return the aspect ratio of the image as (width/height) ratio.

        Returns:
            A float equivalent to (`vipy.image.Image.width` / `vipy.image.Image.height`)

        .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
        &#34;&#34;&#34;
        return self.load().width() / float(self.height())

    def area(self):
        &#34;&#34;&#34;Return the area of the image as (width * height).

        Returns:
            An integer equivalent to (`vipy.image.Image.width` * `vipy.image.Image.height`)

        .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
        &#34;&#34;&#34;
        return self.width()*self.height()
    
    def centroid(self):
        &#34;&#34;&#34;Return the real valued center pixel coordinates of the image (col=x,row=y).
        
        The centroid is equivalent to half the `vipy.image.Image.shape`.

        Returns:
            A tuple (column, row) of the floating point center of the image.
        &#34;&#34;&#34;
        return (self.load().width() / 2.0, self.height() / 2.0)

    def centerpixel(self):
        &#34;&#34;&#34;Return the integer valued center pixel coordinates of the image (col=i,row=j)

        The centerpixel is equivalent to half the `vipy.image.Image.shape` floored to the nearest integer pixel coordinate.

        Returns:
            A tuple (int(column), int(row)) of the integer center of the image.
        &#34;&#34;&#34;
        c = np.round(self.centroid())
        return (int(c[0]), int(c[1]))
    
    def array(self, np_array=None, copy=False):
        &#34;&#34;&#34;Replace self._array with provided numpy array

        Args:
            np_array: [numpy array] A new array to use as the pixel buffer for this image.
            copy: [bool] If true, copy the buffer using np.copy(), else use a reference to this buffer.

        Returns:
            - If np_array is not None, return the `vipy.image.Image` object such that this object points to the provided numpy array as the pixel buffer
            - If np_array is None, then return the numpy array.

        .. notes:: 
            - If copy=False, then this `vipy.image.Image` object will share the pixel buffer with the owner of np_array.  Changes to pixels in this buffer will be shared.  
            - If copy=True, then this will significantly slow down processing for large images.  Use referneces wherevery possible.
        &#34;&#34;&#34;
        if np_array is None:
            return self._array if copy is False else np.copy(self._array)
        elif isnumpyarray(np_array):
            self._array = np.copy(np_array) if copy else np_array  # reference or copy
            assert self._array.dtype == np.float32 or self._array.dtype == np.uint8, &#34;Invalid input - array() must be type uint8 or float32 and not type=&#39;%s&#39;&#34; % (str(self._array.dtype))                        
            self.colorspace(None)  # must be set with colorspace() after array() but before _convert()
            return self
        else:
            raise ValueError(&#39;Invalid input - array() must be numpy array and not &#34;%s&#34;&#39; % (str(type(np_array))))

    def fromarray(self, data):
        &#34;&#34;&#34;Alias for `vipy.image.Image.array` with copy=True. This will set new numpy array as the pixel buffer with a numpy array copy&#34;&#34;&#34;
        return self.array(data, copy=True)
    
    def tonumpy(self):
        &#34;&#34;&#34;Alias for `vipy.image.Image.numpy&#34;&#34;&#34;
        return self.numpy()

    def numpy(self):
        &#34;&#34;&#34;Return a mutable numpy array for this `vipy.image.Image`.

        .. notes:: 
            - This will always return a writeable array with the &#39;WRITEABLE&#39; numpy flag set.  This is useful for returning a mutable numpy array as needed while keeping the original non-mutable numpy array (e.g. loaded from a video or PIL) as the underlying pixel buffer for efficiency reasons.
            - Triggers a `vipy.image.Image.load` if the pixel buffer has not been loaded
            - This will trigger a copy if the [&#39;WRITEABLE&#39; flag](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flags.html) is not set. 
        &#34;&#34;&#34;        
        self.load()
        self._array = np.copy(self._array) if not self._array.flags[&#39;WRITEABLE&#39;] else self._array  # triggers copy         
        return self._array
        
    def channel(self, k=None):
        &#34;&#34;&#34;Return a cloned Image() object for the kth channel, or return an iterator over channels if k=None.

        Iterate over channels as single channel luminance images:

        ```python
        for c in self.channel():
            print(c)
        ```

        Return the kth channel as a single channel luminance image:

        ```python
        c = self.channel(k=0)
        ```

        &#34;&#34;&#34;
        if k is None:
            return [self.channel(j) for j in range(0, self.channels())]
        elif k == 0 and self.channels() == 1:
            return self
        else:
            assert k &lt; self.channels() and k&gt;=0, &#34;Requested channel=%d must be within valid channels=%d&#34; % (k, self.channels())
            im = self.clone().load()
            im._array = im._array[:,:,k]
            im._colorspace = &#39;lum&#39;
            return im

    def red(self):
        &#34;&#34;&#34;Return red channel as a cloned single channel `vipy.image.Image` object.

        These are equivalent operations if the colorspace is &#39;rgb&#39; or &#39;rgba&#39;:
        
        ```python
        self.red() == self.channel(0) 
        ```

        These are equivalent operations if the colorspace is &#39;bgr&#39; or &#39;bgra&#39;:

        ```python
        self.red() == self.channel(3) 
        ```

        .. note:: OpenCV returns images in BGR colorspace.  Use this method to always return the desired channel by color.
        &#34;&#34;&#34;
        assert self.channels() &gt;= 3, &#34;Must be color image&#34;
        if self.colorspace() in [&#39;rgb&#39;, &#39;rgba&#39;]:
            return self.channel(0)
        elif self.colorspace() in [&#39;bgr&#39;, &#39;bgra&#39;]:
            return self.channel(3)
        else:
            raise ValueError(&#39;Invalid colorspace &#34;%s&#34; does not contain red channel&#39; % self.colorspace())

    def green(self):
        &#34;&#34;&#34;Return green channel as a cloned single channel `vipy.image.Image` object.

        These are equivalent operations if the colorspace is &#39;rgb&#39; or &#39;rgba&#39;:

        ```python
        self.green() == self.channel(1) 
        ```

        These are equivalent operations if the colorspace is &#39;bgr&#39; or &#39;bgra&#39;:

        ```python
        self.green() == self.channel(1) 
        ```

        .. note:: OpenCV returns images in BGR colorspace.  Use this method to always return the desired channel by color.
        &#34;&#34;&#34;
        assert self.channels() &gt;= 3, &#34;Must be three channel color image&#34;
        if self.colorspace() in [&#39;rgb&#39;, &#39;rgba&#39;]:
            return self.channel(1)
        elif self.colorspace() in [&#39;bgr&#39;, &#39;bgra&#39;]:
            return self.channel(1)
        else:
            raise ValueError(&#39;Invalid colorspace &#34;%s&#34; does not contain red channel&#39; % self.colorspace())

    def blue(self):
        &#34;&#34;&#34;Return blue channel as a cloned single channel `vipy.image.Image` object.

        These are equivalent operations if the colorspace is &#39;rgb&#39; or &#39;rgba&#39;:

        ```python
        self.vlue() == self.channel(2) 
        ```

        These are equivalent operations if the colorspace is &#39;bgr&#39; or &#39;bgra&#39;:

        ```python
        self.blue() == self.channel(0) 
        ```

        .. note:: OpenCV returns images in BGR colorspace.  Use this method to always return the desired channel by color.
        &#34;&#34;&#34;
        assert self.channels() &gt;= 3, &#34;Must be three channel color image&#34;
        if self.colorspace() in [&#39;rgb&#39;, &#39;rgba&#39;]:
            return self.channel(2)
        elif self.colorspace() in [&#39;bgr&#39;, &#39;bgra&#39;]:
            return self.channel(0)
        else:
            raise ValueError(&#39;Invalid colorspace &#34;%s&#34; does not contain red channel&#39; % self.colorspace())                

    def alpha(self):
        &#34;&#34;&#34;Return alpha (transparency) channel as a cloned single channel `vipy.image.Image` object&#34;&#34;&#34;
        assert self.channels() == 4 and self.colorspace() in [&#39;rgba&#39;, &#39;bgra&#39;], &#34;Must be four channnel color image&#34;
        return self.channel(3)
        
    def zeros(self):
        &#34;&#34;&#34;Set the pixel buffer to all zeros of the same shape and datatype as this `vipy.image.Image` object.
        
        These are equivalent operations for the resulting buffer shape: 
        
        ```python
        import numpy as np
        np.zeros( (self.width(), self.height(), self.channels()) ) == self.zeros().array()
        ```

        Returns:
           This `vipy.image.Image` object.

        .. note:: Triggers load() if the pixel buffer has not been loaded yet.
        &#34;&#34;&#34;
        self._array = 0*self.load()._array
        return self

    def pil(self):
        &#34;&#34;&#34;Convert vipy.image.Image to PIL Image.
        
        Returns:
            A [PIL image](https://pillow.readthedocs.io/en/stable/reference/Image.html) object, that shares the pixel buffer by reference
        &#34;&#34;&#34;
        assert self.channels() in [1,3,4] and (self.channels() == 1 or self.colorspace() != &#39;float&#39;), &#34;Incompatible with PIL&#34;
        return PIL.Image.fromarray(self.numpy(), mode=&#39;RGB&#39; if self.colorspace()==&#39;rgb&#39; else None)  # FIXME: mode=&#39;RGB&#39; triggers slow tobytes() conversion, need RGBA or RGBX

    def blur(self, sigma=3):
        &#34;&#34;&#34;Apply a Gaussian blur with Gaussian kernel radius=sigma to the pixel buffer.
        
        Args:
            sigma: [float &gt;0] The gaussian blur kernel radius.

        Returns:
            This `vipy.image.Image` object with the pixel buffer blurred in place.
        &#34;&#34;&#34;
        assert sigma &gt; 0
        return self.array(np.array(self.pil().filter(PIL.ImageFilter.GaussianBlur(radius=sigma))))
        
    def torch(self, order=&#39;CHW&#39;):
        &#34;&#34;&#34;Convert the batch of 1 HxWxC images to a CxHxW torch tensor.

        Args:
            order: [&#39;CHW&#39;, &#39;HWC&#39;, &#39;NCHW&#39;, &#39;NHWC&#39;].  The axis order of the torch tensor (channels, height, width) or (height, width, channels) or (1, channels, height, width) or (1, height, width, channels)

        Returns:
            A CxHxW or HxWxC or 1xCxHxW or 1xHxWxC [torch tensor](https://pytorch.org/docs/stable/tensors.html) that shares the pixel buffer of this image object by reference.
        &#34;&#34;&#34;
        try_import(&#39;torch&#39;); import torch
        assert order.lower() in [&#39;chw&#39;, &#39;hwc&#39;, &#39;nchw&#39;, &#39;nhwc&#39;]
        img = self.numpy() if self.iscolor() else np.expand_dims(self.numpy(), 2)  # HxW -&gt; HxWx1
        img = img.transpose(2,0,1) if order.lower() in [&#39;chw&#39;, &#39;nchw&#39;]  else img   # HxWxC or CxHxW        
        img = np.expand_dims(img,0) if order.lower() in [&#39;nhwc&#39;, &#39;nchw&#39;] else img  # HxWxC -&gt; 1xHxWxC
        return torch.from_numpy(img)  

    @staticmethod
    def fromtorch(x):
        &#34;&#34;&#34;Convert a 1xCxHxW or CxHxW torch tensor (or numpy array with torch channel order) to HxWxC numpy array, returns new `vipy.image.Image` with inferred colorspace corresponding to data type in x&#34;&#34;&#34;
        try_import(&#39;torch&#39;); import torch        
        assert isinstance(x, torch.Tensor) or isinstance(x, np.ndarray), &#34;Invalid input type &#39;%s&#39;- must be torch.Tensor&#34; % (str(type(x)))
        assert (x.ndim == 4 and x.shape[0] == 1) or x.ndim == 3, &#34;Torch tensor must be shape 1xCxHxW or CxHxW&#34;
        x = x.squeeze(0) if (x.ndim == 4 and x.shape[0] == 1) else x
        img = np.copy(np.squeeze(x.permute(1,2,0).detach().numpy() if torch.is_tensor(x) else x.transpose(1,2,0)))   # CxHxW -&gt; HxWxC, copied
        colorspace = &#39;float&#39; if img.dtype == np.float32 else None
        colorspace = &#39;rgb&#39; if img.dtype == np.uint8 and img.shape[2] == 3 else colorspace  # assumed
        colorspace = &#39;lum&#39; if img.dtype == np.uint8 and img.shape[2] == 1 else colorspace        
        return Image(array=img, colorspace=colorspace)
    
    def nofilename(self):
        self._filename = None
        return self

    def filename(self, newfile=None):
        &#34;&#34;&#34;Return or set image filename&#34;&#34;&#34;
        if newfile is None:
            return self._filename
        else:
            self._filename = newfile
            return self

    def nourl(self):
        self._url = None
        return self

    def url(self, url=None, username=None, password=None, sha1=None, ignoreUrlErrors=None):
        &#34;&#34;&#34;Image URL and URL download properties&#34;&#34;&#34;
        if url is not None:
            self._url = url  # this does not change anything else (e.g. the associated filename), better to use constructor 
        if username is not None:
            self._urluser = username  # basic authentication
        if password is not None:
            self._urlpassword = password  # basic authentication
        if sha1 is not None:
            self._urlsha1 = sha1  # file integrity
        if ignoreUrlErrors is not None:
            self._ignoreErrors = ignoreUrlErrors
        if url is None and username is None and password is None and sha1 is None and ignoreUrlErrors is None:
            return self._url
        else:
            return self
    
    def colorspace(self, colorspace=None):
        &#34;&#34;&#34;Return or set the colorspace as [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;lum&#39;]&#34;&#34;&#34;
        if colorspace is None:
            return self._colorspace
        else:
            assert str(colorspace).lower() in [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;], &#34;Invalid colorspace &#39;%s&#39;. Allowable is [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;]&#34; % colorspace 
            img = self.array()
            if self.isloaded():
                colorspace = str(colorspace).lower()
                if self.array().dtype == np.float32:
                    assert colorspace in [&#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;], &#34;Invalid colorspace &#39;%s&#39; for float32 array()&#34; % colorspace
                elif self.array().dtype == np.uint8:
                    assert colorspace in  [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;lum&#39;], &#34;Invalid colorspace &#39;%s&#39; for uint8 array(). Allowable is [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;lum&#39;]&#34; % colorspace
                else:
                    raise ValueError(&#39;unupported array() datatype &#34;%s&#34;.  Allowable is [np.float32, np.uint8]&#39; % colorspace)  # should never get here as long as array() is used to set _array
                if self.channels() == 1:
                    assert colorspace in [&#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;], &#34;Invalid colorspace &#39;%s; for single channel array.  Allowable is [&#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;]&#34; % colorspace
                elif self.channels() == 3:
                    assert colorspace in [&#39;float&#39;, &#39;rgb&#39;, &#39;bgr&#39;, &#39;hsv&#39;], &#34;Invalid colorspace &#39;%s; for three channel array. Allowable is [&#39;float&#39;, &#39;rgb&#39;, &#39;bgr&#39;, &#39;hsv&#39;]&#34; % colorspace
                elif self.channels() == 4:
                    assert colorspace in [&#39;float&#39;, &#39;rgba&#39;, &#39;bgra&#39;], &#34;Invalid colorspace &#39;%s; for four channel array. Allowable is [&#39;float&#39;, &#39;rgba&#39;, &#39;bgra&#39;]&#34; % colorspace                    
                elif colorspace != &#39;float&#39;:
                    raise ValueError(&#34;Invalid colorspace &#39;%s&#39; for image channels=%d, type=%s&#34; % (colorspace, self.channels(), str(self.array().dtype)))
                if colorspace in [&#39;grey&#39;, &#39;gray&#39;]:
                    assert self.max() &lt;= 1 and self.min() &gt;= 0, &#34;Colorspace &#39;grey&#39; image must be np.float32 in range [0,1].  Use colorspace &#39;lum&#39; for np.uint8 in range [0,255], or colorspace &#39;float&#39; for unconstrained np.float32 [-inf, +inf]&#34;
                    colorspace = &#39;grey&#39;  # standardize
            self._colorspace = str(colorspace).lower()
            return self

    def uri(self):
        &#34;&#34;&#34;Return the URI of the image object, either the URL or the filename, raise exception if neither defined&#34;&#34;&#34;
        if self.hasurl():
            return self.url()
        elif self.hasfilename():
            return self.filename()
        else:
            raise ValueError(&#39;No URI defined&#39;)

    def setattribute(self, key, value):
        &#34;&#34;&#34;Set element self.attributes[key]=value&#34;&#34;&#34;
        if self.attributes is None:
            self.attributes = {key: value}
        else:
            self.attributes[key] = value
        return self

    def setattributes(self, newattr):
        &#34;&#34;&#34;Set many attributes at once by providing a dictionary to be merged with current attributes&#34;&#34;&#34;
        assert isinstance(newattr, dict), &#34;New attributes must be dictionary&#34;
        self.attributes.update(newattr)
        return self
    
    def getattribute(self, k):
        &#34;&#34;&#34;Return the key k in the attributes dictionary (self.attributes) if present, else None&#34;&#34;&#34;        
        return self.attributes[k] if k in self.attributes else None        

    def hasattribute(self, key):
        return self.attributes is not None and key in self.attributes

    def delattribute(self, k):
        if k in self.attributes:
            self.attributes.pop(k)
        return self

    def hasurl(self):
        return self._url is not None and isurl(self._url)

    def hasfilename(self):
        return self._filename is not None and os.path.exists(self._filename)

    def clone(self, flushforward=False, flushbackward=False, flush=False, shallow=False, attributes=False):
        &#34;&#34;&#34;Create deep copy of object, flushing the original buffer if requested and returning the cloned object.
        Flushing is useful for distributed memory management to free the buffer from this object, and pass along a cloned 
        object which can be used for encoding and will be garbage collected.
        
            * flushforward: copy the object, and set the cloned object array() to None.  This flushes the video buffer for the clone, not the object
            * flushbackward:  copy the object, and set the object array() to None.  This flushes the video buffer for the object, not the clone.
            * flush:  set the object array() to None and clone the object.  This flushes the video buffer for both the clone and the object.

        &#34;&#34;&#34;
        if flush or (flushforward and flushbackward):
            self._array = None  # flushes buffer on object and clone
            im = copy.deepcopy(self)  # object and clone are flushed
        elif flushbackward:
            im = copy.deepcopy(self)  # propagates _array to clone
            self._array = None   # object flushed, clone not flushed
        elif flushforward:
            array = self._array;
            self._array = None
            im = copy.deepcopy(self)   # does not propagate _array to clone
            self._array = array    # object not flushed
            im._array = None   # clone flushed
        elif shallow:
            im = copy.copy(self)  # shallow copy
            im._array = np.asarray(self._array) if self._array is not None else None  # shared pixels            
        else:
            im = copy.deepcopy(self)
        if attributes:
            im.attributes = copy.deepcopy(self.attributes)
        return im

    def flush(self):
        &#34;&#34;&#34;Alias for clone(flush=True), returns self not clone&#34;&#34;&#34;
        self._array = None  # flushes buffer on object and clone
        return self

        
    # Spatial transformations
    def resize(self, cols=None, rows=None, width=None, height=None, interp=&#39;bilinear&#39;, fast=False):
        &#34;&#34;&#34;Resize the image buffer to (rows x cols) with bilinear interpolation.  If rows or cols is provided, rescale image maintaining aspect ratio&#34;&#34;&#34;
        assert not (cols is not None and width is not None), &#34;Define either width or cols&#34;
        assert not (rows is not None and height is not None), &#34;Define either height or rows&#34;
        rows = rows if height is None else height
        cols = cols if width is None else width
        if cols is None or rows is None:
            if cols is None:
                scale = float(rows) / float(self.height())
            else:
                scale = float(cols) / float(self.width())
            self.rescale(scale)
        elif rows == self.height() and cols == self.width():
            return self  
        elif self.colorspace() == &#39;float&#39;:
            self._array = np.dstack([np.array(im.pil().resize((cols, rows), string_to_pil_interpolation(interp))) for im in self.channel()])
        else:
            self._array = np.asarray(self.load().pil().resize((cols, rows), string_to_pil_interpolation(interp), reducing_gap=2 if fast else None))  
        return self

    def resize_like(self, im, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize image buffer to be the same size as the provided vipy.image.Image()&#34;&#34;&#34;
        assert isinstance(im, Image), &#34;Invalid input - Must be vipy.image.Image()&#34;
        return self.resize(im.width(), im.height(), interp=interp)
    
    def rescale(self, scale=1, interp=&#39;bilinear&#39;, fast=False):
        &#34;&#34;&#34;Scale the image buffer by the given factor - NOT idempotent&#34;&#34;&#34;
        (height, width) = self.load().shape()
        if scale == 1:
            return self
        elif self.colorspace() == &#39;float&#39;:
            self._array = np.dstack([np.asarray(im.pil().resize((int(np.round(scale * width)), int(np.round(scale * height))), string_to_pil_interpolation(interp))) for im in self.channel()])
        else: 
            self._array = np.asarray(self.pil().resize((int(np.round(scale * width)), int(np.round(scale * height))), string_to_pil_interpolation(interp), reducing_gap=2 if fast else None))
        return self

    def maxdim(self, dim=None, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize image preserving aspect ratio so that maximum dimension of image = dim, or return maxdim()&#34;&#34;&#34;
        return self.rescale(float(dim) / float(np.maximum(self.height(), self.width())), interp=interp) if dim is not None else max(self.shape())

    def mindim(self, dim=None, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize image preserving aspect ratio so that minimum dimension of image = dim, or return mindim()&#34;&#34;&#34;
        if dim is None:
            return np.minimum(self.height(), self.width())
        else:
            s = float(dim) / float(np.minimum(self.height(), self.width()))
            return self.rescale(s, interp=interp) if dim is not None else min(self.shape())

    def _pad(self, dx, dy, mode=&#39;edge&#39;):
        &#34;&#34;&#34;Pad image using np.pad mode, dx=padwidth, dy=padheight, thin wrapper for numpy.pad&#34;&#34;&#34;
        self._array = np.pad(self.load().array(),
                             ((dy, dy), (dx, dx), (0, 0)) if
                             self.load().array().ndim == 3 else ((dy, dy), (dx, dx)),
                             mode=mode)
        return self

    def zeropad(self, padwidth, padheight):
        &#34;&#34;&#34;Pad image using np.pad constant by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding&#34;&#34;&#34;
        if not isinstance(padwidth, tuple):
            padwidth = (padwidth, padwidth)
        if not isinstance(padheight, tuple):
            padheight = (padheight, padheight)
        if self.iscolor():
            pad_shape = (padheight, padwidth, (0, 0))
        else:
            pad_shape = (padheight, padwidth)

        assert all([x&gt;=0 for x in padheight]) and all([x&gt;=0 for x in padwidth]), &#34;padding must be positive&#34;
        if padwidth[0]&gt;0 or padwidth[1]&gt;0 or padheight[0]&gt;0 or padheight[1]&gt;0:
            self._array = np.pad(self.load().array(), pad_width=pad_shape, mode=&#39;constant&#39;, constant_values=0)  # this is still slow due to the required copy, but fast-ish in np &gt;= 1.17
            
        return self

    def zeropadlike(self, width, height):
        &#34;&#34;&#34;Zero pad the image balancing the border so that the resulting image size is (width, height)&#34;&#34;&#34;
        assert width &gt;= self.width() and height &gt;= self.height(), &#34;Invalid input - final (width=%d, height=%d) must be greater than current image size (width=%d, height=%d)&#34; % (width, height, self.width(), self.height())
        return self.zeropad( (int(np.floor((width - self.width())/2)), int(np.ceil((width - self.width())/2))),
                             (int(np.floor((height - self.height())/2)), int(np.ceil((height - self.height())/2))))
                            
    def meanpad(self, padwidth, padheight, mu=None):
        &#34;&#34;&#34;Pad image using np.pad constant=image mean by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding&#34;&#34;&#34;        
        if not isinstance(padwidth, tuple):
            padwidth = (padwidth, padwidth)
        if not isinstance(padheight, tuple):
            padheight = (padheight, padheight)
        assert all([x&gt;=0 for x in padheight]) and all([x&gt;=0 for x in padwidth]), &#34;padding must be positive&#34;
        mu = self.meanchannel() if mu is None else mu
        self._array = np.squeeze(np.dstack([np.pad(img,
                                                   pad_width=(padheight,padwidth),
                                                   mode=&#39;constant&#39;,
                                                   constant_values=c) for (img,c) in zip(self.channel(), mu)]))
        return self

    def alphapad(self, padwidth, padheight):
        &#34;&#34;&#34;Pad image using alpha transparency by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding&#34;&#34;&#34;
        assert self.colorspace() == &#39;rgba&#39;, &#34;Colorspace must be RGBA for padding with transparency&#34;
        return self.meanpad(padwidth, padheight, mu=np.array([0,0,0,0]))
    
    def minsquare(self):
        &#34;&#34;&#34;Crop image of size (HxW) to (min(H,W), min(H,W)), keeping upper left corner constant&#34;&#34;&#34;
        S = np.min(self.load().shape())
        return self._crop(BoundingBox(xmin=0, ymin=0, width=int(S), height=int(S)))

    def maxsquare(self, S=None):
        &#34;&#34;&#34;Crop image of size (HxW) to (max(H,W), max(H,W)) with zeropadding or (S,S) if provided, keeping upper left corner constant&#34;&#34;&#34;
        S = np.max(self.load().shape()) if S is None else int(S)
        (H, W) = self.shape()
        (dW, dH) = (max(0, S - W), max(0, S - H))
        if S != W or S != H:
            self._crop(BoundingBox(0, 0, width=min(W, S), height=min(H, S)))
            if (dW &gt; 0 or dH &gt; 0):
                self.zeropad((0,dW), (0,dH))  # crop then zeropad
        return self

    def maxmatte(self):
        &#34;&#34;&#34;Crop image of size (HxW) to (max(H,W), max(H,W)) with balanced zeropadding forming a letterbox with top/bottom matte or pillarbox with left/right matte&#34;&#34;&#34;
        S = np.max(self.load().shape())
        dW = S - self.width()
        dH = S - self.height()
        return self.zeropad((int(np.floor(dW//2)), int(np.ceil(dW//2))), (int(np.floor(dH//2)), int(np.ceil(dH//2))))._crop(BoundingBox(0, 0, width=int(S), height=int(S)))
    
    def centersquare(self):
        &#34;&#34;&#34;Crop image of size (NxN) in the center, such that N=min(width,height), keeping the image centroid constant&#34;&#34;&#34;
        N = int(np.min(self.shape()))
        return self._crop(BoundingBox(xcentroid=float(self.width() / 2.0), ycentroid=float(self.height() / 2.0), width=N, height=N))

    def centercrop(self, height, width):
        &#34;&#34;&#34;Crop image of size (height x width) in the center, keeping the image centroid constant&#34;&#34;&#34;
        return self._crop(BoundingBox(xcentroid=float(self.width() / 2.0), ycentroid=float(self.height() / 2.0), width=int(width), height=int(height)))

    def cornercrop(self, height, width):
        &#34;&#34;&#34;Crop image of size (height x width) from the upper left corner&#34;&#34;&#34;
        return self._crop(BoundingBox(xmin=0, ymin=0, width=int(width), height=int(height)))
    
    def _crop(self, bbox):
        &#34;&#34;&#34;Crop the image buffer using the supplied bounding box object, clipping the box to the image rectangle&#34;&#34;&#34;
        assert isinstance(bbox, BoundingBox) and bbox.valid(), &#34;Invalid input - Must be vipy.geometry.BoundingBox() not &#39;%s&#39;&#34; % (str(type(bbox)))
        if not bbox.isdegenerate() and bbox.hasoverlap(self.load().array()):
            bbox = bbox.imclip(self.load().array()).int()
            self._array = self.array()[bbox.ymin():bbox.ymax(),
                                       bbox.xmin():bbox.xmax()]
        else:
            warnings.warn(&#39;BoundingBox for crop() does not intersect image rectangle - Ignoring&#39;)
        return self

    def crop(self, bbox):
        return self._crop(bbox)
    
    def fliplr(self):
        &#34;&#34;&#34;Mirror the image buffer about the vertical axis - Not idempotent&#34;&#34;&#34;
        self._array = np.fliplr(self.load().array())
        return self

    def flipud(self):
        &#34;&#34;&#34;Mirror the image buffer about the horizontal axis - Not idempotent&#34;&#34;&#34;
        self._array = np.flipud(self.load().array())
        return self
    
    def imagebox(self):
        &#34;&#34;&#34;Return the bounding box for the image rectangle&#34;&#34;&#34;
        return BoundingBox(xmin=0, ymin=0, width=int(self.width()), height=int(self.height()))

    def border_mask(self, pad):
        &#34;&#34;&#34;Return a binary uint8 image the same size as self, with a border of pad pixels in width or height around the edge&#34;&#34;&#34;
        img = np.zeros( (self.height(), self.width()), dtype=np.uint8)
        img[0:pad,:] = 1
        img[-pad:,:] = 1
        img[:,0:pad] = 1
        img[:,-pad:] = 1
        return img
    
    # Color conversion
    def _convert(self, to):
        &#34;&#34;&#34;Supported colorspaces are rgb, rgbab, bgr, bgra, hsv, grey, lum, float&#34;&#34;&#34;
        to = to if to != &#39;gray&#39; else &#39;grey&#39;  # standardize &#39;gray&#39; -&gt; &#39;grey&#39; internally
        self.load()
        if self.colorspace() == to:
            return self
        elif to == &#39;float&#39;:
            img = self.load().array()  # any type
            self._array = np.array(img).astype(np.float32)  # typecast to float32
        elif self.colorspace() == &#39;lum&#39;:
            img = self.load().array()  # single channel, uint8 [0,255]
            assert img.dtype == np.uint8
            img = np.squeeze(img, axis=2) if img.ndim == 3 and img.shape[2] == 1 else img  # remove singleton channel            
            self._array = np.array(PIL.Image.fromarray(img, mode=&#39;L&#39;).convert(&#39;RGB&#39;))  # uint8 luminance [0,255] -&gt; uint8 RGB
            self.colorspace(&#39;rgb&#39;)
            self._convert(to)
        elif self.colorspace() in [&#39;gray&#39;, &#39;grey&#39;]:
            img = self.load().array()  # single channel float32 [0,1]
            img = np.squeeze(img, axis=2) if img.ndim == 3 and img.shape[2] == 1 else img  # remove singleton channel                        
            self._array = np.array(PIL.Image.fromarray(255.0 * img, mode=&#39;F&#39;).convert(&#39;RGB&#39;))  # float32 gray [0,1] -&gt; float32 gray [0,255] -&gt; uint8 RGB
            self.colorspace(&#39;rgb&#39;)
            self._convert(to)
        elif self.colorspace() == &#39;rgba&#39;:
            img = self.load().array()  # uint8 RGBA
            if to == &#39;bgra&#39;:
                self._array = np.array(img)[:,:,::-1]  # uint8 RGBA -&gt; uint8 ABGR
                self._array = self._array[:,:,[1,2,3,0]]  # uint8 ABGR -&gt; uint8 BGRA
            elif to == &#39;rgb&#39;:
                self._array = self._array[:,:,0:-1]  # uint8 RGBA -&gt; uint8 RGB
            else:
                self._array = self._array[:,:,0:-1]  # uint8 RGBA -&gt; uint8 RGB
                self.colorspace(&#39;rgb&#39;)
                self._convert(to)
        elif self.colorspace() == &#39;rgb&#39;:
            img = self.load().array()  # uint8 RGB
            if to in [&#39;grey&#39;, &#39;gray&#39;]:
                self._array = (1.0 / 255.0) * np.array(PIL.Image.fromarray(img).convert(&#39;L&#39;)).astype(np.float32)  # uint8 RGB -&gt; float32 Grey [0,255] -&gt; float32 Grey [0,1]
            elif to == &#39;bgr&#39;:
                self._array = np.array(img)[:,:,::-1]  # uint8 RGB -&gt; uint8 BGR
            elif to == &#39;hsv&#39;:
                self._array = np.array(PIL.Image.fromarray(img).convert(&#39;HSV&#39;))  # uint8 RGB -&gt; uint8 HSV
            elif to == &#39;lum&#39;:
                self._array = np.array(PIL.Image.fromarray(img).convert(&#39;L&#39;))  # uint8 RGB -&gt; uint8 Luminance (integer grey)
            elif to == &#39;rgba&#39;:
                self._array = np.dstack((img, 255*np.ones((img.shape[0], img.shape[1]), dtype=np.uint8)))
            elif to == &#39;bgra&#39;:
                self._array = np.array(img)[:,:,::-1]  # uint8 RGB -&gt; uint8 BGR
                self._array = np.dstack((self._array, np.zeros((img.shape[0], img.shape[1]), dtype=np.uint8)))  # uint8 BGR -&gt; uint8 BGRA
        elif self.colorspace() == &#39;bgr&#39;:
            img = self.load().array()  # uint8 BGR
            self._array = np.array(img)[:,:,::-1]  # uint8 BGR -&gt; uint8 RGB
            self.colorspace(&#39;rgb&#39;)
            self._convert(to)
        elif self.colorspace() == &#39;bgra&#39;:
            img = self.load().array()  # uint8 BGRA
            self._array = np.array(img)[:,:,::-1]  # uint8 BGRA -&gt; uint8 ARGB
            self._array = self._array[:,:,[1,2,3,0]]  # uint8 ARGB -&gt; uint8 RGBA
            self.colorspace(&#39;rgba&#39;)
            self._convert(to)
        elif self.colorspace() == &#39;hsv&#39;:
            img = self.load().array()  # uint8 HSV
            self._array = np.array(PIL.Image.fromarray(img, mode=&#39;HSV&#39;).convert(&#39;RGB&#39;))  # uint8 HSV -&gt; uint8 RGB
            self.colorspace(&#39;rgb&#39;)
            self._convert(to)
        elif self.colorspace() == &#39;float&#39;:
            img = self.load().array()  # float32
            if np.max(img) &gt; 1 or np.min(img) &lt; 0:
                warnings.warn(&#39;Converting float image to &#34;%s&#34; will be rescaled with self.mat2gray() into the range float32 [0,1]&#39; % to)
                img = self.mat2gray().array()
            if not self.channels() in [1,2,3]:
                raise ValueError(&#39;Float image must be single channel or three channel RGB in the range float32 [0,1] prior to conversion&#39;)
            if self.channels() == 3:  # assumed RGB
                self._array = np.uint8(255 * self.array())   # float32 RGB [0,1] -&gt; uint8 RGB [0,255]
                self.colorspace(&#39;rgb&#39;)
            else:
                self._array = (1.0 / 255.0) * np.array(PIL.Image.fromarray(np.uint8(255 * np.squeeze(self.array()))).convert(&#39;L&#39;)).astype(np.float32)  # float32 RGB [0,1] -&gt; float32 gray [0,1]                
                self.colorspace(&#39;grey&#39;)
            self._convert(to)
        elif self.colorspace() is None:
            raise ValueError(&#39;Colorspace must be initialized by constructor or colorspace() to allow for colorspace conversion&#39;)
        else:
            raise ValueError(&#39;unsupported colorspace &#34;%s&#34;&#39; % self.colorspace())

        self.colorspace(to)
        return self

    def affine_transform(self, A):
        &#34;&#34;&#34;Apply a 3x3 affine geometric transformation to the image. 

        See also `vipy.geometry.affine_transform`

        .. note:: The image will be loaded and converted to float() prior to applying the affine transformation.  
        .. note:: This will transform only the pixels
        &#34;&#34;&#34;
        assert isnumpy(A) or isinstance(img, vipy.image.Image), &#34;invalid input&#34;
        assert A.shape == (3,3), &#34;The affine transformation matrix should be the output of vipy.geometry.affine_transformation&#34;
        self._array = vipy.geometry.imtransform(self.load().float().array(), A.astype(np.float32))
        return self

    def rotate(self, r):
        &#34;&#34;&#34;Apply a rotation in radians to the pixels, with origin in upper left &#34;&#34;&#34;
        return self.affine_transform(vipy.geometry.affine_transform(r=r))
    
    def rgb(self):
        &#34;&#34;&#34;Convert the image buffer to three channel RGB uint8 colorspace&#34;&#34;&#34;
        return self._convert(&#39;rgb&#39;)

    def rgba(self):
        &#34;&#34;&#34;Convert the image buffer to four channel RGBA uint8 colorspace&#34;&#34;&#34;
        return self._convert(&#39;rgba&#39;)

    def hsv(self):
        &#34;&#34;&#34;Convert the image buffer to three channel HSV uint8 colorspace&#34;&#34;&#34;
        return self._convert(&#39;hsv&#39;)

    def bgr(self):
        &#34;&#34;&#34;Convert the image buffer to three channel BGR uint8 colorspace&#34;&#34;&#34;
        return self._convert(&#39;bgr&#39;)

    def bgra(self):
        &#34;&#34;&#34;Convert the image buffer to four channel BGR uint8 colorspace&#34;&#34;&#34;
        return self._convert(&#39;bgra&#39;)

    def float(self):
        &#34;&#34;&#34;Convert the image buffer to float32&#34;&#34;&#34;
        return self._convert(&#39;float&#39;)

    def greyscale(self):
        &#34;&#34;&#34;Convert the image buffer to single channel grayscale float32 in range [0,1]&#34;&#34;&#34;
        return self._convert(&#39;gray&#39;)

    def grayscale(self):
        &#34;&#34;&#34;Alias for greyscale()&#34;&#34;&#34;
        return self.greyscale()

    def grey(self):
        &#34;&#34;&#34;Alias for greyscale()&#34;&#34;&#34;
        return self.greyscale()

    def gray(self):
        &#34;&#34;&#34;Alias for greyscale()&#34;&#34;&#34;
        return self.greyscale()

    def luminance(self):
        &#34;&#34;&#34;Convert the image buffer to single channel uint8 in range [0,255] corresponding to the luminance component&#34;&#34;&#34;
        return self._convert(&#39;lum&#39;)

    def lum(self):
        &#34;&#34;&#34;Alias for luminance()&#34;&#34;&#34;
        return self._convert(&#39;lum&#39;)

    def _apply_colormap(self, cm):
        &#34;&#34;&#34;Convert an image to greyscale, then convert to RGB image with matplotlib colormap&#34;&#34;&#34;
        &#34;&#34;&#34;https://matplotlib.org/tutorials/colors/colormaps.html&#34;&#34;&#34;
        cm = plt.get_cmap(cm)
        img = self.grey().numpy()
        self._array = np.uint8(255 * cm(img)[:,:,:3])
        self.colorspace(&#39;rgb&#39;)
        return self

    def jet(self):
        &#34;&#34;&#34;Apply jet colormap to greyscale image and save as RGB&#34;&#34;&#34;
        return self._apply_colormap(&#39;jet&#39;)

    def rainbow(self):
        &#34;&#34;&#34;Apply rainbow colormap to greyscale image and convert to RGB&#34;&#34;&#34;
        return self._apply_colormap(&#39;gist_rainbow&#39;)

    def hot(self):
        &#34;&#34;&#34;Apply hot colormap to greyscale image and convert to RGB&#34;&#34;&#34;
        return self._apply_colormap(&#39;hot&#39;)

    def bone(self):
        &#34;&#34;&#34;Apply bone colormap to greyscale image and convert to RGB&#34;&#34;&#34;
        return self._apply_colormap(&#39;bone&#39;)

    def saturate(self, min, max):
        &#34;&#34;&#34;Saturate the image buffer to be clipped between [min,max], types of min/max are specified by _array type&#34;&#34;&#34;
        return self.array(np.minimum(np.maximum(self.load().array(), min), max))

    def intensity(self):
        &#34;&#34;&#34;Convert image to float32 with [min,max] to range [0,1], force colormap to be &#39;float&#39;.  Equivalent to self.mat2gray()&#34;&#34;&#34;
        self.array((self.load().float().array()) - float(self.min()) / float(self.max() - self.min()))
        return self.colorspace(&#39;float&#39;)

    def mat2gray(self, min=None, max=None):
        &#34;&#34;&#34;Convert the image buffer so that [min,max] -&gt; [0,1], forces conversion to &#39;float&#39; colorspace.  This does not change the number of color channels&#34;&#34;&#34;
        self.array(mat2gray(np.float32(self.load().float().array()), min, max))
        return self.colorspace(&#39;float&#39;)
        return self

    def gain(self, g):
        &#34;&#34;&#34;Elementwise multiply gain to image array, Gain should be broadcastable to array().  This forces the colospace to &#39;float&#39;&#34;&#34;&#34;
        return self.array(np.multiply(self.load().float().array(), g)).colorspace(&#39;float&#39;) if g != 1 else self

    def bias(self, b):
        &#34;&#34;&#34;Add a bias to the image array.  Bias should be broadcastable to array().  This forces the colorspace to &#39;float&#39;&#34;&#34;&#34;
        self.array(self.load().float().array() + b)
        return self.colorspace(&#39;float&#39;)

    def normalize(self, gain, bias):
        &#34;&#34;&#34;Apply a multiplicative gain g and additive bias b, such that self.array() == gain*self.array() + bias.

        This is useful for applying a normalization of an image prior to calling `vipy.image.Image.torch`.

        The following operations are equivalent.

        ```python
        im = vipy.image.RandomImage()
        im.normalize(1/255.0, 0.5) == im.gain(1/255.0).bias(-0.5)
        ```
        
        .. note:: This will force the colorspace to &#39;float&#39;
        &#34;&#34;&#34;
        self.array(gain*self.load().float().array() + bias)
        return self.colorspace(&#39;float&#39;)
    
    # Image statistics
    def stats(self):
        print(self)
        print(&#39;  Channels: %d&#39; % self.channels())
        print(&#39;  Shape: %s&#39; % str(self.shape()))
        print(&#39;  min: %s&#39; % str(self.min()))
        print(&#39;  max: %s&#39; % str(self.max()))
        print(&#39;  mean: %s&#39; % str(self.mean()))
        print(&#39;  channel mean: %s&#39; % str(self.meanchannel()))        
    
    def min(self):
        return np.min(self.load().array().flatten())

    def max(self):
        return np.max(self.load().array().flatten())

    def mean(self):
        &#34;&#34;&#34;Mean over all pixels&#34;&#34;&#34;
        return np.mean(self.load().array().flatten())

    def meanchannel(self, k=None):
        &#34;&#34;&#34;Mean per channel over all pixels.  If channel k is provided, return just the mean for that channel&#34;&#34;&#34;
        C = np.mean(self.load().array(), axis=(0, 1)).flatten()
        return C[k] if k is not None else C
    
    def sum(self):
        return np.sum(self.load().array().flatten())

    # Image visualization
    def closeall(self):
        &#34;&#34;&#34;Close all open figure windows&#34;&#34;&#34;
        vipy.show.closeall()
        return self
    
    def close(self, fignum=None):
        &#34;&#34;&#34;Close the requested figure number, or close all of fignum=None&#34;&#34;&#34;
        if fignum is None:
            return self.closeall()
        else:
            vipy.show.close(fignum)
            return self
    
    def show(self, figure=1, nowindow=False, timestamp=None, timestampfacecolor=&#39;white&#39;, timestampcolor=&#39;black&#39;, mutator=None):
        &#34;&#34;&#34;Display image on screen in provided figure number (clone and convert to RGB colorspace to show), return object&#34;&#34;&#34;
        assert self.load().isloaded(), &#39;Image not loaded&#39;
        im = self.clone() if not mutator else mutator(self.clone())        
        vipy.show.imshow(im.rgb().numpy(), fignum=figure, nowindow=nowindow, timestamp=timestamp, timestampfacecolor=timestampfacecolor, flush=True, timestampcolor=timestampcolor)
        return self

    def save(self, filename):
        &#34;&#34;&#34;Save the current image to a new filename and return the image object&#34;&#34;&#34;
        assert filename is not None, &#34;Invalid filename - must be path to new image filename&#34;
        return self.filename(self.saveas(filename))
        
        
    # Image export
    def pkl(self, pklfile=None):
        &#34;&#34;&#34;save the object to a pickle file and return the object, useful for intermediate saving in long fluent chains&#34;&#34;&#34;
        pklfile = pklfile if pklfile is not None else toextension(self.filename(), &#39;.pkl&#39;)
        remkdir(filepath(pklfile))
        vipy.util.save(self, pklfile)
        return self

    def pklif(self, b, pklfile=None):
        &#34;&#34;&#34;Save the object to the provided pickle file only if b=True. Uuseful for conditional intermediate saving in long fluent chains&#34;&#34;&#34;
        assert isinstance(b, bool)
        return self.pkl(pklfile) if b else self

    def saveas(self, filename=None, writeas=None):
        &#34;&#34;&#34;Save current buffer (not including drawing overlays) to new filename and return filename.  If filename is not provided, use a temporary JPEG filename.&#34;&#34;&#34;
        filename = tempjpg() if filename is None else filename
        if self.colorspace() in [&#39;gray&#39;]:
            imwritegray(self.grayscale()._array, filename)
        elif self.colorspace() != &#39;float&#39;:
            imwrite(self.load().array(), filename, writeas=writeas)
        else:
            raise ValueError(&#39;Convert float image to RGB or gray first. Try self.mat2gray()&#39;)
        return filename

    def saveastmp(self):
        &#34;&#34;&#34;Save current buffer to temp JPEG filename and return filename.  Alias for savetmp()&#34;&#34;&#34;
        return self.saveas(tempjpg())

    def savetmp(self):
        &#34;&#34;&#34;Save current buffer to temp JPEG filename and return filename.   Alias for saveastmp()&#34;&#34;&#34;
        return self.saveastmp()

    def base64(self):
        &#34;&#34;&#34;Export a base64 encoding of the image suitable for embedding in an html page&#34;&#34;&#34;
        buf = io.BytesIO()
        self.clone().rgb().pil().save(buf, format=&#39;JPEG&#39;)
        return base64.b64encode(buf.getvalue())
        
    def ascii(self):
        &#34;&#34;&#34;Export a base64 ascii encoding of the image suitable for embedding in an &lt;img&gt; tag&#34;&#34;&#34;
        return self.base64().decode(&#39;ascii&#39;)

    def html(self, alt=None, id=None, attributes={&#39;loading&#39;:&#39;lazy&#39;}):
        &#34;&#34;&#34;Export a base64 encoding of the image suitable for embedding in an html page, enclosed in &lt;img&gt; tag
           
           Returns:
              -string:  &lt;img src=&#34;data:image/jpeg;charset=utf-8;base64,%s&#34; alt=&#34;%s&#34; loading=&#34;lazy&#34;&gt; containing base64 encoded JPEG and alt text with lazy loading
        &#34;&#34;&#34;
        assert isinstance(attributes, dict)
        b = self.base64().decode(&#39;ascii&#39;)
        alt_text = alt if alt is not None else self.filename()
        id = id if id is not None else self.filename()
        attr = &#39; &#39;.join([&#39;%s=&#34;%s&#34;&#39; % (str(k),str(v)) for (k,v) in attributes.items()])
        return &#39;&lt;img %ssrc=&#34;data:image/jpeg;charset=utf-8;base64,%s&#34; alt=&#34;%s&#34; %s&gt;&#39; % ((&#39;id=&#34;%s&#34; &#39; % id) if id is not None else &#39;&#39;, b, str(alt_text), attr)

    def annotate(self, timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None):
        &#34;&#34;&#34;Change pixels of this image to include rendered annotation and return an image object&#34;&#34;&#34;
        # FIXME: for k in range(0,10): self.annotate().show(figure=k), this will result in cumulative figures
        return self.array(self.savefig(timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, mutator=mutator, fontsize=fontsize).rgb().array()).downcast()

    def savefig(self, filename=None, figure=1, timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None):
        &#34;&#34;&#34;Save last figure output from self.show() with drawing overlays to provided filename and return filename&#34;&#34;&#34;
        self.show(figure=figure, nowindow=True, timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, mutator=mutator)  # sets figure dimensions, does not display window
        (W,H) = plt.figure(figure).canvas.get_width_height()  # fast
        buf = io.BytesIO()
        plt.figure(1).canvas.print_raw(buf)  # fast
        img = np.frombuffer(buf.getbuffer(), dtype=np.uint8).reshape((H, W, 4))  # RGBA
        vipy.show.close(figure)
        t = vipy.image.Image(array=img, colorspace=&#39;rgba&#39;)
        if filename is not None:
            t.rgb().saveas(os.path.abspath(os.path.expanduser(filename)))
        return t

    def map(self, func):
        &#34;&#34;&#34;Apply lambda function to our numpy array img, such that newimg=f(img), then replace newimg -&gt; self.array().  The output of this lambda function must be a numpy array and if the channels or dtype changes, the colorspace is set to &#39;float&#39;&#34;&#34;&#34;
        assert isinstance(func, types.LambdaType), &#34;Input must be lambda function (e.g. f = lambda img: 255.0-img)&#34;
        oldimg = self.array()  # reference
        newimg = func(self.array())  # in-place
        assert isnumpy(newimg), &#34;Lambda function output must be numpy array&#34;
        self.array(newimg)  # reference
        if newimg.dtype != oldimg.dtype or newimg.shape != oldimg.shape:
            self.colorspace(&#39;float&#39;)  # unknown colorspace after transformation, set generic
        return self

    def downcast(self):
        &#34;&#34;&#34;Cast the class to the base class (vipy.image.Image)&#34;&#34;&#34;
        self.__class__ = vipy.image.Image
        return self

    def perceptualhash(self, bits=128, asbinary=False, asbytes=False):
        &#34;&#34;&#34;Perceptual differential hash function

        This function converts to greyscale, resizes with linear interpolation to small image based on desired bit encoding, compute vertical and horizontal gradient signs.
        
        Args:
            bits: [int]  longer hashes have lower TAR (true accept rate, some near dupes are missed), but lower FAR (false accept rate), shorter hashes have higher TAR (fewer near-dupes are missed) but higher FAR (more non-dupes are declared as dupes).
            asbinary: [bool] If true, return a binary array
            asbytes: [bool] if true return a byte array

        Returns:
            A hash string encoding the perceptual hash such that `vipy.image.Image.perceptualhash_distance` can be used to compute a hash distance
            asbytes: a bytes array
            asbinary: a numpy binary array            

        .. notes::
            - Can be used for near duplicate detection by unpacking the returned hex string to binary and computing hamming distance, or performing hamming based nearest neighbor indexing.  Equivalently, `vipy.image.Image.perceptualhash_distance`.
            - The default packed hex output can be converted to binary as: np.unpackbits(bytearray().fromhex(h)
        &#34;&#34;&#34;        
        allowablebits = [2*k*k for k in range(2, 17)]
        assert bits in allowablebits, &#34;Bits must be in %s&#34; % str(allowablebits)
        sq = int(np.ceil(np.sqrt(bits/2.0)))
        im = self.clone()
        b = (np.dstack(np.gradient(im.resize(cols=sq+1, rows=sq+1).greyscale().numpy()))[0:-1, 0:-1] &gt; 0).flatten()
        return bytes(np.packbits(b)).hex() if not (asbytes or asbinary) else bytes(np.packbits(b)) if asbytes else b

    @staticmethod
    def perceptualhash_distance(h1, h2):
        &#34;&#34;&#34;Hamming distance between two perceptual hashes&#34;&#34;&#34;
        assert len(h1) == len(h2)
        return np.sum(np.unpackbits(bytearray().fromhex(h1)) != np.unpackbits(bytearray().fromhex(h2)))
    

    def rot90cw(self):
        &#34;&#34;&#34;Rotate the scene 90 degrees clockwise&#34;&#34;&#34;
        self.array(np.rot90(self.numpy(), 3))
        return self

    def rot90ccw(self):
        &#34;&#34;&#34;Rotate the scene 90 degrees counterclockwise&#34;&#34;&#34;
        self.array(np.rot90(self.numpy(), 1))
        return self</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vipy.image.ImageCategory" href="#vipy.image.ImageCategory">ImageCategory</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vipy.image.Image.cast"><code class="name flex">
<span>def <span class="ident">cast</span></span>(<span>im)</span>
</code></dt>
<dd>
<div class="desc"><p>Typecast the conformal vipy.image object im as <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code>.</p>
<p>This is useful for downcasting <code><a title="vipy.image.Scene" href="#vipy.image.Scene">Scene</a></code> or <code><a title="vipy.image.ImageDetection" href="#vipy.image.ImageDetection">ImageDetection</a></code> down to an image.</p>
<pre><code class="language-python">ims = vipy.image.RandomScene()
im = vipy.image.Image.cast(im)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L136-L150" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def cast(cls, im):
    &#34;&#34;&#34;Typecast the conformal vipy.image object im as `vipy.image.Image`.
    
    This is useful for downcasting `vipy.image.Scene` or `vipy.image.ImageDetection` down to an image.

    ```python
    ims = vipy.image.RandomScene()
    im = vipy.image.Image.cast(im)
    ```

    &#34;&#34;&#34;
    assert isinstance(im, vipy.image.Image), &#34;Invalid input - must derive from vipy.image.Image&#34;
    im.__class__ = vipy.image.Image
    return im</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Import the JSON string s as an <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object.</p>
<p>This will perform a round trip such that im1 == im2</p>
<pre><code class="language-python">im1 = vupy.image.RandomImage()
im2 = vipy.image.Image.from_json(im1.json())
assert im1 == im2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L152-L170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def from_json(cls, s):
    &#34;&#34;&#34;Import the JSON string s as an `vipy.image.Image` object.
    
    This will perform a round trip such that im1 == im2

    ```python
    im1 = vupy.image.RandomImage()
    im2 = vipy.image.Image.from_json(im1.json())
    assert im1 == im2
    ```
    
    &#34;&#34;&#34;
    d = json.loads(s)        
    return cls(filename=d[&#39;_filename&#39;],
               url=d[&#39;_url&#39;],
               array=np.array(d[&#39;_array&#39;], dtype=np.uint8) if d[&#39;_array&#39;] is not None else None,
               colorspace=d[&#39;_colorspace&#39;],
               attributes=d[&#39;attributes&#39;])</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.fromtorch"><code class="name flex">
<span>def <span class="ident">fromtorch</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a 1xCxHxW or CxHxW torch tensor (or numpy array with torch channel order) to HxWxC numpy array, returns new <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> with inferred colorspace corresponding to data type in x</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L855-L866" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def fromtorch(x):
    &#34;&#34;&#34;Convert a 1xCxHxW or CxHxW torch tensor (or numpy array with torch channel order) to HxWxC numpy array, returns new `vipy.image.Image` with inferred colorspace corresponding to data type in x&#34;&#34;&#34;
    try_import(&#39;torch&#39;); import torch        
    assert isinstance(x, torch.Tensor) or isinstance(x, np.ndarray), &#34;Invalid input type &#39;%s&#39;- must be torch.Tensor&#34; % (str(type(x)))
    assert (x.ndim == 4 and x.shape[0] == 1) or x.ndim == 3, &#34;Torch tensor must be shape 1xCxHxW or CxHxW&#34;
    x = x.squeeze(0) if (x.ndim == 4 and x.shape[0] == 1) else x
    img = np.copy(np.squeeze(x.permute(1,2,0).detach().numpy() if torch.is_tensor(x) else x.transpose(1,2,0)))   # CxHxW -&gt; HxWxC, copied
    colorspace = &#39;float&#39; if img.dtype == np.float32 else None
    colorspace = &#39;rgb&#39; if img.dtype == np.uint8 and img.shape[2] == 3 else colorspace  # assumed
    colorspace = &#39;lum&#39; if img.dtype == np.uint8 and img.shape[2] == 1 else colorspace        
    return Image(array=img, colorspace=colorspace)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.perceptualhash_distance"><code class="name flex">
<span>def <span class="ident">perceptualhash_distance</span></span>(<span>h1, h2)</span>
</code></dt>
<dd>
<div class="desc"><p>Hamming distance between two perceptual hashes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1568-L1572" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def perceptualhash_distance(h1, h2):
    &#34;&#34;&#34;Hamming distance between two perceptual hashes&#34;&#34;&#34;
    assert len(h1) == len(h2)
    return np.sum(np.unpackbits(bytearray().fromhex(h1)) != np.unpackbits(bytearray().fromhex(h2)))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.untile"><code class="name flex">
<span>def <span class="ident">untile</span></span>(<span>imlist)</span>
</code></dt>
<dd>
<div class="desc"><p>Undo an image tiling and recreate the original image.</p>
<pre><code class="language-python">tiles = im.tile(im.width()/2, im.height()/2, 0, 0)
imdst = vipy.image.Image.untile(tiles)
assert imdst == im
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imlist</code></strong></dt>
<dd>this must be the output of <code><a title="vipy.image.Image.tile" href="#vipy.image.Image.tile">Image.tile()</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A
new <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object reconstructed from the tiling, such that this is equivalent to the input to vipy.image.Image.tile` </p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;All annotations are updated properly for each tile, when the source image is <code><a title="vipy.image.Scene" href="#vipy.image.Scene">Scene</a></code></p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L260-L287" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def untile(cls, imlist):
    &#34;&#34;&#34;Undo an image tiling and recreate the original image.

    ```python
    tiles = im.tile(im.width()/2, im.height()/2, 0, 0)
    imdst = vipy.image.Image.untile(tiles)
    assert imdst == im
    ```

    Args:
        imlist: this must be the output of `vipy.image.Image.tile`
    
    Returns:
        A  new `vipy.image.Image` object reconstructed from the tiling, such that this is equivalent to the input to vipy.image.Image.tile` 
    
    .. note:: All annotations are updated properly for each tile, when the source image is `vipy.image.Scene`
    &#34;&#34;&#34;
    assert all([isinstance(im, vipy.image.Image) and im.hasattribute(&#39;tile&#39;) for im in imlist]), &#34;invalid image tile list&#34;        
    imc = None
    for im in imlist:
        if imc is None:
            imc = im.clone(shallow=True).array(np.zeros( (im.attributes[&#39;tile&#39;][&#39;shape&#39;][0], im.attributes[&#39;tile&#39;][&#39;shape&#39;][1], im.channels()), dtype=np.uint8))                
        imc = imc.splat(im.array(im.attributes[&#39;tile&#39;][&#39;crop&#39;].clone().to_origin().int().crop(im.array())), im.attributes[&#39;tile&#39;][&#39;crop&#39;])
        if hasattr(im, &#39;objectmap&#39;):
            im.objectmap(lambda o: o.set_origin(im.attributes[&#39;tile&#39;][&#39;crop&#39;]))  # FIXME: only for Scene()
        imc = imc.union(im)
    return imc</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.image.Image.abspath"><code class="name flex">
<span>def <span class="ident">abspath</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the path of the filename from a relative path to an absolute path (not relocatable)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L354-L356" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def abspath(self):
    &#34;&#34;&#34;Change the path of the filename from a relative path to an absolute path (not relocatable)&#34;&#34;&#34;
    return self.filename(os.path.normpath(os.path.abspath(os.path.expanduser(self.filename()))))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.affine_transform"><code class="name flex">
<span>def <span class="ident">affine_transform</span></span>(<span>self, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a 3x3 affine geometric transformation to the image. </p>
<p>See also <code><a title="vipy.geometry.affine_transform" href="geometry.html#vipy.geometry.affine_transform">affine_transform()</a></code></p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;The image will be loaded and converted to float() prior to applying the affine transformation.
</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This will transform only the pixels</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1267-L1278" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def affine_transform(self, A):
    &#34;&#34;&#34;Apply a 3x3 affine geometric transformation to the image. 

    See also `vipy.geometry.affine_transform`

    .. note:: The image will be loaded and converted to float() prior to applying the affine transformation.  
    .. note:: This will transform only the pixels
    &#34;&#34;&#34;
    assert isnumpy(A) or isinstance(img, vipy.image.Image), &#34;invalid input&#34;
    assert A.shape == (3,3), &#34;The affine transformation matrix should be the output of vipy.geometry.affine_transformation&#34;
    self._array = vipy.geometry.imtransform(self.load().float().array(), A.astype(np.float32))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.alpha"><code class="name flex">
<span>def <span class="ident">alpha</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return alpha (transparency) channel as a cloned single channel <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L795-L798" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def alpha(self):
    &#34;&#34;&#34;Return alpha (transparency) channel as a cloned single channel `vipy.image.Image` object&#34;&#34;&#34;
    assert self.channels() == 4 and self.colorspace() in [&#39;rgba&#39;, &#39;bgra&#39;], &#34;Must be four channnel color image&#34;
    return self.channel(3)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.alphapad"><code class="name flex">
<span>def <span class="ident">alphapad</span></span>(<span>self, padwidth, padheight)</span>
</code></dt>
<dd>
<div class="desc"><p>Pad image using alpha transparency by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1102-L1105" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def alphapad(self, padwidth, padheight):
    &#34;&#34;&#34;Pad image using alpha transparency by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding&#34;&#34;&#34;
    assert self.colorspace() == &#39;rgba&#39;, &#34;Colorspace must be RGBA for padding with transparency&#34;
    return self.meanpad(padwidth, padheight, mu=np.array([0,0,0,0]))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.annotate"><code class="name flex">
<span>def <span class="ident">annotate</span></span>(<span>self, timestamp=None, timestampcolor='black', timestampfacecolor='white', mutator=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Change pixels of this image to include rendered annotation and return an image object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1508-L1511" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def annotate(self, timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None):
    &#34;&#34;&#34;Change pixels of this image to include rendered annotation and return an image object&#34;&#34;&#34;
    # FIXME: for k in range(0,10): self.annotate().show(figure=k), this will result in cumulative figures
    return self.array(self.savefig(timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, mutator=mutator, fontsize=fontsize).rgb().array()).downcast()</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the area of the image as (width * height).</p>
<h2 id="returns">Returns</h2>
<p>An integer equivalent to (<code><a title="vipy.image.Image.width" href="#vipy.image.Image.width">Image.width()</a></code> * <code><a title="vipy.image.Image.height" href="#vipy.image.Image.height">Image.height()</a></code>)</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This triggers a <code><a title="vipy.image.Image.load" href="#vipy.image.Image.load">Image.load()</a></code> if the image is not already loaded.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L616-L624" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area(self):
    &#34;&#34;&#34;Return the area of the image as (width * height).

    Returns:
        An integer equivalent to (`vipy.image.Image.width` * `vipy.image.Image.height`)

    .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
    &#34;&#34;&#34;
    return self.width()*self.height()</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.array"><code class="name flex">
<span>def <span class="ident">array</span></span>(<span>self, np_array=None, copy=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace self._array with provided numpy array</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>np_array</code></strong></dt>
<dd>[numpy array] A new array to use as the pixel buffer for this image.</dd>
<dt><strong><code>copy</code></strong></dt>
<dd>[bool] If true, copy the buffer using np.copy(), else use a reference to this buffer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<ul>
<li>If np_array is not None, return the <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object such that this object points to the provided numpy array as the pixel buffer</li>
<li>If np_array is None, then return the numpy array.</li>
</ul>
<div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>If copy=False, then this <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object will share the pixel buffer with the owner of np_array.
Changes to pixels in this buffer will be shared.
</li>
<li>If copy=True, then this will significantly slow down processing for large images.
Use referneces wherevery possible.</li>
</ul>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L647-L670" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def array(self, np_array=None, copy=False):
    &#34;&#34;&#34;Replace self._array with provided numpy array

    Args:
        np_array: [numpy array] A new array to use as the pixel buffer for this image.
        copy: [bool] If true, copy the buffer using np.copy(), else use a reference to this buffer.

    Returns:
        - If np_array is not None, return the `vipy.image.Image` object such that this object points to the provided numpy array as the pixel buffer
        - If np_array is None, then return the numpy array.

    .. notes:: 
        - If copy=False, then this `vipy.image.Image` object will share the pixel buffer with the owner of np_array.  Changes to pixels in this buffer will be shared.  
        - If copy=True, then this will significantly slow down processing for large images.  Use referneces wherevery possible.
    &#34;&#34;&#34;
    if np_array is None:
        return self._array if copy is False else np.copy(self._array)
    elif isnumpyarray(np_array):
        self._array = np.copy(np_array) if copy else np_array  # reference or copy
        assert self._array.dtype == np.float32 or self._array.dtype == np.uint8, &#34;Invalid input - array() must be type uint8 or float32 and not type=&#39;%s&#39;&#34; % (str(self._array.dtype))                        
        self.colorspace(None)  # must be set with colorspace() after array() but before _convert()
        return self
    else:
        raise ValueError(&#39;Invalid input - array() must be numpy array and not &#34;%s&#34;&#39; % (str(type(np_array))))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.ascii"><code class="name flex">
<span>def <span class="ident">ascii</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Export a base64 ascii encoding of the image suitable for embedding in an <img> tag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1491-L1493" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ascii(self):
    &#34;&#34;&#34;Export a base64 ascii encoding of the image suitable for embedding in an &lt;img&gt; tag&#34;&#34;&#34;
    return self.base64().decode(&#39;ascii&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.aspectratio"><code class="name flex">
<span>def <span class="ident">aspectratio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the aspect ratio of the image as (width/height) ratio.</p>
<h2 id="returns">Returns</h2>
<p>A float equivalent to (<code><a title="vipy.image.Image.width" href="#vipy.image.Image.width">Image.width()</a></code> / <code><a title="vipy.image.Image.height" href="#vipy.image.Image.height">Image.height()</a></code>)</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This triggers a <code><a title="vipy.image.Image.load" href="#vipy.image.Image.load">Image.load()</a></code> if the image is not already loaded.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L606-L614" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def aspectratio(self):
    &#34;&#34;&#34;Return the aspect ratio of the image as (width/height) ratio.

    Returns:
        A float equivalent to (`vipy.image.Image.width` / `vipy.image.Image.height`)

    .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
    &#34;&#34;&#34;
    return self.load().width() / float(self.height())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.base64"><code class="name flex">
<span>def <span class="ident">base64</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Export a base64 encoding of the image suitable for embedding in an html page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1485-L1489" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def base64(self):
    &#34;&#34;&#34;Export a base64 encoding of the image suitable for embedding in an html page&#34;&#34;&#34;
    buf = io.BytesIO()
    self.clone().rgb().pil().save(buf, format=&#39;JPEG&#39;)
    return base64.b64encode(buf.getvalue())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.bgr"><code class="name flex">
<span>def <span class="ident">bgr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the image buffer to three channel BGR uint8 colorspace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1296-L1298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bgr(self):
    &#34;&#34;&#34;Convert the image buffer to three channel BGR uint8 colorspace&#34;&#34;&#34;
    return self._convert(&#39;bgr&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.bgra"><code class="name flex">
<span>def <span class="ident">bgra</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the image buffer to four channel BGR uint8 colorspace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1300-L1302" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bgra(self):
    &#34;&#34;&#34;Convert the image buffer to four channel BGR uint8 colorspace&#34;&#34;&#34;
    return self._convert(&#39;bgra&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.bias"><code class="name flex">
<span>def <span class="ident">bias</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a bias to the image array.
Bias should be broadcastable to array().
This forces the colorspace to 'float'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1376-L1379" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bias(self, b):
    &#34;&#34;&#34;Add a bias to the image array.  Bias should be broadcastable to array().  This forces the colorspace to &#39;float&#39;&#34;&#34;&#34;
    self.array(self.load().float().array() + b)
    return self.colorspace(&#39;float&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.blue"><code class="name flex">
<span>def <span class="ident">blue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return blue channel as a cloned single channel <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object.</p>
<p>These are equivalent operations if the colorspace is 'rgb' or 'rgba':</p>
<pre><code class="language-python">self.vlue() == self.channel(2) 
</code></pre>
<p>These are equivalent operations if the colorspace is 'bgr' or 'bgra':</p>
<pre><code class="language-python">self.blue() == self.channel(0) 
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;OpenCV returns images in BGR colorspace.
Use this method to always return the desired channel by color.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L770-L793" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def blue(self):
    &#34;&#34;&#34;Return blue channel as a cloned single channel `vipy.image.Image` object.

    These are equivalent operations if the colorspace is &#39;rgb&#39; or &#39;rgba&#39;:

    ```python
    self.vlue() == self.channel(2) 
    ```

    These are equivalent operations if the colorspace is &#39;bgr&#39; or &#39;bgra&#39;:

    ```python
    self.blue() == self.channel(0) 
    ```

    .. note:: OpenCV returns images in BGR colorspace.  Use this method to always return the desired channel by color.
    &#34;&#34;&#34;
    assert self.channels() &gt;= 3, &#34;Must be three channel color image&#34;
    if self.colorspace() in [&#39;rgb&#39;, &#39;rgba&#39;]:
        return self.channel(2)
    elif self.colorspace() in [&#39;bgr&#39;, &#39;bgra&#39;]:
        return self.channel(0)
    else:
        raise ValueError(&#39;Invalid colorspace &#34;%s&#34; does not contain red channel&#39; % self.colorspace())                </code></pre>
</details>
</dd>
<dt id="vipy.image.Image.blur"><code class="name flex">
<span>def <span class="ident">blur</span></span>(<span>self, sigma=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a Gaussian blur with Gaussian kernel radius=sigma to the pixel buffer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sigma</code></strong></dt>
<dd>[float &gt;0] The gaussian blur kernel radius.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object with the pixel buffer blurred in place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L827-L837" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def blur(self, sigma=3):
    &#34;&#34;&#34;Apply a Gaussian blur with Gaussian kernel radius=sigma to the pixel buffer.
    
    Args:
        sigma: [float &gt;0] The gaussian blur kernel radius.

    Returns:
        This `vipy.image.Image` object with the pixel buffer blurred in place.
    &#34;&#34;&#34;
    assert sigma &gt; 0
    return self.array(np.array(self.pil().filter(PIL.ImageFilter.GaussianBlur(radius=sigma))))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.bone"><code class="name flex">
<span>def <span class="ident">bone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply bone colormap to greyscale image and convert to RGB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1353-L1355" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bone(self):
    &#34;&#34;&#34;Apply bone colormap to greyscale image and convert to RGB&#34;&#34;&#34;
    return self._apply_colormap(&#39;bone&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.border_mask"><code class="name flex">
<span>def <span class="ident">border_mask</span></span>(<span>self, pad)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a binary uint8 image the same size as self, with a border of pad pixels in width or height around the edge</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1171-L1178" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def border_mask(self, pad):
    &#34;&#34;&#34;Return a binary uint8 image the same size as self, with a border of pad pixels in width or height around the edge&#34;&#34;&#34;
    img = np.zeros( (self.height(), self.width()), dtype=np.uint8)
    img[0:pad,:] = 1
    img[-pad:,:] = 1
    img[:,0:pad] = 1
    img[:,-pad:] = 1
    return img</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.canload"><code class="name flex">
<span>def <span class="ident">canload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if the image can be loaded successfully, useful for filtering bad links or corrupt images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L364-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def canload(self):
    &#34;&#34;&#34;Return True if the image can be loaded successfully, useful for filtering bad links or corrupt images&#34;&#34;&#34;
    if not self.isloaded():
        try:
            self.load()  # try to load
            return True
        except:
            return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.centercrop"><code class="name flex">
<span>def <span class="ident">centercrop</span></span>(<span>self, height, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop image of size (height x width) in the center, keeping the image centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1135-L1137" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centercrop(self, height, width):
    &#34;&#34;&#34;Crop image of size (height x width) in the center, keeping the image centroid constant&#34;&#34;&#34;
    return self._crop(BoundingBox(xcentroid=float(self.width() / 2.0), ycentroid=float(self.height() / 2.0), width=int(width), height=int(height)))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.centerpixel"><code class="name flex">
<span>def <span class="ident">centerpixel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the integer valued center pixel coordinates of the image (col=i,row=j)</p>
<p>The centerpixel is equivalent to half the <code><a title="vipy.image.Image.shape" href="#vipy.image.Image.shape">Image.shape()</a></code> floored to the nearest integer pixel coordinate.</p>
<h2 id="returns">Returns</h2>
<p>A tuple (int(column), int(row)) of the integer center of the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L636-L645" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centerpixel(self):
    &#34;&#34;&#34;Return the integer valued center pixel coordinates of the image (col=i,row=j)

    The centerpixel is equivalent to half the `vipy.image.Image.shape` floored to the nearest integer pixel coordinate.

    Returns:
        A tuple (int(column), int(row)) of the integer center of the image.
    &#34;&#34;&#34;
    c = np.round(self.centroid())
    return (int(c[0]), int(c[1]))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.centersquare"><code class="name flex">
<span>def <span class="ident">centersquare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop image of size (NxN) in the center, such that N=min(width,height), keeping the image centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1130-L1133" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centersquare(self):
    &#34;&#34;&#34;Crop image of size (NxN) in the center, such that N=min(width,height), keeping the image centroid constant&#34;&#34;&#34;
    N = int(np.min(self.shape()))
    return self._crop(BoundingBox(xcentroid=float(self.width() / 2.0), ycentroid=float(self.height() / 2.0), width=N, height=N))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.centroid"><code class="name flex">
<span>def <span class="ident">centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the real valued center pixel coordinates of the image (col=x,row=y).</p>
<p>The centroid is equivalent to half the <code><a title="vipy.image.Image.shape" href="#vipy.image.Image.shape">Image.shape()</a></code>.</p>
<h2 id="returns">Returns</h2>
<p>A tuple (column, row) of the floating point center of the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L626-L634" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centroid(self):
    &#34;&#34;&#34;Return the real valued center pixel coordinates of the image (col=x,row=y).
    
    The centroid is equivalent to half the `vipy.image.Image.shape`.

    Returns:
        A tuple (column, row) of the floating point center of the image.
    &#34;&#34;&#34;
    return (self.load().width() / 2.0, self.height() / 2.0)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.channel"><code class="name flex">
<span>def <span class="ident">channel</span></span>(<span>self, k=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a cloned Image() object for the kth channel, or return an iterator over channels if k=None.</p>
<p>Iterate over channels as single channel luminance images:</p>
<pre><code class="language-python">for c in self.channel():
    print(c)
</code></pre>
<p>Return the kth channel as a single channel luminance image:</p>
<pre><code class="language-python">c = self.channel(k=0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L692-L718" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def channel(self, k=None):
    &#34;&#34;&#34;Return a cloned Image() object for the kth channel, or return an iterator over channels if k=None.

    Iterate over channels as single channel luminance images:

    ```python
    for c in self.channel():
        print(c)
    ```

    Return the kth channel as a single channel luminance image:

    ```python
    c = self.channel(k=0)
    ```

    &#34;&#34;&#34;
    if k is None:
        return [self.channel(j) for j in range(0, self.channels())]
    elif k == 0 and self.channels() == 1:
        return self
    else:
        assert k &lt; self.channels() and k&gt;=0, &#34;Requested channel=%d must be within valid channels=%d&#34; % (k, self.channels())
        im = self.clone().load()
        im._array = im._array[:,:,k]
        im._colorspace = &#39;lum&#39;
        return im</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.channels"><code class="name flex">
<span>def <span class="ident">channels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return integer number of color channels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L557-L559" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def channels(self):
    &#34;&#34;&#34;Return integer number of color channels&#34;&#34;&#34;
    return 1 if self.load().array().ndim == 2 else self.load().array().shape[2]</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, flushforward=False, flushbackward=False, flush=False, shallow=False, attributes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create deep copy of object, flushing the original buffer if requested and returning the cloned object.
Flushing is useful for distributed memory management to free the buffer from this object, and pass along a cloned
object which can be used for encoding and will be garbage collected.</p>
<pre><code>* flushforward: copy the object, and set the cloned object array() to None.  This flushes the video buffer for the clone, not the object
* flushbackward:  copy the object, and set the object array() to None.  This flushes the video buffer for the object, not the clone.
* flush:  set the object array() to None and clone the object.  This flushes the video buffer for both the clone and the object.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L971-L1000" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clone(self, flushforward=False, flushbackward=False, flush=False, shallow=False, attributes=False):
    &#34;&#34;&#34;Create deep copy of object, flushing the original buffer if requested and returning the cloned object.
    Flushing is useful for distributed memory management to free the buffer from this object, and pass along a cloned 
    object which can be used for encoding and will be garbage collected.
    
        * flushforward: copy the object, and set the cloned object array() to None.  This flushes the video buffer for the clone, not the object
        * flushbackward:  copy the object, and set the object array() to None.  This flushes the video buffer for the object, not the clone.
        * flush:  set the object array() to None and clone the object.  This flushes the video buffer for both the clone and the object.

    &#34;&#34;&#34;
    if flush or (flushforward and flushbackward):
        self._array = None  # flushes buffer on object and clone
        im = copy.deepcopy(self)  # object and clone are flushed
    elif flushbackward:
        im = copy.deepcopy(self)  # propagates _array to clone
        self._array = None   # object flushed, clone not flushed
    elif flushforward:
        array = self._array;
        self._array = None
        im = copy.deepcopy(self)   # does not propagate _array to clone
        self._array = array    # object not flushed
        im._array = None   # clone flushed
    elif shallow:
        im = copy.copy(self)  # shallow copy
        im._array = np.asarray(self._array) if self._array is not None else None  # shared pixels            
    else:
        im = copy.deepcopy(self)
    if attributes:
        im.attributes = copy.deepcopy(self.attributes)
    return im</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, fignum=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the requested figure number, or close all of fignum=None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1432-L1438" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def close(self, fignum=None):
    &#34;&#34;&#34;Close the requested figure number, or close all of fignum=None&#34;&#34;&#34;
    if fignum is None:
        return self.closeall()
    else:
        vipy.show.close(fignum)
        return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.closeall"><code class="name flex">
<span>def <span class="ident">closeall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close all open figure windows</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1427-L1430" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def closeall(self):
    &#34;&#34;&#34;Close all open figure windows&#34;&#34;&#34;
    vipy.show.closeall()
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.colorspace"><code class="name flex">
<span>def <span class="ident">colorspace</span></span>(<span>self, colorspace=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return or set the colorspace as ['rgb', 'rgba', 'bgr', 'bgra', 'hsv', 'float', 'grey', 'lum']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L901-L928" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def colorspace(self, colorspace=None):
    &#34;&#34;&#34;Return or set the colorspace as [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;lum&#39;]&#34;&#34;&#34;
    if colorspace is None:
        return self._colorspace
    else:
        assert str(colorspace).lower() in [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;], &#34;Invalid colorspace &#39;%s&#39;. Allowable is [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;]&#34; % colorspace 
        img = self.array()
        if self.isloaded():
            colorspace = str(colorspace).lower()
            if self.array().dtype == np.float32:
                assert colorspace in [&#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;], &#34;Invalid colorspace &#39;%s&#39; for float32 array()&#34; % colorspace
            elif self.array().dtype == np.uint8:
                assert colorspace in  [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;lum&#39;], &#34;Invalid colorspace &#39;%s&#39; for uint8 array(). Allowable is [&#39;rgb&#39;, &#39;rgba&#39;, &#39;bgr&#39;, &#39;bgra&#39;, &#39;hsv&#39;, &#39;lum&#39;]&#34; % colorspace
            else:
                raise ValueError(&#39;unupported array() datatype &#34;%s&#34;.  Allowable is [np.float32, np.uint8]&#39; % colorspace)  # should never get here as long as array() is used to set _array
            if self.channels() == 1:
                assert colorspace in [&#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;], &#34;Invalid colorspace &#39;%s; for single channel array.  Allowable is [&#39;float&#39;, &#39;grey&#39;, &#39;gray&#39;, &#39;lum&#39;]&#34; % colorspace
            elif self.channels() == 3:
                assert colorspace in [&#39;float&#39;, &#39;rgb&#39;, &#39;bgr&#39;, &#39;hsv&#39;], &#34;Invalid colorspace &#39;%s; for three channel array. Allowable is [&#39;float&#39;, &#39;rgb&#39;, &#39;bgr&#39;, &#39;hsv&#39;]&#34; % colorspace
            elif self.channels() == 4:
                assert colorspace in [&#39;float&#39;, &#39;rgba&#39;, &#39;bgra&#39;], &#34;Invalid colorspace &#39;%s; for four channel array. Allowable is [&#39;float&#39;, &#39;rgba&#39;, &#39;bgra&#39;]&#34; % colorspace                    
            elif colorspace != &#39;float&#39;:
                raise ValueError(&#34;Invalid colorspace &#39;%s&#39; for image channels=%d, type=%s&#34; % (colorspace, self.channels(), str(self.array().dtype)))
            if colorspace in [&#39;grey&#39;, &#39;gray&#39;]:
                assert self.max() &lt;= 1 and self.min() &gt;= 0, &#34;Colorspace &#39;grey&#39; image must be np.float32 in range [0,1].  Use colorspace &#39;lum&#39; for np.uint8 in range [0,255], or colorspace &#39;float&#39; for unconstrained np.float32 [-inf, +inf]&#34;
                colorspace = &#39;grey&#39;  # standardize
        self._colorspace = str(colorspace).lower()
        return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.cornercrop"><code class="name flex">
<span>def <span class="ident">cornercrop</span></span>(<span>self, height, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop image of size (height x width) from the upper left corner</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1139-L1141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cornercrop(self, height, width):
    &#34;&#34;&#34;Crop image of size (height x width) from the upper left corner&#34;&#34;&#34;
    return self._crop(BoundingBox(xmin=0, ymin=0, width=int(width), height=int(height)))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>self, bbox)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1154-L1155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def crop(self, bbox):
    return self._crop(bbox)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.delattribute"><code class="name flex">
<span>def <span class="ident">delattribute</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L960-L963" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delattribute(self, k):
    if k in self.attributes:
        self.attributes.pop(k)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L375-L377" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dict(self):
    &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
    return self.json(s=None, encode=False)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.downcast"><code class="name flex">
<span>def <span class="ident">downcast</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cast the class to the base class (vipy.image.Image)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1537-L1540" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downcast(self):
    &#34;&#34;&#34;Cast the class to the base class (vipy.image.Image)&#34;&#34;&#34;
    self.__class__ = vipy.image.Image
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, ignoreErrors=False, timeout=10, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Download URL to filename provided by constructor, or to temp filename.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ignoreErrors</code></strong></dt>
<dd>[bool] If true, do not throw an exception if the download of the URL fails for some reason.
Instead, print out a reason and return this image object.
The function <code><a title="vipy.image.Image.hasfilename" href="#vipy.image.Image.hasfilename">Image.hasfilename()</a></code> will return false if the downloaded file does not exist and can be used to filter these failed downloads gracefully.</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>[int]
The timeout in seconds for an http or https connection attempt.
See also <a href="https://docs.python.org/3/library/urllib.request.html">urllib.request.urlopen</a>.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>[bool] If true, output more helpful message.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object with the URL downloaded to <code><a title="vipy.image.Image.filename" href="#vipy.image.Image.filename">Image.filename()</a></code> or to a <code><a title="vipy.util.tempimage" href="util.html#vipy.util.tempimage">tempimage()</a></code> filename which can be retrieved with <code><a title="vipy.image.Image.filename" href="#vipy.image.Image.filename">Image.filename()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L475-L547" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def download(self, ignoreErrors=False, timeout=10, verbose=False):
    &#34;&#34;&#34;Download URL to filename provided by constructor, or to temp filename.

    Args:
        ignoreErrors:  [bool] If true, do not throw an exception if the download of the URL fails for some reason.  Instead, print out a reason and return this image object.  The function `vipy.image.Image.hasfilename` will return false if the downloaded file does not exist and can be used to filter these failed downloads gracefully.
        timeout: [int]  The timeout in seconds for an http or https connection attempt.  See also [urllib.request.urlopen](https://docs.python.org/3/library/urllib.request.html).
        verbose: [bool] If true, output more helpful message.

    Returns:
        This `vipy.image.Image` object with the URL downloaded to `vipy.image.Image.filename` or to a `vipy.util.tempimage` filename which can be retrieved with `vipy.image.Image.filename`.
    &#34;&#34;&#34;
    if self._url is None and self._filename is not None:
        return self
    if self._url is None or not isurl(str(self._url)):
        raise ValueError(&#39;[vipy.image.download][ERROR]: &#39;
                         &#39;Invalid URL &#34;%s&#34; &#39; % self._url)

    if self._filename is None:
        if vipy.globals.cache() is not None:
            self._filename = os.path.join(remkdir(vipy.globals.cache()), filetail(self._url))
        elif isimageurl(self._url):
            self._filename = tempimage(fileext(self._url))
        else:
            self._filename = tempjpg()  # guess JPG for URLs with no file extension

    try:
        url_scheme = urllib.parse.urlparse(self._url)[0]
        if url_scheme in [&#39;http&#39;, &#39;https&#39;]:
            vipy.downloader.download(self._url,
                                     self._filename,
                                     verbose=verbose,
                                     timeout=timeout,
                                     sha1=self._urlsha1,
                                     username=self._urluser,
                                     password=self._urlpassword)
        elif url_scheme == &#39;file&#39;:
            shutil.copyfile(self._url, self._filename)
        elif url_scheme == &#39;s3&#39;:
            raise NotImplementedError(&#39;S3 support is in development&#39;)                
        else:
            raise NotImplementedError(
                &#39;Invalid URL scheme &#34;%s&#34; for URL &#34;%s&#34;&#39; %
                (url_scheme, self._url))

    except (httplib.BadStatusLine,
            urllib.error.URLError,
            urllib.error.HTTPError):
        if self._ignoreErrors or ignoreErrors:
            if verbose is True:
                warnings.warn(&#39;[vipy.image][WARNING]: download failed - Ignoring image&#39;)
            self._array = None
        else:
            raise

    except IOError:
        if self._ignoreErrors or ignoreErrors:
            if verbose:
                warnings.warn(&#39;[vipy.image][WARNING]: IO error downloading &#34;%s&#34; -&gt; &#34;%s&#34; - Ignoring&#39; % (self.url(), self.filename()))
            self._array = None
        else:
            raise

    except KeyboardInterrupt:
        raise

    except Exception:
        if self._ignoreErrors or ignoreErrors:
            if verbose:
                warnings.warn(&#39;[vipy.image][WARNING]: load error for image &#34;%s&#34;&#39; % self.filename())
        else:
            raise

    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.filename"><code class="name flex">
<span>def <span class="ident">filename</span></span>(<span>self, newfile=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return or set image filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L872-L878" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filename(self, newfile=None):
    &#34;&#34;&#34;Return or set image filename&#34;&#34;&#34;
    if newfile is None:
        return self._filename
    else:
        self._filename = newfile
        return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.filesize"><code class="name flex">
<span>def <span class="ident">filesize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return size of underlying image file, requires fetching metadata from filesystem</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L577-L580" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filesize(self):
    &#34;&#34;&#34;Return size of underlying image file, requires fetching metadata from filesystem&#34;&#34;&#34;
    assert self.hasfilename(), &#39;Invalid image filename&#39;
    return os.path.getsize(self._filename)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.fliplr"><code class="name flex">
<span>def <span class="ident">fliplr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mirror the image buffer about the vertical axis - Not idempotent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1157-L1160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fliplr(self):
    &#34;&#34;&#34;Mirror the image buffer about the vertical axis - Not idempotent&#34;&#34;&#34;
    self._array = np.fliplr(self.load().array())
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.flipud"><code class="name flex">
<span>def <span class="ident">flipud</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mirror the image buffer about the horizontal axis - Not idempotent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1162-L1165" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flipud(self):
    &#34;&#34;&#34;Mirror the image buffer about the horizontal axis - Not idempotent&#34;&#34;&#34;
    self._array = np.flipud(self.load().array())
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.float"><code class="name flex">
<span>def <span class="ident">float</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the image buffer to float32</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1304-L1306" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def float(self):
    &#34;&#34;&#34;Convert the image buffer to float32&#34;&#34;&#34;
    return self._convert(&#39;float&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for clone(flush=True), returns self not clone</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1002-L1005" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flush(self):
    &#34;&#34;&#34;Alias for clone(flush=True), returns self not clone&#34;&#34;&#34;
    self._array = None  # flushes buffer on object and clone
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.fromarray"><code class="name flex">
<span>def <span class="ident">fromarray</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.image.Image.array" href="#vipy.image.Image.array">Image.array()</a></code> with copy=True. This will set new numpy array as the pixel buffer with a numpy array copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L672-L674" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fromarray(self, data):
    &#34;&#34;&#34;Alias for `vipy.image.Image.array` with copy=True. This will set new numpy array as the pixel buffer with a numpy array copy&#34;&#34;&#34;
    return self.array(data, copy=True)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.gain"><code class="name flex">
<span>def <span class="ident">gain</span></span>(<span>self, g)</span>
</code></dt>
<dd>
<div class="desc"><p>Elementwise multiply gain to image array, Gain should be broadcastable to array().
This forces the colospace to 'float'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1372-L1374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def gain(self, g):
    &#34;&#34;&#34;Elementwise multiply gain to image array, Gain should be broadcastable to array().  This forces the colospace to &#39;float&#39;&#34;&#34;&#34;
    return self.array(np.multiply(self.load().float().array(), g)).colorspace(&#39;float&#39;) if g != 1 else self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.getattribute"><code class="name flex">
<span>def <span class="ident">getattribute</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the key k in the attributes dictionary (self.attributes) if present, else None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L953-L955" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getattribute(self, k):
    &#34;&#34;&#34;Return the key k in the attributes dictionary (self.attributes) if present, else None&#34;&#34;&#34;        
    return self.attributes[k] if k in self.attributes else None        </code></pre>
</details>
</dd>
<dt id="vipy.image.Image.gray"><code class="name flex">
<span>def <span class="ident">gray</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for greyscale()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1320-L1322" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def gray(self):
    &#34;&#34;&#34;Alias for greyscale()&#34;&#34;&#34;
    return self.greyscale()</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.grayscale"><code class="name flex">
<span>def <span class="ident">grayscale</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for greyscale()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1312-L1314" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grayscale(self):
    &#34;&#34;&#34;Alias for greyscale()&#34;&#34;&#34;
    return self.greyscale()</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.green"><code class="name flex">
<span>def <span class="ident">green</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return green channel as a cloned single channel <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object.</p>
<p>These are equivalent operations if the colorspace is 'rgb' or 'rgba':</p>
<pre><code class="language-python">self.green() == self.channel(1) 
</code></pre>
<p>These are equivalent operations if the colorspace is 'bgr' or 'bgra':</p>
<pre><code class="language-python">self.green() == self.channel(1) 
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;OpenCV returns images in BGR colorspace.
Use this method to always return the desired channel by color.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L745-L768" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def green(self):
    &#34;&#34;&#34;Return green channel as a cloned single channel `vipy.image.Image` object.

    These are equivalent operations if the colorspace is &#39;rgb&#39; or &#39;rgba&#39;:

    ```python
    self.green() == self.channel(1) 
    ```

    These are equivalent operations if the colorspace is &#39;bgr&#39; or &#39;bgra&#39;:

    ```python
    self.green() == self.channel(1) 
    ```

    .. note:: OpenCV returns images in BGR colorspace.  Use this method to always return the desired channel by color.
    &#34;&#34;&#34;
    assert self.channels() &gt;= 3, &#34;Must be three channel color image&#34;
    if self.colorspace() in [&#39;rgb&#39;, &#39;rgba&#39;]:
        return self.channel(1)
    elif self.colorspace() in [&#39;bgr&#39;, &#39;bgra&#39;]:
        return self.channel(1)
    else:
        raise ValueError(&#39;Invalid colorspace &#34;%s&#34; does not contain red channel&#39; % self.colorspace())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.grey"><code class="name flex">
<span>def <span class="ident">grey</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for greyscale()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1316-L1318" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grey(self):
    &#34;&#34;&#34;Alias for greyscale()&#34;&#34;&#34;
    return self.greyscale()</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.greyscale"><code class="name flex">
<span>def <span class="ident">greyscale</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the image buffer to single channel grayscale float32 in range [0,1]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1308-L1310" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def greyscale(self):
    &#34;&#34;&#34;Convert the image buffer to single channel grayscale float32 in range [0,1]&#34;&#34;&#34;
    return self._convert(&#39;gray&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.hasattribute"><code class="name flex">
<span>def <span class="ident">hasattribute</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L957-L958" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasattribute(self, key):
    return self.attributes is not None and key in self.attributes</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.hasfilename"><code class="name flex">
<span>def <span class="ident">hasfilename</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L968-L969" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasfilename(self):
    return self._filename is not None and os.path.exists(self._filename)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.hasurl"><code class="name flex">
<span>def <span class="ident">hasurl</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L965-L966" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasurl(self):
    return self._url is not None and isurl(self._url)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.height"><code class="name flex">
<span>def <span class="ident">height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the height (rows) of the image in integer pixels.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This triggers a <code><a title="vipy.image.Image.load" href="#vipy.image.Image.load">Image.load()</a></code> if the image is not already loaded.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L589-L594" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def height(self):
    &#34;&#34;&#34;Return the height (rows) of the image in integer pixels.
    
    .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
    &#34;&#34;&#34;        
    return self.load().array().shape[0]</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.hot"><code class="name flex">
<span>def <span class="ident">hot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply hot colormap to greyscale image and convert to RGB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1349-L1351" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hot(self):
    &#34;&#34;&#34;Apply hot colormap to greyscale image and convert to RGB&#34;&#34;&#34;
    return self._apply_colormap(&#39;hot&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.hsv"><code class="name flex">
<span>def <span class="ident">hsv</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the image buffer to three channel HSV uint8 colorspace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1292-L1294" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hsv(self):
    &#34;&#34;&#34;Convert the image buffer to three channel HSV uint8 colorspace&#34;&#34;&#34;
    return self._convert(&#39;hsv&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.html"><code class="name flex">
<span>def <span class="ident">html</span></span>(<span>self, alt=None, id=None, attributes={'loading': 'lazy'})</span>
</code></dt>
<dd>
<div class="desc"><p>Export a base64 encoding of the image suitable for embedding in an html page, enclosed in <img> tag</p>
<h2 id="returns">Returns</h2>
<p>-string:
<img src="data:image/jpeg;charset=utf-8;base64,%s" alt="%s" loading="lazy"> containing base64 encoded JPEG and alt text with lazy loading</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1495-L1506" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def html(self, alt=None, id=None, attributes={&#39;loading&#39;:&#39;lazy&#39;}):
    &#34;&#34;&#34;Export a base64 encoding of the image suitable for embedding in an html page, enclosed in &lt;img&gt; tag
       
       Returns:
          -string:  &lt;img src=&#34;data:image/jpeg;charset=utf-8;base64,%s&#34; alt=&#34;%s&#34; loading=&#34;lazy&#34;&gt; containing base64 encoded JPEG and alt text with lazy loading
    &#34;&#34;&#34;
    assert isinstance(attributes, dict)
    b = self.base64().decode(&#39;ascii&#39;)
    alt_text = alt if alt is not None else self.filename()
    id = id if id is not None else self.filename()
    attr = &#39; &#39;.join([&#39;%s=&#34;%s&#34;&#39; % (str(k),str(v)) for (k,v) in attributes.items()])
    return &#39;&lt;img %ssrc=&#34;data:image/jpeg;charset=utf-8;base64,%s&#34; alt=&#34;%s&#34; %s&gt;&#39; % ((&#39;id=&#34;%s&#34; &#39; % id) if id is not None else &#39;&#39;, b, str(alt_text), attr)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.imagebox"><code class="name flex">
<span>def <span class="ident">imagebox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the bounding box for the image rectangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1167-L1169" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imagebox(self):
    &#34;&#34;&#34;Return the bounding box for the image rectangle&#34;&#34;&#34;
    return BoundingBox(xmin=0, ymin=0, width=int(self.width()), height=int(self.height()))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.intensity"><code class="name flex">
<span>def <span class="ident">intensity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert image to float32 with [min,max] to range [0,1], force colormap to be 'float'.
Equivalent to self.mat2gray()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1361-L1364" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def intensity(self):
    &#34;&#34;&#34;Convert image to float32 with [min,max] to range [0,1], force colormap to be &#39;float&#39;.  Equivalent to self.mat2gray()&#34;&#34;&#34;
    self.array((self.load().float().array()) - float(self.min()) / float(self.max() - self.min()))
    return self.colorspace(&#39;float&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.iscolor"><code class="name flex">
<span>def <span class="ident">iscolor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Color images are three channel or four channel with transparency, float32 or uint8</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L561-L563" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iscolor(self):
    &#34;&#34;&#34;Color images are three channel or four channel with transparency, float32 or uint8&#34;&#34;&#34;
    return self.channels() == 3 or self.channels() == 4</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.isgrey"><code class="name flex">
<span>def <span class="ident">isgrey</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Grey images are one channel, float32</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L569-L571" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isgrey(self):
    &#34;&#34;&#34;Grey images are one channel, float32&#34;&#34;&#34;
    return self.channels() == 1 and self.array().dtype == np.float32</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.isloaded"><code class="name flex">
<span>def <span class="ident">isloaded</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if <code><a title="vipy.image.Image.load" href="#vipy.image.Image.load">Image.load()</a></code> was successful in reading the image, or if the pixels are present in <code><a title="vipy.image.Image.array" href="#vipy.image.Image.array">Image.array()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L553-L555" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isloaded(self):
    &#34;&#34;&#34;Return True if `vipy.image.Image.load` was successful in reading the image, or if the pixels are present in `vipy.image.Image.array`.&#34;&#34;&#34;
    return self._array is not None</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.isluminance"><code class="name flex">
<span>def <span class="ident">isluminance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Luninance images are one channel, uint8</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L573-L575" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isluminance(self):
    &#34;&#34;&#34;Luninance images are one channel, uint8&#34;&#34;&#34;
    return self.channels() == 1 and self.array().dtype == np.uint8</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.istransparent"><code class="name flex">
<span>def <span class="ident">istransparent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Transparent images are four channel color images with transparency, float32 or uint8.
Return true if this image contains an alpha transparency channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L565-L567" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def istransparent(self):
    &#34;&#34;&#34;Transparent images are four channel color images with transparency, float32 or uint8.  Return true if this image contains an alpha transparency channel&#34;&#34;&#34;
    return self.channels() == 4</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.jet"><code class="name flex">
<span>def <span class="ident">jet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply jet colormap to greyscale image and save as RGB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1341-L1343" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def jet(self):
    &#34;&#34;&#34;Apply jet colormap to greyscale image and save as RGB&#34;&#34;&#34;
    return self._apply_colormap(&#39;jet&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, s=None, encode=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L379-L396" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self, s=None, encode=True):
    if s is None:
        d = {&#39;_filename&#39;:self._filename,
             &#39;_url&#39;:self._url,
             &#39;_loader&#39;:self._loader,
             &#39;_array&#39;:self._array.tolist() if self._array is not None else None,
             &#39;_colorspace&#39;:self._colorspace,
             &#39;attributes&#39;:self.attributes}                        
        return json.dumps(d) if encode else d
    else:
        d = json.loads(s)
        self._filename = d[&#39;_filename&#39;]
        self._url = d[&#39;_url&#39;]
        self._loader = d[&#39;_loader&#39;]
        self._array = np.array(d[&#39;_array&#39;], dtype=np.uint8) if d[&#39;_array&#39;] is not None else None
        self._colorspace = d[&#39;_colorspace&#39;]
        self.attributes = d[&#39;attributes&#39;]            
        return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, ignoreErrors=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Load image to cached private '_array' attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ignoreErrors</code></strong></dt>
<dd>[bool] If true, ignore any exceptions thrown during load and print the corresponding error messages.
This is useful for loading images distributed without throwing exceptions when some images may be corrupted.
In this case, the _array attribute will be None and <code><a title="vipy.image.Image.isloaded" href="#vipy.image.Image.isloaded">Image.isloaded()</a></code> will return false to determine if the image is loaded, which can be used to filter out corrupted images gracefully. </dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>[bool] If true, show additional useful printed output</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object with the pixels loaded in self._array as a numpy array.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This loader supports any image file format supported by PIL.
A custom loader can be added using <code><a title="vipy.image.Image.loader" href="#vipy.image.Image.loader">Image.loader()</a></code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L406-L473" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load(self, ignoreErrors=False, verbose=False):
    &#34;&#34;&#34;Load image to cached private &#39;_array&#39; attribute.

    Args:
        ignoreErrors: [bool] If true, ignore any exceptions thrown during load and print the corresponding error messages.  This is useful for loading images distributed without throwing exceptions when some images may be corrupted.  In this case, the _array attribute will be None and `vipy.image.Image.isloaded` will return false to determine if the image is loaded, which can be used to filter out corrupted images gracefully. 
        verbose: [bool] If true, show additional useful printed output

    Returns:
        This `vipy.image.Image` object with the pixels loaded in self._array as a numpy array.

    .. note:: This loader supports any image file format supported by PIL.  A custom loader can be added using `vipy.image.Image.loader`.
    &#34;&#34;&#34;
    try:
        # Return if previously loaded image
        if self._array is not None:
            return self

        # Download URL to filename
        if self._url is not None:
            self.download(ignoreErrors=ignoreErrors, verbose=verbose)

        # Load filename to numpy array
        if self._loader is not None:
            self._array = self._loader(self._filename).astype(np.float32)  # forcing float32
            self.colorspace(&#39;float&#39;)
        elif isimagefile(self._filename):
            self._array = np.array(PIL.Image.open(self._filename))  # RGB order!
            if self.istransparent():
                self.colorspace(&#39;rgba&#39;)  # must be before iscolor()
            elif self.iscolor():
                self.colorspace(&#39;rgb&#39;)
            elif self.isgrey():
                self.colorspace(&#39;grey&#39;)
            elif self.isluminance():
                self.colorspace(&#39;lum&#39;)
            else:
                warnings.warn(&#39;unknown colorspace for image &#34;%s&#34; - attempting to coerce to colorspace=float&#39; % str(self._filename))
                self._array = np.float32(self._array)
                self.colorspace(&#39;float&#39;)
        elif iswebp(self._filename):
            import vipy.video
            return vipy.video.Video(self._filename).load()  
        elif hasextension(self._filename):
            raise ValueError(&#39;Non-standard image extensions require a custom loader&#39;)
        else:
            # Attempting to open it anyway, may be an image file without an extension. Cross your fingers ...
            self._array = np.array(PIL.Image.open(self._filename))  # RGB order!

    except IOError:
        if self._ignoreErrors or ignoreErrors:
            if verbose is True:
                warnings.warn(&#39;[vipy.image][WARNING]: IO error &#34;%s&#34; -&gt; &#34;%s&#34; - Ignoring. &#39; % (self.url(), self.filename()))
            self._array = None
        else:
            raise

    except KeyboardInterrupt:
        raise

    except Exception:
        if self._ignoreErrors or ignoreErrors:
            if verbose is True:
                warnings.warn(&#39;[vipy.image][WARNING]: Load error for image &#34;%s&#34; - Ignoring&#39; % self.filename())
            self._array = None
        else:
            raise

    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.loader"><code class="name flex">
<span>def <span class="ident">loader</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Lambda function to load an unsupported image filename to a numpy array.</p>
<p>This lambda function will be executed during load and the result will be stored in self._array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L398-L404" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loader(self, f):
    &#34;&#34;&#34;Lambda function to load an unsupported image filename to a numpy array.
    
    This lambda function will be executed during load and the result will be stored in self._array
    &#34;&#34;&#34;
    self._loader = f
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.lum"><code class="name flex">
<span>def <span class="ident">lum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for luminance()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1328-L1330" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lum(self):
    &#34;&#34;&#34;Alias for luminance()&#34;&#34;&#34;
    return self._convert(&#39;lum&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.luminance"><code class="name flex">
<span>def <span class="ident">luminance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the image buffer to single channel uint8 in range [0,255] corresponding to the luminance component</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1324-L1326" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def luminance(self):
    &#34;&#34;&#34;Convert the image buffer to single channel uint8 in range [0,255] corresponding to the luminance component&#34;&#34;&#34;
    return self._convert(&#39;lum&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply lambda function to our numpy array img, such that newimg=f(img), then replace newimg -&gt; self.array().
The output of this lambda function must be a numpy array and if the channels or dtype changes, the colorspace is set to 'float'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1526-L1535" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def map(self, func):
    &#34;&#34;&#34;Apply lambda function to our numpy array img, such that newimg=f(img), then replace newimg -&gt; self.array().  The output of this lambda function must be a numpy array and if the channels or dtype changes, the colorspace is set to &#39;float&#39;&#34;&#34;&#34;
    assert isinstance(func, types.LambdaType), &#34;Input must be lambda function (e.g. f = lambda img: 255.0-img)&#34;
    oldimg = self.array()  # reference
    newimg = func(self.array())  # in-place
    assert isnumpy(newimg), &#34;Lambda function output must be numpy array&#34;
    self.array(newimg)  # reference
    if newimg.dtype != oldimg.dtype or newimg.shape != oldimg.shape:
        self.colorspace(&#39;float&#39;)  # unknown colorspace after transformation, set generic
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.mat2gray"><code class="name flex">
<span>def <span class="ident">mat2gray</span></span>(<span>self, min=None, max=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the image buffer so that [min,max] -&gt; [0,1], forces conversion to 'float' colorspace.
This does not change the number of color channels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1366-L1370" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mat2gray(self, min=None, max=None):
    &#34;&#34;&#34;Convert the image buffer so that [min,max] -&gt; [0,1], forces conversion to &#39;float&#39; colorspace.  This does not change the number of color channels&#34;&#34;&#34;
    self.array(mat2gray(np.float32(self.load().float().array()), min, max))
    return self.colorspace(&#39;float&#39;)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.max"><code class="name flex">
<span>def <span class="ident">max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1411-L1412" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def max(self):
    return np.max(self.load().array().flatten())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.maxdim"><code class="name flex">
<span>def <span class="ident">maxdim</span></span>(<span>self, dim=None, interp='bilinear')</span>
</code></dt>
<dd>
<div class="desc"><p>Resize image preserving aspect ratio so that maximum dimension of image = dim, or return maxdim()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1045-L1047" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxdim(self, dim=None, interp=&#39;bilinear&#39;):
    &#34;&#34;&#34;Resize image preserving aspect ratio so that maximum dimension of image = dim, or return maxdim()&#34;&#34;&#34;
    return self.rescale(float(dim) / float(np.maximum(self.height(), self.width())), interp=interp) if dim is not None else max(self.shape())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.maxmatte"><code class="name flex">
<span>def <span class="ident">maxmatte</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop image of size (HxW) to (max(H,W), max(H,W)) with balanced zeropadding forming a letterbox with top/bottom matte or pillarbox with left/right matte</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1123-L1128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxmatte(self):
    &#34;&#34;&#34;Crop image of size (HxW) to (max(H,W), max(H,W)) with balanced zeropadding forming a letterbox with top/bottom matte or pillarbox with left/right matte&#34;&#34;&#34;
    S = np.max(self.load().shape())
    dW = S - self.width()
    dH = S - self.height()
    return self.zeropad((int(np.floor(dW//2)), int(np.ceil(dW//2))), (int(np.floor(dH//2)), int(np.ceil(dH//2))))._crop(BoundingBox(0, 0, width=int(S), height=int(S)))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.maxsquare"><code class="name flex">
<span>def <span class="ident">maxsquare</span></span>(<span>self, S=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop image of size (HxW) to (max(H,W), max(H,W)) with zeropadding or (S,S) if provided, keeping upper left corner constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1112-L1121" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxsquare(self, S=None):
    &#34;&#34;&#34;Crop image of size (HxW) to (max(H,W), max(H,W)) with zeropadding or (S,S) if provided, keeping upper left corner constant&#34;&#34;&#34;
    S = np.max(self.load().shape()) if S is None else int(S)
    (H, W) = self.shape()
    (dW, dH) = (max(0, S - W), max(0, S - H))
    if S != W or S != H:
        self._crop(BoundingBox(0, 0, width=min(W, S), height=min(H, S)))
        if (dW &gt; 0 or dH &gt; 0):
            self.zeropad((0,dW), (0,dH))  # crop then zeropad
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mean over all pixels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1414-L1416" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mean(self):
    &#34;&#34;&#34;Mean over all pixels&#34;&#34;&#34;
    return np.mean(self.load().array().flatten())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.meanchannel"><code class="name flex">
<span>def <span class="ident">meanchannel</span></span>(<span>self, k=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Mean per channel over all pixels.
If channel k is provided, return just the mean for that channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1418-L1421" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def meanchannel(self, k=None):
    &#34;&#34;&#34;Mean per channel over all pixels.  If channel k is provided, return just the mean for that channel&#34;&#34;&#34;
    C = np.mean(self.load().array(), axis=(0, 1)).flatten()
    return C[k] if k is not None else C</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.meanpad"><code class="name flex">
<span>def <span class="ident">meanpad</span></span>(<span>self, padwidth, padheight, mu=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Pad image using np.pad constant=image mean by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1088-L1100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def meanpad(self, padwidth, padheight, mu=None):
    &#34;&#34;&#34;Pad image using np.pad constant=image mean by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding&#34;&#34;&#34;        
    if not isinstance(padwidth, tuple):
        padwidth = (padwidth, padwidth)
    if not isinstance(padheight, tuple):
        padheight = (padheight, padheight)
    assert all([x&gt;=0 for x in padheight]) and all([x&gt;=0 for x in padwidth]), &#34;padding must be positive&#34;
    mu = self.meanchannel() if mu is None else mu
    self._array = np.squeeze(np.dstack([np.pad(img,
                                               pad_width=(padheight,padwidth),
                                               mode=&#39;constant&#39;,
                                               constant_values=c) for (img,c) in zip(self.channel(), mu)]))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.min"><code class="name flex">
<span>def <span class="ident">min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1408-L1409" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def min(self):
    return np.min(self.load().array().flatten())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.mindim"><code class="name flex">
<span>def <span class="ident">mindim</span></span>(<span>self, dim=None, interp='bilinear')</span>
</code></dt>
<dd>
<div class="desc"><p>Resize image preserving aspect ratio so that minimum dimension of image = dim, or return mindim()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1049-L1055" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mindim(self, dim=None, interp=&#39;bilinear&#39;):
    &#34;&#34;&#34;Resize image preserving aspect ratio so that minimum dimension of image = dim, or return mindim()&#34;&#34;&#34;
    if dim is None:
        return np.minimum(self.height(), self.width())
    else:
        s = float(dim) / float(np.minimum(self.height(), self.width()))
        return self.rescale(s, interp=interp) if dim is not None else min(self.shape())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.minsquare"><code class="name flex">
<span>def <span class="ident">minsquare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop image of size (HxW) to (min(H,W), min(H,W)), keeping upper left corner constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1107-L1110" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def minsquare(self):
    &#34;&#34;&#34;Crop image of size (HxW) to (min(H,W), min(H,W)), keeping upper left corner constant&#34;&#34;&#34;
    S = np.min(self.load().shape())
    return self._crop(BoundingBox(xmin=0, ymin=0, width=int(S), height=int(S)))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.nofilename"><code class="name flex">
<span>def <span class="ident">nofilename</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L868-L870" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nofilename(self):
    self._filename = None
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self, gain, bias)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a multiplicative gain g and additive bias b, such that self.array() == gain*self.array() + bias.</p>
<p>This is useful for applying a normalization of an image prior to calling <code><a title="vipy.image.Image.torch" href="#vipy.image.Image.torch">Image.torch()</a></code>.</p>
<p>The following operations are equivalent.</p>
<pre><code class="language-python">im = vipy.image.RandomImage()
im.normalize(1/255.0, 0.5) == im.gain(1/255.0).bias(-0.5)
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This will force the colorspace to 'float'</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1381-L1396" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize(self, gain, bias):
    &#34;&#34;&#34;Apply a multiplicative gain g and additive bias b, such that self.array() == gain*self.array() + bias.

    This is useful for applying a normalization of an image prior to calling `vipy.image.Image.torch`.

    The following operations are equivalent.

    ```python
    im = vipy.image.RandomImage()
    im.normalize(1/255.0, 0.5) == im.gain(1/255.0).bias(-0.5)
    ```
    
    .. note:: This will force the colorspace to &#39;float&#39;
    &#34;&#34;&#34;
    self.array(gain*self.load().float().array() + bias)
    return self.colorspace(&#39;float&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.nourl"><code class="name flex">
<span>def <span class="ident">nourl</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L880-L882" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nourl(self):
    self._url = None
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.numpy"><code class="name flex">
<span>def <span class="ident">numpy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a mutable numpy array for this <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code>.</p>
<div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>This will always return a writeable array with the 'WRITEABLE' numpy flag set.
This is useful for returning a mutable numpy array as needed while keeping the original non-mutable numpy array (e.g. loaded from a video or PIL) as the underlying pixel buffer for efficiency reasons.</li>
<li>Triggers a <code><a title="vipy.image.Image.load" href="#vipy.image.Image.load">Image.load()</a></code> if the pixel buffer has not been loaded</li>
<li>This will trigger a copy if the <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flags.html">'WRITEABLE' flag</a> is not set.</li>
</ul>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L680-L690" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def numpy(self):
    &#34;&#34;&#34;Return a mutable numpy array for this `vipy.image.Image`.

    .. notes:: 
        - This will always return a writeable array with the &#39;WRITEABLE&#39; numpy flag set.  This is useful for returning a mutable numpy array as needed while keeping the original non-mutable numpy array (e.g. loaded from a video or PIL) as the underlying pixel buffer for efficiency reasons.
        - Triggers a `vipy.image.Image.load` if the pixel buffer has not been loaded
        - This will trigger a copy if the [&#39;WRITEABLE&#39; flag](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flags.html) is not set. 
    &#34;&#34;&#34;        
    self.load()
    self._array = np.copy(self._array) if not self._array.flags[&#39;WRITEABLE&#39;] else self._array  # triggers copy         
    return self._array</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.perceptualhash"><code class="name flex">
<span>def <span class="ident">perceptualhash</span></span>(<span>self, bits=128, asbinary=False, asbytes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perceptual differential hash function</p>
<p>This function converts to greyscale, resizes with linear interpolation to small image based on desired bit encoding, compute vertical and horizontal gradient signs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bits</code></strong></dt>
<dd>[int]
longer hashes have lower TAR (true accept rate, some near dupes are missed), but lower FAR (false accept rate), shorter hashes have higher TAR (fewer near-dupes are missed) but higher FAR (more non-dupes are declared as dupes).</dd>
<dt><strong><code>asbinary</code></strong></dt>
<dd>[bool] If true, return a binary array</dd>
<dt><strong><code>asbytes</code></strong></dt>
<dd>[bool] if true return a byte array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>A hash string encoding the perceptual hash such that <code><a title="vipy.image.Image.perceptualhash_distance" href="#vipy.image.Image.perceptualhash_distance">Image.perceptualhash_distance()</a></code> can be used to compute a hash distance</dt>
<dt><code>asbytes</code></dt>
<dd>a bytes array</dd>
<dt><code>asbinary</code></dt>
<dd>a numpy binary array
</dd>
</dl>
<div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>Can be used for near duplicate detection by unpacking the returned hex string to binary and computing hamming distance, or performing hamming based nearest neighbor indexing.
Equivalently, <code><a title="vipy.image.Image.perceptualhash_distance" href="#vipy.image.Image.perceptualhash_distance">Image.perceptualhash_distance()</a></code>.</li>
<li>The default packed hex output can be converted to binary as: np.unpackbits(bytearray().fromhex(h)</li>
</ul>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1542-L1566" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def perceptualhash(self, bits=128, asbinary=False, asbytes=False):
    &#34;&#34;&#34;Perceptual differential hash function

    This function converts to greyscale, resizes with linear interpolation to small image based on desired bit encoding, compute vertical and horizontal gradient signs.
    
    Args:
        bits: [int]  longer hashes have lower TAR (true accept rate, some near dupes are missed), but lower FAR (false accept rate), shorter hashes have higher TAR (fewer near-dupes are missed) but higher FAR (more non-dupes are declared as dupes).
        asbinary: [bool] If true, return a binary array
        asbytes: [bool] if true return a byte array

    Returns:
        A hash string encoding the perceptual hash such that `vipy.image.Image.perceptualhash_distance` can be used to compute a hash distance
        asbytes: a bytes array
        asbinary: a numpy binary array            

    .. notes::
        - Can be used for near duplicate detection by unpacking the returned hex string to binary and computing hamming distance, or performing hamming based nearest neighbor indexing.  Equivalently, `vipy.image.Image.perceptualhash_distance`.
        - The default packed hex output can be converted to binary as: np.unpackbits(bytearray().fromhex(h)
    &#34;&#34;&#34;        
    allowablebits = [2*k*k for k in range(2, 17)]
    assert bits in allowablebits, &#34;Bits must be in %s&#34; % str(allowablebits)
    sq = int(np.ceil(np.sqrt(bits/2.0)))
    im = self.clone()
    b = (np.dstack(np.gradient(im.resize(cols=sq+1, rows=sq+1).greyscale().numpy()))[0:-1, 0:-1] &gt; 0).flatten()
    return bytes(np.packbits(b)).hex() if not (asbytes or asbinary) else bytes(np.packbits(b)) if asbytes else b</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.pil"><code class="name flex">
<span>def <span class="ident">pil</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert vipy.image.Image to PIL Image.</p>
<h2 id="returns">Returns</h2>
<p>A <a href="https://pillow.readthedocs.io/en/stable/reference/Image.html">PIL image</a> object, that shares the pixel buffer by reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L818-L825" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pil(self):
    &#34;&#34;&#34;Convert vipy.image.Image to PIL Image.
    
    Returns:
        A [PIL image](https://pillow.readthedocs.io/en/stable/reference/Image.html) object, that shares the pixel buffer by reference
    &#34;&#34;&#34;
    assert self.channels() in [1,3,4] and (self.channels() == 1 or self.colorspace() != &#39;float&#39;), &#34;Incompatible with PIL&#34;
    return PIL.Image.fromarray(self.numpy(), mode=&#39;RGB&#39; if self.colorspace()==&#39;rgb&#39; else None)  # FIXME: mode=&#39;RGB&#39; triggers slow tobytes() conversion, need RGBA or RGBX</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.pkl"><code class="name flex">
<span>def <span class="ident">pkl</span></span>(<span>self, pklfile=None)</span>
</code></dt>
<dd>
<div class="desc"><p>save the object to a pickle file and return the object, useful for intermediate saving in long fluent chains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1454-L1459" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pkl(self, pklfile=None):
    &#34;&#34;&#34;save the object to a pickle file and return the object, useful for intermediate saving in long fluent chains&#34;&#34;&#34;
    pklfile = pklfile if pklfile is not None else toextension(self.filename(), &#39;.pkl&#39;)
    remkdir(filepath(pklfile))
    vipy.util.save(self, pklfile)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.pklif"><code class="name flex">
<span>def <span class="ident">pklif</span></span>(<span>self, b, pklfile=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the object to the provided pickle file only if b=True. Uuseful for conditional intermediate saving in long fluent chains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1461-L1464" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pklif(self, b, pklfile=None):
    &#34;&#34;&#34;Save the object to the provided pickle file only if b=True. Uuseful for conditional intermediate saving in long fluent chains&#34;&#34;&#34;
    assert isinstance(b, bool)
    return self.pkl(pklfile) if b else self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, prefix='', verbose=True, sleep=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the representation of the image and return self with an optional sleep=n seconds</p>
<p>Useful for debugging in long fluent chains.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L218-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def print(self, prefix=&#39;&#39;, verbose=True, sleep=None):
    &#34;&#34;&#34;Print the representation of the image and return self with an optional sleep=n seconds
    
    Useful for debugging in long fluent chains.
    &#34;&#34;&#34;
    if verbose:
        print(prefix+self.__repr__())
    if sleep is not None:
        assert isinstance(sleep, int) and sleep &gt; 0, &#34;Sleep must be a non-negative integer number of seconds&#34;
        time.sleep(sleep)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.rainbow"><code class="name flex">
<span>def <span class="ident">rainbow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply rainbow colormap to greyscale image and convert to RGB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1345-L1347" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rainbow(self):
    &#34;&#34;&#34;Apply rainbow colormap to greyscale image and convert to RGB&#34;&#34;&#34;
    return self._apply_colormap(&#39;gist_rainbow&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.red"><code class="name flex">
<span>def <span class="ident">red</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return red channel as a cloned single channel <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object.</p>
<p>These are equivalent operations if the colorspace is 'rgb' or 'rgba':</p>
<pre><code class="language-python">self.red() == self.channel(0) 
</code></pre>
<p>These are equivalent operations if the colorspace is 'bgr' or 'bgra':</p>
<pre><code class="language-python">self.red() == self.channel(3) 
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;OpenCV returns images in BGR colorspace.
Use this method to always return the desired channel by color.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L720-L743" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def red(self):
    &#34;&#34;&#34;Return red channel as a cloned single channel `vipy.image.Image` object.

    These are equivalent operations if the colorspace is &#39;rgb&#39; or &#39;rgba&#39;:
    
    ```python
    self.red() == self.channel(0) 
    ```

    These are equivalent operations if the colorspace is &#39;bgr&#39; or &#39;bgra&#39;:

    ```python
    self.red() == self.channel(3) 
    ```

    .. note:: OpenCV returns images in BGR colorspace.  Use this method to always return the desired channel by color.
    &#34;&#34;&#34;
    assert self.channels() &gt;= 3, &#34;Must be color image&#34;
    if self.colorspace() in [&#39;rgb&#39;, &#39;rgba&#39;]:
        return self.channel(0)
    elif self.colorspace() in [&#39;bgr&#39;, &#39;bgra&#39;]:
        return self.channel(3)
    else:
        raise ValueError(&#39;Invalid colorspace &#34;%s&#34; does not contain red channel&#39; % self.colorspace())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.reload"><code class="name flex">
<span>def <span class="ident">reload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flush the image buffer to force reloading from file or URL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L549-L551" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reload(self):
    &#34;&#34;&#34;Flush the image buffer to force reloading from file or URL&#34;&#34;&#34;
    return self.clone(flush=True).load()</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.relpath"><code class="name flex">
<span>def <span class="ident">relpath</span></span>(<span>self, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace the filename with a relative path to parent (or current working directory if none)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L358-L362" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def relpath(self, parent=None):
    &#34;&#34;&#34;Replace the filename with a relative path to parent (or current working directory if none)&#34;&#34;&#34;
    parent = parent if parent is not None else os.getcwd()
    assert parent in os.path.expanduser(self.filename()), &#34;Parent path &#39;%s&#39; not found in abspath &#39;%s&#39;&#34; % (parent, self.filename())
    return self.filename(PurePath(os.path.expanduser(self.filename())).relative_to(parent))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.rescale"><code class="name flex">
<span>def <span class="ident">rescale</span></span>(<span>self, scale=1, interp='bilinear', fast=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale the image buffer by the given factor - NOT idempotent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1034-L1043" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rescale(self, scale=1, interp=&#39;bilinear&#39;, fast=False):
    &#34;&#34;&#34;Scale the image buffer by the given factor - NOT idempotent&#34;&#34;&#34;
    (height, width) = self.load().shape()
    if scale == 1:
        return self
    elif self.colorspace() == &#39;float&#39;:
        self._array = np.dstack([np.asarray(im.pil().resize((int(np.round(scale * width)), int(np.round(scale * height))), string_to_pil_interpolation(interp))) for im in self.channel()])
    else: 
        self._array = np.asarray(self.pil().resize((int(np.round(scale * width)), int(np.round(scale * height))), string_to_pil_interpolation(interp), reducing_gap=2 if fast else None))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, cols=None, rows=None, width=None, height=None, interp='bilinear', fast=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Resize the image buffer to (rows x cols) with bilinear interpolation.
If rows or cols is provided, rescale image maintaining aspect ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1009-L1027" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resize(self, cols=None, rows=None, width=None, height=None, interp=&#39;bilinear&#39;, fast=False):
    &#34;&#34;&#34;Resize the image buffer to (rows x cols) with bilinear interpolation.  If rows or cols is provided, rescale image maintaining aspect ratio&#34;&#34;&#34;
    assert not (cols is not None and width is not None), &#34;Define either width or cols&#34;
    assert not (rows is not None and height is not None), &#34;Define either height or rows&#34;
    rows = rows if height is None else height
    cols = cols if width is None else width
    if cols is None or rows is None:
        if cols is None:
            scale = float(rows) / float(self.height())
        else:
            scale = float(cols) / float(self.width())
        self.rescale(scale)
    elif rows == self.height() and cols == self.width():
        return self  
    elif self.colorspace() == &#39;float&#39;:
        self._array = np.dstack([np.array(im.pil().resize((cols, rows), string_to_pil_interpolation(interp))) for im in self.channel()])
    else:
        self._array = np.asarray(self.load().pil().resize((cols, rows), string_to_pil_interpolation(interp), reducing_gap=2 if fast else None))  
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.resize_like"><code class="name flex">
<span>def <span class="ident">resize_like</span></span>(<span>self, im, interp='bilinear')</span>
</code></dt>
<dd>
<div class="desc"><p>Resize image buffer to be the same size as the provided vipy.image.Image()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1029-L1032" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resize_like(self, im, interp=&#39;bilinear&#39;):
    &#34;&#34;&#34;Resize image buffer to be the same size as the provided vipy.image.Image()&#34;&#34;&#34;
    assert isinstance(im, Image), &#34;Invalid input - Must be vipy.image.Image()&#34;
    return self.resize(im.width(), im.height(), interp=interp)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.restore"><code class="name flex">
<span>def <span class="ident">restore</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the currently stored image to filename, and set up filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L347-L352" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def restore(self, filename):
    &#34;&#34;&#34;Save the currently stored image to filename, and set up filename&#34;&#34;&#34;
    assert self.hasattribute(&#39;__image__&#39;), &#34;Image not stored&#34;
    with open(filename, &#39;wb&#39;) as f:
        f.write(self.attributes[&#39;__image__&#39;])
    return self.filename(filename)                </code></pre>
</details>
</dd>
<dt id="vipy.image.Image.rgb"><code class="name flex">
<span>def <span class="ident">rgb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the image buffer to three channel RGB uint8 colorspace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1284-L1286" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rgb(self):
    &#34;&#34;&#34;Convert the image buffer to three channel RGB uint8 colorspace&#34;&#34;&#34;
    return self._convert(&#39;rgb&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.rgba"><code class="name flex">
<span>def <span class="ident">rgba</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the image buffer to four channel RGBA uint8 colorspace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1288-L1290" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rgba(self):
    &#34;&#34;&#34;Convert the image buffer to four channel RGBA uint8 colorspace&#34;&#34;&#34;
    return self._convert(&#39;rgba&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.rot90ccw"><code class="name flex">
<span>def <span class="ident">rot90ccw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate the scene 90 degrees counterclockwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1580-L1583" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90ccw(self):
    &#34;&#34;&#34;Rotate the scene 90 degrees counterclockwise&#34;&#34;&#34;
    self.array(np.rot90(self.numpy(), 1))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.rot90cw"><code class="name flex">
<span>def <span class="ident">rot90cw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate the scene 90 degrees clockwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1575-L1578" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90cw(self):
    &#34;&#34;&#34;Rotate the scene 90 degrees clockwise&#34;&#34;&#34;
    self.array(np.rot90(self.numpy(), 3))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a rotation in radians to the pixels, with origin in upper left</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1280-L1282" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotate(self, r):
    &#34;&#34;&#34;Apply a rotation in radians to the pixels, with origin in upper left &#34;&#34;&#34;
    return self.affine_transform(vipy.geometry.affine_transform(r=r))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.sanitize"><code class="name flex">
<span>def <span class="ident">sanitize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all private keys from the attributes dictionary.</p>
<p>The attributes dictionary is useful storage for arbitrary (key,value) pairs.
However, this storage may contain sensitive information that should be scrubbed from the media before serialization.
As a general rule, any key that is of the form '__keyname' prepended by two underscores is a private key.
This is analogous to private or reserved attributes in the python lanugage.
Users should reserve these keynames for those keys that should be sanitized and removed before any serialization of this object.</p>
<pre><code class="language-python">assert self.setattribute('__mykey', 1).sanitize().hasattribute('__mykey') == False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L205-L216" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sanitize(self):
    &#34;&#34;&#34;Remove all private keys from the attributes dictionary.
    
    The attributes dictionary is useful storage for arbitrary (key,value) pairs.  However, this storage may contain sensitive information that should be scrubbed from the media before serialization.  As a general rule, any key that is of the form &#39;__keyname&#39; prepended by two underscores is a private key.  This is analogous to private or reserved attributes in the python lanugage.  Users should reserve these keynames for those keys that should be sanitized and removed before any serialization of this object.
    
    ```python
    assert self.setattribute(&#39;__mykey&#39;, 1).sanitize().hasattribute(&#39;__mykey&#39;) == False
    ```

    &#34;&#34;&#34;
    self.attributes = {k:v for (k,v) in self.attributes.items() if not k.startswith(&#39;__&#39;)} if isinstance(self.atttributes, dict) else self.attributes
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.saturate"><code class="name flex">
<span>def <span class="ident">saturate</span></span>(<span>self, min, max)</span>
</code></dt>
<dd>
<div class="desc"><p>Saturate the image buffer to be clipped between [min,max], types of min/max are specified by _array type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1357-L1359" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def saturate(self, min, max):
    &#34;&#34;&#34;Saturate the image buffer to be clipped between [min,max], types of min/max are specified by _array type&#34;&#34;&#34;
    return self.array(np.minimum(np.maximum(self.load().array(), min), max))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the current image to a new filename and return the image object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1447-L1450" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def save(self, filename):
    &#34;&#34;&#34;Save the current image to a new filename and return the image object&#34;&#34;&#34;
    assert filename is not None, &#34;Invalid filename - must be path to new image filename&#34;
    return self.filename(self.saveas(filename))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.saveas"><code class="name flex">
<span>def <span class="ident">saveas</span></span>(<span>self, filename=None, writeas=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save current buffer (not including drawing overlays) to new filename and return filename.
If filename is not provided, use a temporary JPEG filename.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1466-L1475" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def saveas(self, filename=None, writeas=None):
    &#34;&#34;&#34;Save current buffer (not including drawing overlays) to new filename and return filename.  If filename is not provided, use a temporary JPEG filename.&#34;&#34;&#34;
    filename = tempjpg() if filename is None else filename
    if self.colorspace() in [&#39;gray&#39;]:
        imwritegray(self.grayscale()._array, filename)
    elif self.colorspace() != &#39;float&#39;:
        imwrite(self.load().array(), filename, writeas=writeas)
    else:
        raise ValueError(&#39;Convert float image to RGB or gray first. Try self.mat2gray()&#39;)
    return filename</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.saveastmp"><code class="name flex">
<span>def <span class="ident">saveastmp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save current buffer to temp JPEG filename and return filename.
Alias for savetmp()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1477-L1479" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def saveastmp(self):
    &#34;&#34;&#34;Save current buffer to temp JPEG filename and return filename.  Alias for savetmp()&#34;&#34;&#34;
    return self.saveas(tempjpg())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.savefig"><code class="name flex">
<span>def <span class="ident">savefig</span></span>(<span>self, filename=None, figure=1, timestamp=None, timestampcolor='black', timestampfacecolor='white', mutator=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save last figure output from self.show() with drawing overlays to provided filename and return filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1513-L1524" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def savefig(self, filename=None, figure=1, timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None):
    &#34;&#34;&#34;Save last figure output from self.show() with drawing overlays to provided filename and return filename&#34;&#34;&#34;
    self.show(figure=figure, nowindow=True, timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, mutator=mutator)  # sets figure dimensions, does not display window
    (W,H) = plt.figure(figure).canvas.get_width_height()  # fast
    buf = io.BytesIO()
    plt.figure(1).canvas.print_raw(buf)  # fast
    img = np.frombuffer(buf.getbuffer(), dtype=np.uint8).reshape((H, W, 4))  # RGBA
    vipy.show.close(figure)
    t = vipy.image.Image(array=img, colorspace=&#39;rgba&#39;)
    if filename is not None:
        t.rgb().saveas(os.path.abspath(os.path.expanduser(filename)))
    return t</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.savetmp"><code class="name flex">
<span>def <span class="ident">savetmp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save current buffer to temp JPEG filename and return filename.
Alias for saveastmp()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1481-L1483" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def savetmp(self):
    &#34;&#34;&#34;Save current buffer to temp JPEG filename and return filename.   Alias for saveastmp()&#34;&#34;&#34;
    return self.saveastmp()</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.setattribute"><code class="name flex">
<span>def <span class="ident">setattribute</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set element self.attributes[key]=value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L939-L945" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setattribute(self, key, value):
    &#34;&#34;&#34;Set element self.attributes[key]=value&#34;&#34;&#34;
    if self.attributes is None:
        self.attributes = {key: value}
    else:
        self.attributes[key] = value
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.setattributes"><code class="name flex">
<span>def <span class="ident">setattributes</span></span>(<span>self, newattr)</span>
</code></dt>
<dd>
<div class="desc"><p>Set many attributes at once by providing a dictionary to be merged with current attributes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L947-L951" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setattributes(self, newattr):
    &#34;&#34;&#34;Set many attributes at once by providing a dictionary to be merged with current attributes&#34;&#34;&#34;
    assert isinstance(newattr, dict), &#34;New attributes must be dictionary&#34;
    self.attributes.update(newattr)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.shape"><code class="name flex">
<span>def <span class="ident">shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (height, width) or equivalently (rows, cols) of the image.</p>
<h2 id="returns">Returns</h2>
<p>A tuple (height=int, width=int) of the image.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This triggers a <code><a title="vipy.image.Image.load" href="#vipy.image.Image.load">Image.load()</a></code> if the image is not already loaded.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L596-L604" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shape(self):
    &#34;&#34;&#34;Return the (height, width) or equivalently (rows, cols) of the image.
    
    Returns:
        A tuple (height=int, width=int) of the image.

    .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
    &#34;&#34;&#34;
    return (self.load().height(), self.width())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, figure=1, nowindow=False, timestamp=None, timestampfacecolor='white', timestampcolor='black', mutator=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Display image on screen in provided figure number (clone and convert to RGB colorspace to show), return object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1440-L1445" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def show(self, figure=1, nowindow=False, timestamp=None, timestampfacecolor=&#39;white&#39;, timestampcolor=&#39;black&#39;, mutator=None):
    &#34;&#34;&#34;Display image on screen in provided figure number (clone and convert to RGB colorspace to show), return object&#34;&#34;&#34;
    assert self.load().isloaded(), &#39;Image not loaded&#39;
    im = self.clone() if not mutator else mutator(self.clone())        
    vipy.show.imshow(im.rgb().numpy(), fignum=figure, nowindow=nowindow, timestamp=timestamp, timestampfacecolor=timestampfacecolor, flush=True, timestampcolor=timestampcolor)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.splat"><code class="name flex">
<span>def <span class="ident">splat</span></span>(<span>self, im, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace pixels within boundingbox in self with pixels in im</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L317-L323" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def splat(self, im, bb):
    &#34;&#34;&#34;Replace pixels within boundingbox in self with pixels in im&#34;&#34;&#34;
    assert isinstance(im, vipy.image.Image), &#34;invalid image&#34;
    assert (im.width() == bb.width() and im.height() == bb.height()) or bb.isinterior(im.width(), im.height()) and bb.isinterior(self.width(), self.height()), &#34;Invalid bounding box &#39;%s&#39;&#34; % str(bb)
    (x,y,w,h) = bb.xywh()
    self._array[int(y):int(y+h), int(x):int(x+w)] = im.array() if (im.width() == bb.width() and im.height() == bb.height()) else im.array()[int(y):int(y+h), int(x):int(x+w)]
    return self            </code></pre>
</details>
</dd>
<dt id="vipy.image.Image.stats"><code class="name flex">
<span>def <span class="ident">stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1399-L1406" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def stats(self):
    print(self)
    print(&#39;  Channels: %d&#39; % self.channels())
    print(&#39;  Shape: %s&#39; % str(self.shape()))
    print(&#39;  min: %s&#39; % str(self.min()))
    print(&#39;  max: %s&#39; % str(self.max()))
    print(&#39;  mean: %s&#39; % str(self.mean()))
    print(&#39;  channel mean: %s&#39; % str(self.meanchannel()))        </code></pre>
</details>
</dd>
<dt id="vipy.image.Image.store"><code class="name flex">
<span>def <span class="ident">store</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Store the current image file as an attribute of this object.
Useful for archiving an object to be fully self contained without any external references.
</p>
<p>-Remove this stored image using unstore()
-Unpack this stored image and set up the filename using restore()
-This method is more efficient than load() followed by pkl(), as it stores the encoded image as a byte string.
-Useful for creating a single self contained object for distributed processing.
</p>
<pre><code class="language-python">v == v.store().restore(v.filename()) 
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L325-L341" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def store(self):
    &#34;&#34;&#34;Store the current image file as an attribute of this object.  Useful for archiving an object to be fully self contained without any external references.  
    
       -Remove this stored image using unstore()
       -Unpack this stored image and set up the filename using restore() 
       -This method is more efficient than load() followed by pkl(), as it stores the encoded image as a byte string.
       -Useful for creating a single self contained object for distributed processing.  

    ```python
    v == v.store().restore(v.filename()) 
    ```

    &#34;&#34;&#34;
    assert self.hasfilename(), &#34;Image file not found&#34;
    with open(self.filename(), &#39;rb&#39;) as f:
        self.attributes[&#39;__image__&#39;] = f.read()
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1423-L1424" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sum(self):
    return np.sum(self.load().array().flatten())</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.tile"><code class="name flex">
<span>def <span class="ident">tile</span></span>(<span>self, tilewidth, tileheight, overlaprows=0, overlapcols=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an image tiling.</p>
<p>A tiling is a decomposition of an image into overlapping or non-overlapping rectangular regions.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tilewidth</code></strong></dt>
<dd>[int] the image width of each tile</dd>
<dt><strong><code>tileheight</code></strong></dt>
<dd>[int] the image height of each tile</dd>
<dt><strong><code>overlaprows</code></strong></dt>
<dd>[int] the number of overlapping rows (height) for each tile</dd>
<dt><strong><code>overlapcols</code></strong></dt>
<dd>[int] the number of overlapping width (width) for each tile</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> objects such that each image is a single tile and the set of these tiles forms the original image
Each image in the returned list contains the 'tile' attribute which encodes the crop used to create the tile.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li><code><a title="vipy.image.Image.tile" href="#vipy.image.Image.tile">Image.tile()</a></code> can be undone using <code><a title="vipy.image.Image.untile" href="#vipy.image.Image.untile">Image.untile()</a></code></li>
<li>The identity tiling is im.tile(im.widht(), im.height(), overlaprows=0, overlapcols=0)</li>
<li>Ragged tiles outside the image boundary are zero padded</li>
<li>All annotations are updated properly for each tile, when the source image is <code><a title="vipy.image.Scene" href="#vipy.image.Scene">Scene</a></code></li>
</ul>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L230-L254" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tile(self, tilewidth, tileheight, overlaprows=0, overlapcols=0):
    &#34;&#34;&#34;Generate an image tiling.
    
    A tiling is a decomposition of an image into overlapping or non-overlapping rectangular regions.  

    Args:
        tilewidth: [int] the image width of each tile
        tileheight: [int] the image height of each tile
        overlaprows: [int] the number of overlapping rows (height) for each tile
        overlapcols: [int] the number of overlapping width (width) for each tile

    Returns:
        A list of `vipy.image.Image` objects such that each image is a single tile and the set of these tiles forms the original image
        Each image in the returned list contains the &#39;tile&#39; attribute which encodes the crop used to create the tile.

    .. note:: 
        - `vipy.image.Image.tile` can be undone using `vipy.image.Image.untile`
        - The identity tiling is im.tile(im.widht(), im.height(), overlaprows=0, overlapcols=0)
        - Ragged tiles outside the image boundary are zero padded
        - All annotations are updated properly for each tile, when the source image is `vipy.image.Scene`
    &#34;&#34;&#34;
    assert tilewidth &gt; 0 and tileheight &gt; 0 and overlaprows &gt;= 0 and overlapcols &gt;= 0, &#34;Invalid input&#34;
    assert self.width() &gt;= tilewidth-overlapcols and self.height() &gt;= tileheight-overlaprows, &#34;Invalid input&#34; 
    bboxes = [BoundingBox(xmin=i, ymin=j, width=min(tilewidth, self.width()-i), height=min(tileheight, self.height()-j)) for i in range(0, self.width()-overlapcols, tilewidth-overlapcols) for j in range(0, self.height()-overlaprows, tileheight-overlaprows)]
    return [self.clone(shallow=True, attributes=True).setattribute(&#39;tile&#39;, {&#39;crop&#39;:bb, &#39;shape&#39;:self.shape()}).crop(bb) for bb in bboxes]</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.tonumpy"><code class="name flex">
<span>def <span class="ident">tonumpy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for `vipy.image.Image.numpy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L676-L678" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tonumpy(self):
    &#34;&#34;&#34;Alias for `vipy.image.Image.numpy&#34;&#34;&#34;
    return self.numpy()</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.torch"><code class="name flex">
<span>def <span class="ident">torch</span></span>(<span>self, order='CHW')</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the batch of 1 HxWxC images to a CxHxW torch tensor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>order</code></strong></dt>
<dd>['CHW', 'HWC', 'NCHW', 'NHWC'].
The axis order of the torch tensor (channels, height, width) or (height, width, channels) or (1, channels, height, width) or (1, height, width, channels)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A CxHxW or HxWxC or 1xCxHxW or 1xHxWxC <a href="https://pytorch.org/docs/stable/tensors.html">torch tensor</a> that shares the pixel buffer of this image object by reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L839-L853" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def torch(self, order=&#39;CHW&#39;):
    &#34;&#34;&#34;Convert the batch of 1 HxWxC images to a CxHxW torch tensor.

    Args:
        order: [&#39;CHW&#39;, &#39;HWC&#39;, &#39;NCHW&#39;, &#39;NHWC&#39;].  The axis order of the torch tensor (channels, height, width) or (height, width, channels) or (1, channels, height, width) or (1, height, width, channels)

    Returns:
        A CxHxW or HxWxC or 1xCxHxW or 1xHxWxC [torch tensor](https://pytorch.org/docs/stable/tensors.html) that shares the pixel buffer of this image object by reference.
    &#34;&#34;&#34;
    try_import(&#39;torch&#39;); import torch
    assert order.lower() in [&#39;chw&#39;, &#39;hwc&#39;, &#39;nchw&#39;, &#39;nhwc&#39;]
    img = self.numpy() if self.iscolor() else np.expand_dims(self.numpy(), 2)  # HxW -&gt; HxWx1
    img = img.transpose(2,0,1) if order.lower() in [&#39;chw&#39;, &#39;nchw&#39;]  else img   # HxWxC or CxHxW        
    img = np.expand_dims(img,0) if order.lower() in [&#39;nhwc&#39;, &#39;nchw&#39;] else img  # HxWxC -&gt; 1xHxWxC
    return torch.from_numpy(img)  </code></pre>
</details>
</dd>
<dt id="vipy.image.Image.uncrop"><code class="name flex">
<span>def <span class="ident">uncrop</span></span>(<span>self, bb, shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Uncrop using provided bounding box and zeropad to shape=(Height, Width).</p>
<p>An uncrop is the inverse operation for a crop, which preserves the cropped portion of the image in the correct location and replaces the rest with zeros out to shape.</p>
<pre><code class="language-python">im = vipy.image.RandomImage(128, 128)
bb = vipy.geometry.BoundingBox(xmin=0, ymin=0, width=64, height=64)
uncrop = im.crop(bb).uncrop(bb, shape=(128,128))
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bb</code></strong></dt>
<dd>[<code>vipy.geometry.BoundingBox</code>] the bounding box used to crop the image in self</dd>
<dt><strong><code>shape</code></strong></dt>
<dd>[tuple] (height, width) of the uncropped image</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>this <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object with the pixels uncropped.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;NOT idempotent.
This will generate different results if run more than once.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L289-L315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def uncrop(self, bb, shape):
    &#34;&#34;&#34;Uncrop using provided bounding box and zeropad to shape=(Height, Width).

    An uncrop is the inverse operation for a crop, which preserves the cropped portion of the image in the correct location and replaces the rest with zeros out to shape.

    ```python
    im = vipy.image.RandomImage(128, 128)
    bb = vipy.geometry.BoundingBox(xmin=0, ymin=0, width=64, height=64)
    uncrop = im.crop(bb).uncrop(bb, shape=(128,128))
    ```

    Args:
        bb: [`vipy.geometry.BoundingBox`] the bounding box used to crop the image in self
        shape: [tuple] (height, width) of the uncropped image

    Returns:
        this `vipy.image.Image` object with the pixels uncropped.

    .. note:: NOT idempotent.  This will generate different results if run more than once.
    &#34;&#34;&#34;
    ((x,y,w,h), (H,W)) = (bb.xywh(), shape)
    ((dyb, dya), (dxb, dxa)) = ((int(y), int(H-(y+h))), (int(x), int(W-(x+w))))
    self._array = np.pad(self.load().array(),
                         ((dyb, dya), (dxb, dxa), (0, 0)) if
                         self.load().array().ndim == 3 else ((dyb, dya), (dxb, dxa)),
                         mode=&#39;constant&#39;)        
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>No-op for <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L256-L258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def union(self, other):
    &#34;&#34;&#34;No-op for `vipy.image.Image`&#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.unstore"><code class="name flex">
<span>def <span class="ident">unstore</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the currently stored image from store()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L343-L345" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unstore(self):
    &#34;&#34;&#34;Delete the currently stored image from store()&#34;&#34;&#34;
    return self.delattribute(&#39;__image__&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.uri"><code class="name flex">
<span>def <span class="ident">uri</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the URI of the image object, either the URL or the filename, raise exception if neither defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L930-L937" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def uri(self):
    &#34;&#34;&#34;Return the URI of the image object, either the URL or the filename, raise exception if neither defined&#34;&#34;&#34;
    if self.hasurl():
        return self.url()
    elif self.hasfilename():
        return self.filename()
    else:
        raise ValueError(&#39;No URI defined&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.url"><code class="name flex">
<span>def <span class="ident">url</span></span>(<span>self, url=None, username=None, password=None, sha1=None, ignoreUrlErrors=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Image URL and URL download properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L884-L899" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def url(self, url=None, username=None, password=None, sha1=None, ignoreUrlErrors=None):
    &#34;&#34;&#34;Image URL and URL download properties&#34;&#34;&#34;
    if url is not None:
        self._url = url  # this does not change anything else (e.g. the associated filename), better to use constructor 
    if username is not None:
        self._urluser = username  # basic authentication
    if password is not None:
        self._urlpassword = password  # basic authentication
    if sha1 is not None:
        self._urlsha1 = sha1  # file integrity
    if ignoreUrlErrors is not None:
        self._ignoreErrors = ignoreUrlErrors
    if url is None and username is None and password is None and sha1 is None and ignoreUrlErrors is None:
        return self._url
    else:
        return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the width (columns) of the image in integer pixels.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This triggers a <code><a title="vipy.image.Image.load" href="#vipy.image.Image.load">Image.load()</a></code> if the image is not already loaded.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L582-L587" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def width(self):
    &#34;&#34;&#34;Return the width (columns) of the image in integer pixels.
    
    .. note:: This triggers a `vipy.image.Image.load` if the image is not already loaded.
    &#34;&#34;&#34;
    return self.load().array().shape[1]</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.zeropad"><code class="name flex">
<span>def <span class="ident">zeropad</span></span>(<span>self, padwidth, padheight)</span>
</code></dt>
<dd>
<div class="desc"><p>Pad image using np.pad constant by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1065-L1080" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def zeropad(self, padwidth, padheight):
    &#34;&#34;&#34;Pad image using np.pad constant by adding padwidth on both left and right , or padwidth=(left,right) for different pre/postpadding,, and padheight on top and bottom or padheight=(top,bottom) for different pre/post padding&#34;&#34;&#34;
    if not isinstance(padwidth, tuple):
        padwidth = (padwidth, padwidth)
    if not isinstance(padheight, tuple):
        padheight = (padheight, padheight)
    if self.iscolor():
        pad_shape = (padheight, padwidth, (0, 0))
    else:
        pad_shape = (padheight, padwidth)

    assert all([x&gt;=0 for x in padheight]) and all([x&gt;=0 for x in padwidth]), &#34;padding must be positive&#34;
    if padwidth[0]&gt;0 or padwidth[1]&gt;0 or padheight[0]&gt;0 or padheight[1]&gt;0:
        self._array = np.pad(self.load().array(), pad_width=pad_shape, mode=&#39;constant&#39;, constant_values=0)  # this is still slow due to the required copy, but fast-ish in np &gt;= 1.17
        
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.zeropadlike"><code class="name flex">
<span>def <span class="ident">zeropadlike</span></span>(<span>self, width, height)</span>
</code></dt>
<dd>
<div class="desc"><p>Zero pad the image balancing the border so that the resulting image size is (width, height)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1082-L1086" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def zeropadlike(self, width, height):
    &#34;&#34;&#34;Zero pad the image balancing the border so that the resulting image size is (width, height)&#34;&#34;&#34;
    assert width &gt;= self.width() and height &gt;= self.height(), &#34;Invalid input - final (width=%d, height=%d) must be greater than current image size (width=%d, height=%d)&#34; % (width, height, self.width(), self.height())
    return self.zeropad( (int(np.floor((width - self.width())/2)), int(np.ceil((width - self.width())/2))),
                         (int(np.floor((height - self.height())/2)), int(np.ceil((height - self.height())/2))))</code></pre>
</details>
</dd>
<dt id="vipy.image.Image.zeros"><code class="name flex">
<span>def <span class="ident">zeros</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the pixel buffer to all zeros of the same shape and datatype as this <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object.</p>
<p>These are equivalent operations for the resulting buffer shape: </p>
<pre><code class="language-python">import numpy as np
np.zeros( (self.width(), self.height(), self.channels()) ) == self.zeros().array()
</code></pre>
<h2 id="returns">Returns</h2>
<p>This <code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code> object.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Triggers load() if the pixel buffer has not been loaded yet.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L800-L816" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def zeros(self):
    &#34;&#34;&#34;Set the pixel buffer to all zeros of the same shape and datatype as this `vipy.image.Image` object.
    
    These are equivalent operations for the resulting buffer shape: 
    
    ```python
    import numpy as np
    np.zeros( (self.width(), self.height(), self.channels()) ) == self.zeros().array()
    ```

    Returns:
       This `vipy.image.Image` object.

    .. note:: Triggers load() if the pixel buffer has not been loaded yet.
    &#34;&#34;&#34;
    self._array = 0*self.load()._array
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.image.ImageCategory"><code class="flex name class">
<span>class <span class="ident">ImageCategory</span></span>
<span>(</span><span>filename=None, url=None, category=None, label=None, attributes=None, array=None, colorspace=None)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy ImageCategory class</p>
<p>This class provides a representation of a vipy.image.Image with a category. </p>
<p>Valid constructors include all provided by vipy.image.Image with the additional kwarg 'category' (or alias 'label')</p>
<pre><code class="language-python">im = vipy.image.ImageCategory(filename='/path/to/dog_image.ext', category='dog')
im = vipy.image.ImageCategory(url='http://path/to/dog_image.ext', category='dog')
im = vipy.image.ImageCategory(array=dog_img, colorspace='rgb', category='dog')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1586-L1691" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ImageCategory(Image):
    &#34;&#34;&#34;vipy ImageCategory class

    This class provides a representation of a vipy.image.Image with a category. 

    Valid constructors include all provided by vipy.image.Image with the additional kwarg &#39;category&#39; (or alias &#39;label&#39;)

    ```python
    im = vipy.image.ImageCategory(filename=&#39;/path/to/dog_image.ext&#39;, category=&#39;dog&#39;)
    im = vipy.image.ImageCategory(url=&#39;http://path/to/dog_image.ext&#39;, category=&#39;dog&#39;)
    im = vipy.image.ImageCategory(array=dog_img, colorspace=&#39;rgb&#39;, category=&#39;dog&#39;)
    ```

    &#34;&#34;&#34;
    
    def __init__(self, filename=None, url=None, category=None, label=None,
                 attributes=None, array=None, colorspace=None):
        # Image class inheritance
        super().__init__(filename=filename,
                         url=url,
                         attributes=attributes,
                         array=array,
                         colorspace=colorspace)
        assert not (category is not None and label is not None), &#34;Define either category or label kwarg, not both&#34;
        self._category = category if category is not None else label

    @classmethod
    def cast(cls, im, flush=False):
        assert isinstance(im, vipy.image.Image)
        im.__class__ = vipy.image.ImageCategory
        im._category = None if flush or not hasattr(im, &#39;_category&#39;) else im._category
        return im

    @classmethod
    def from_json(obj, s):
        im = super().from_json(s)
        im._category = json.loads(s)[&#39;_category&#39;]
        return im

    def json(self, s=None, encode=True):
        if s is None:
            d = json.loads(super().json())
            d[&#39;_category&#39;] = self._category
            return json.dumps(d) if encode else d
        else:
            super().json(s)
            d = json.loads(s)            
            self._category = d[&#39;_category&#39;]
            return self
    
    def __repr__(self):
        strlist = []
        if self.isloaded():
            strlist.append(&#34;height=%d, width=%d, color=%s&#34; % (self.height(), self.width(), self.colorspace()))
        if self.filename() is not None:
            strlist.append(&#39;filename=&#34;%s&#34;&#39; % (self.filename() if self.hasfilename() else &#39;&lt;NOTFOUND&gt;%s&lt;/NOTFOUND&gt;&#39; % self.filename()))
        if self.hasurl():
            strlist.append(&#39;url=&#34;%s&#34;&#39; % self.url())
        if self.category() is not None:
            strlist.append(&#39;category=&#34;%s&#34;&#39; % self.category())
        return str(&#39;&lt;vipy.imagecategory: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def __eq__(self, other):
        return self._category.lower() == other._category.lower() if isinstance(other, ImageCategory) else False

    def __ne__(self, other):
        return self._category.lower() != other._category.lower()

    def is_(self, other):
        return self.__eq__(other)

    def is_not(self, other):
        return self.__ne__(other)

    def nocategory(self):
        self._category = None
        return self

    def category(self, newcategory=None):
        &#34;&#34;&#34;Return or update the category&#34;&#34;&#34;
        if newcategory is None:
            return self._category
        else:
            self._category = newcategory
            return self

    def label(self, newlabel=None):
        &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
        return self.category(newlabel)
    
    def score(self, newscore=None):
        &#34;&#34;&#34;Real valued score for categorization, larger is better&#34;&#34;&#34;
        if newscore is None:
            return self.getattribute(&#39;score&#39;)
        else:
            self.setattribute(&#39;score&#39;, newscore)
            return self

    def probability(self, newprob=None):
        &#34;&#34;&#34;Real valued probability for categorization, [0,1]&#34;&#34;&#34;
        if newprob is None:
            return self.getattribute(&#39;probability&#39;)
        else:
            self.setattribute(&#39;probability&#39;, newprob)
            self.setattribute(&#39;RawDetectionProbability&#39;, newprob)
            return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vipy.image.Scene" href="#vipy.image.Scene">Scene</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="vipy.image.ImageCategory.category"><code class="name flex">
<span>def <span class="ident">category</span></span>(<span>self, newcategory=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return or update the category</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1664-L1670" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def category(self, newcategory=None):
    &#34;&#34;&#34;Return or update the category&#34;&#34;&#34;
    if newcategory is None:
        return self._category
    else:
        self._category = newcategory
        return self</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageCategory.is_"><code class="name flex">
<span>def <span class="ident">is_</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1654-L1655" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_(self, other):
    return self.__eq__(other)</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageCategory.is_not"><code class="name flex">
<span>def <span class="ident">is_not</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1657-L1658" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_not(self, other):
    return self.__ne__(other)</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageCategory.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, s=None, encode=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1625-L1634" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self, s=None, encode=True):
    if s is None:
        d = json.loads(super().json())
        d[&#39;_category&#39;] = self._category
        return json.dumps(d) if encode else d
    else:
        super().json(s)
        d = json.loads(s)            
        self._category = d[&#39;_category&#39;]
        return self</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageCategory.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>self, newlabel=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for category</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1672-L1674" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def label(self, newlabel=None):
    &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
    return self.category(newlabel)</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageCategory.nocategory"><code class="name flex">
<span>def <span class="ident">nocategory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1660-L1662" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nocategory(self):
    self._category = None
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageCategory.probability"><code class="name flex">
<span>def <span class="ident">probability</span></span>(<span>self, newprob=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Real valued probability for categorization, [0,1]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1684-L1691" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def probability(self, newprob=None):
    &#34;&#34;&#34;Real valued probability for categorization, [0,1]&#34;&#34;&#34;
    if newprob is None:
        return self.getattribute(&#39;probability&#39;)
    else:
        self.setattribute(&#39;probability&#39;, newprob)
        self.setattribute(&#39;RawDetectionProbability&#39;, newprob)
        return self</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageCategory.score"><code class="name flex">
<span>def <span class="ident">score</span></span>(<span>self, newscore=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Real valued score for categorization, larger is better</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1676-L1682" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def score(self, newscore=None):
    &#34;&#34;&#34;Real valued score for categorization, larger is better&#34;&#34;&#34;
    if newscore is None:
        return self.getattribute(&#39;score&#39;)
    else:
        self.setattribute(&#39;score&#39;, newscore)
        return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.image.Image.abspath" href="#vipy.image.Image.abspath">abspath</a></code></li>
<li><code><a title="vipy.image.Image.affine_transform" href="#vipy.image.Image.affine_transform">affine_transform</a></code></li>
<li><code><a title="vipy.image.Image.alpha" href="#vipy.image.Image.alpha">alpha</a></code></li>
<li><code><a title="vipy.image.Image.alphapad" href="#vipy.image.Image.alphapad">alphapad</a></code></li>
<li><code><a title="vipy.image.Image.annotate" href="#vipy.image.Image.annotate">annotate</a></code></li>
<li><code><a title="vipy.image.Image.area" href="#vipy.image.Image.area">area</a></code></li>
<li><code><a title="vipy.image.Image.array" href="#vipy.image.Image.array">array</a></code></li>
<li><code><a title="vipy.image.Image.ascii" href="#vipy.image.Image.ascii">ascii</a></code></li>
<li><code><a title="vipy.image.Image.aspectratio" href="#vipy.image.Image.aspectratio">aspectratio</a></code></li>
<li><code><a title="vipy.image.Image.base64" href="#vipy.image.Image.base64">base64</a></code></li>
<li><code><a title="vipy.image.Image.bgr" href="#vipy.image.Image.bgr">bgr</a></code></li>
<li><code><a title="vipy.image.Image.bgra" href="#vipy.image.Image.bgra">bgra</a></code></li>
<li><code><a title="vipy.image.Image.bias" href="#vipy.image.Image.bias">bias</a></code></li>
<li><code><a title="vipy.image.Image.blue" href="#vipy.image.Image.blue">blue</a></code></li>
<li><code><a title="vipy.image.Image.blur" href="#vipy.image.Image.blur">blur</a></code></li>
<li><code><a title="vipy.image.Image.bone" href="#vipy.image.Image.bone">bone</a></code></li>
<li><code><a title="vipy.image.Image.border_mask" href="#vipy.image.Image.border_mask">border_mask</a></code></li>
<li><code><a title="vipy.image.Image.canload" href="#vipy.image.Image.canload">canload</a></code></li>
<li><code><a title="vipy.image.Image.cast" href="#vipy.image.Image.cast">cast</a></code></li>
<li><code><a title="vipy.image.Image.centercrop" href="#vipy.image.Image.centercrop">centercrop</a></code></li>
<li><code><a title="vipy.image.Image.centerpixel" href="#vipy.image.Image.centerpixel">centerpixel</a></code></li>
<li><code><a title="vipy.image.Image.centersquare" href="#vipy.image.Image.centersquare">centersquare</a></code></li>
<li><code><a title="vipy.image.Image.centroid" href="#vipy.image.Image.centroid">centroid</a></code></li>
<li><code><a title="vipy.image.Image.channel" href="#vipy.image.Image.channel">channel</a></code></li>
<li><code><a title="vipy.image.Image.channels" href="#vipy.image.Image.channels">channels</a></code></li>
<li><code><a title="vipy.image.Image.clone" href="#vipy.image.Image.clone">clone</a></code></li>
<li><code><a title="vipy.image.Image.close" href="#vipy.image.Image.close">close</a></code></li>
<li><code><a title="vipy.image.Image.closeall" href="#vipy.image.Image.closeall">closeall</a></code></li>
<li><code><a title="vipy.image.Image.colorspace" href="#vipy.image.Image.colorspace">colorspace</a></code></li>
<li><code><a title="vipy.image.Image.cornercrop" href="#vipy.image.Image.cornercrop">cornercrop</a></code></li>
<li><code><a title="vipy.image.Image.dict" href="#vipy.image.Image.dict">dict</a></code></li>
<li><code><a title="vipy.image.Image.downcast" href="#vipy.image.Image.downcast">downcast</a></code></li>
<li><code><a title="vipy.image.Image.download" href="#vipy.image.Image.download">download</a></code></li>
<li><code><a title="vipy.image.Image.filename" href="#vipy.image.Image.filename">filename</a></code></li>
<li><code><a title="vipy.image.Image.filesize" href="#vipy.image.Image.filesize">filesize</a></code></li>
<li><code><a title="vipy.image.Image.fliplr" href="#vipy.image.Image.fliplr">fliplr</a></code></li>
<li><code><a title="vipy.image.Image.flipud" href="#vipy.image.Image.flipud">flipud</a></code></li>
<li><code><a title="vipy.image.Image.float" href="#vipy.image.Image.float">float</a></code></li>
<li><code><a title="vipy.image.Image.flush" href="#vipy.image.Image.flush">flush</a></code></li>
<li><code><a title="vipy.image.Image.from_json" href="#vipy.image.Image.from_json">from_json</a></code></li>
<li><code><a title="vipy.image.Image.fromarray" href="#vipy.image.Image.fromarray">fromarray</a></code></li>
<li><code><a title="vipy.image.Image.fromtorch" href="#vipy.image.Image.fromtorch">fromtorch</a></code></li>
<li><code><a title="vipy.image.Image.gain" href="#vipy.image.Image.gain">gain</a></code></li>
<li><code><a title="vipy.image.Image.getattribute" href="#vipy.image.Image.getattribute">getattribute</a></code></li>
<li><code><a title="vipy.image.Image.gray" href="#vipy.image.Image.gray">gray</a></code></li>
<li><code><a title="vipy.image.Image.grayscale" href="#vipy.image.Image.grayscale">grayscale</a></code></li>
<li><code><a title="vipy.image.Image.green" href="#vipy.image.Image.green">green</a></code></li>
<li><code><a title="vipy.image.Image.grey" href="#vipy.image.Image.grey">grey</a></code></li>
<li><code><a title="vipy.image.Image.greyscale" href="#vipy.image.Image.greyscale">greyscale</a></code></li>
<li><code><a title="vipy.image.Image.height" href="#vipy.image.Image.height">height</a></code></li>
<li><code><a title="vipy.image.Image.hot" href="#vipy.image.Image.hot">hot</a></code></li>
<li><code><a title="vipy.image.Image.hsv" href="#vipy.image.Image.hsv">hsv</a></code></li>
<li><code><a title="vipy.image.Image.html" href="#vipy.image.Image.html">html</a></code></li>
<li><code><a title="vipy.image.Image.imagebox" href="#vipy.image.Image.imagebox">imagebox</a></code></li>
<li><code><a title="vipy.image.Image.intensity" href="#vipy.image.Image.intensity">intensity</a></code></li>
<li><code><a title="vipy.image.Image.iscolor" href="#vipy.image.Image.iscolor">iscolor</a></code></li>
<li><code><a title="vipy.image.Image.isgrey" href="#vipy.image.Image.isgrey">isgrey</a></code></li>
<li><code><a title="vipy.image.Image.isloaded" href="#vipy.image.Image.isloaded">isloaded</a></code></li>
<li><code><a title="vipy.image.Image.isluminance" href="#vipy.image.Image.isluminance">isluminance</a></code></li>
<li><code><a title="vipy.image.Image.istransparent" href="#vipy.image.Image.istransparent">istransparent</a></code></li>
<li><code><a title="vipy.image.Image.jet" href="#vipy.image.Image.jet">jet</a></code></li>
<li><code><a title="vipy.image.Image.load" href="#vipy.image.Image.load">load</a></code></li>
<li><code><a title="vipy.image.Image.loader" href="#vipy.image.Image.loader">loader</a></code></li>
<li><code><a title="vipy.image.Image.lum" href="#vipy.image.Image.lum">lum</a></code></li>
<li><code><a title="vipy.image.Image.luminance" href="#vipy.image.Image.luminance">luminance</a></code></li>
<li><code><a title="vipy.image.Image.map" href="#vipy.image.Image.map">map</a></code></li>
<li><code><a title="vipy.image.Image.mat2gray" href="#vipy.image.Image.mat2gray">mat2gray</a></code></li>
<li><code><a title="vipy.image.Image.maxdim" href="#vipy.image.Image.maxdim">maxdim</a></code></li>
<li><code><a title="vipy.image.Image.maxmatte" href="#vipy.image.Image.maxmatte">maxmatte</a></code></li>
<li><code><a title="vipy.image.Image.maxsquare" href="#vipy.image.Image.maxsquare">maxsquare</a></code></li>
<li><code><a title="vipy.image.Image.mean" href="#vipy.image.Image.mean">mean</a></code></li>
<li><code><a title="vipy.image.Image.meanchannel" href="#vipy.image.Image.meanchannel">meanchannel</a></code></li>
<li><code><a title="vipy.image.Image.meanpad" href="#vipy.image.Image.meanpad">meanpad</a></code></li>
<li><code><a title="vipy.image.Image.mindim" href="#vipy.image.Image.mindim">mindim</a></code></li>
<li><code><a title="vipy.image.Image.minsquare" href="#vipy.image.Image.minsquare">minsquare</a></code></li>
<li><code><a title="vipy.image.Image.normalize" href="#vipy.image.Image.normalize">normalize</a></code></li>
<li><code><a title="vipy.image.Image.numpy" href="#vipy.image.Image.numpy">numpy</a></code></li>
<li><code><a title="vipy.image.Image.perceptualhash" href="#vipy.image.Image.perceptualhash">perceptualhash</a></code></li>
<li><code><a title="vipy.image.Image.perceptualhash_distance" href="#vipy.image.Image.perceptualhash_distance">perceptualhash_distance</a></code></li>
<li><code><a title="vipy.image.Image.pil" href="#vipy.image.Image.pil">pil</a></code></li>
<li><code><a title="vipy.image.Image.pkl" href="#vipy.image.Image.pkl">pkl</a></code></li>
<li><code><a title="vipy.image.Image.pklif" href="#vipy.image.Image.pklif">pklif</a></code></li>
<li><code><a title="vipy.image.Image.print" href="#vipy.image.Image.print">print</a></code></li>
<li><code><a title="vipy.image.Image.rainbow" href="#vipy.image.Image.rainbow">rainbow</a></code></li>
<li><code><a title="vipy.image.Image.red" href="#vipy.image.Image.red">red</a></code></li>
<li><code><a title="vipy.image.Image.reload" href="#vipy.image.Image.reload">reload</a></code></li>
<li><code><a title="vipy.image.Image.relpath" href="#vipy.image.Image.relpath">relpath</a></code></li>
<li><code><a title="vipy.image.Image.rescale" href="#vipy.image.Image.rescale">rescale</a></code></li>
<li><code><a title="vipy.image.Image.resize" href="#vipy.image.Image.resize">resize</a></code></li>
<li><code><a title="vipy.image.Image.resize_like" href="#vipy.image.Image.resize_like">resize_like</a></code></li>
<li><code><a title="vipy.image.Image.restore" href="#vipy.image.Image.restore">restore</a></code></li>
<li><code><a title="vipy.image.Image.rgb" href="#vipy.image.Image.rgb">rgb</a></code></li>
<li><code><a title="vipy.image.Image.rgba" href="#vipy.image.Image.rgba">rgba</a></code></li>
<li><code><a title="vipy.image.Image.rot90ccw" href="#vipy.image.Image.rot90ccw">rot90ccw</a></code></li>
<li><code><a title="vipy.image.Image.rot90cw" href="#vipy.image.Image.rot90cw">rot90cw</a></code></li>
<li><code><a title="vipy.image.Image.rotate" href="#vipy.image.Image.rotate">rotate</a></code></li>
<li><code><a title="vipy.image.Image.sanitize" href="#vipy.image.Image.sanitize">sanitize</a></code></li>
<li><code><a title="vipy.image.Image.saturate" href="#vipy.image.Image.saturate">saturate</a></code></li>
<li><code><a title="vipy.image.Image.save" href="#vipy.image.Image.save">save</a></code></li>
<li><code><a title="vipy.image.Image.saveas" href="#vipy.image.Image.saveas">saveas</a></code></li>
<li><code><a title="vipy.image.Image.saveastmp" href="#vipy.image.Image.saveastmp">saveastmp</a></code></li>
<li><code><a title="vipy.image.Image.savefig" href="#vipy.image.Image.savefig">savefig</a></code></li>
<li><code><a title="vipy.image.Image.savetmp" href="#vipy.image.Image.savetmp">savetmp</a></code></li>
<li><code><a title="vipy.image.Image.setattribute" href="#vipy.image.Image.setattribute">setattribute</a></code></li>
<li><code><a title="vipy.image.Image.setattributes" href="#vipy.image.Image.setattributes">setattributes</a></code></li>
<li><code><a title="vipy.image.Image.shape" href="#vipy.image.Image.shape">shape</a></code></li>
<li><code><a title="vipy.image.Image.show" href="#vipy.image.Image.show">show</a></code></li>
<li><code><a title="vipy.image.Image.splat" href="#vipy.image.Image.splat">splat</a></code></li>
<li><code><a title="vipy.image.Image.store" href="#vipy.image.Image.store">store</a></code></li>
<li><code><a title="vipy.image.Image.tile" href="#vipy.image.Image.tile">tile</a></code></li>
<li><code><a title="vipy.image.Image.tonumpy" href="#vipy.image.Image.tonumpy">tonumpy</a></code></li>
<li><code><a title="vipy.image.Image.torch" href="#vipy.image.Image.torch">torch</a></code></li>
<li><code><a title="vipy.image.Image.uncrop" href="#vipy.image.Image.uncrop">uncrop</a></code></li>
<li><code><a title="vipy.image.Image.union" href="#vipy.image.Image.union">union</a></code></li>
<li><code><a title="vipy.image.Image.unstore" href="#vipy.image.Image.unstore">unstore</a></code></li>
<li><code><a title="vipy.image.Image.untile" href="#vipy.image.Image.untile">untile</a></code></li>
<li><code><a title="vipy.image.Image.uri" href="#vipy.image.Image.uri">uri</a></code></li>
<li><code><a title="vipy.image.Image.url" href="#vipy.image.Image.url">url</a></code></li>
<li><code><a title="vipy.image.Image.width" href="#vipy.image.Image.width">width</a></code></li>
<li><code><a title="vipy.image.Image.zeropad" href="#vipy.image.Image.zeropad">zeropad</a></code></li>
<li><code><a title="vipy.image.Image.zeropadlike" href="#vipy.image.Image.zeropadlike">zeropadlike</a></code></li>
<li><code><a title="vipy.image.Image.zeros" href="#vipy.image.Image.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vipy.image.ImageDetection"><code class="flex name class">
<span>class <span class="ident">ImageDetection</span></span>
<span>(</span><span>filename=None, url=None, category=None, attributes=None, xmin=None, xmax=None, ymin=None, ymax=None, width=None, bbwidth=None, height=None, bbheight=None, bbox=None, array=None, colorspace=None, xcentroid=None, ycentroid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.image.ImageDetection class</p>
<p>This class provides a representation of a vipy.image.Image with a single object detection with a category and a vipy.geometry.BoundingBox</p>
<p>This class inherits all methods of Scene and BoundingBox.
Be careful with overloaded methods clone(), width() and height() which will
correspond to these methods for Scene() and not BoundingBox().
Use bbclone(), bbwidth() or bbheight() to access the subclass. </p>
<p>Valid constructors include all provided by vipy.image.Image with the additional kwarg 'category' (or alias 'label'), and BoundingBox coordinates</p>
<pre><code class="language-python">im = vipy.image.ImageDetection(filename='/path/to/dog_image.ext', category='dog', xmin=0, ymin=0, width=100, height=100)
im = vipy.image.ImageDetection(filename='/path/to/dog_image.ext', category='dog', xmin=0, ymin=0, xmax=100, ymax=100)
im = vipy.image.ImageDetection(filename='/path/to/dog_image.ext', category='dog', xcentroid=50, ycentroid=50, width=100, height=100)
im = vipy.image.ImageDetection(filename='/path/to/dog_image.ext', category='dog', bbox=vipy.geometry.BoundingBox(xmin=0, ymin=0, width=100, height=100))
im = vipy.image.ImageCategory(url='http://path/to/dog_image.ext', category='dog').boundingbox(xmin=0, ymin=0, width=100, height=100)
im = vipy.image.ImageCategory(array=dog_img, colorspace='rgb', category='dog',  xmin=0, ymin=0, width=100, height=100)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2200-L2366" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ImageDetection(Scene, BoundingBox):
    &#34;&#34;&#34;vipy.image.ImageDetection class

    This class provides a representation of a vipy.image.Image with a single object detection with a category and a vipy.geometry.BoundingBox

    This class inherits all methods of Scene and BoundingBox.  Be careful with overloaded methods clone(), width() and height() which will 
    correspond to these methods for Scene() and not BoundingBox().  Use bbclone(), bbwidth() or bbheight() to access the subclass. 

    Valid constructors include all provided by vipy.image.Image with the additional kwarg &#39;category&#39; (or alias &#39;label&#39;), and BoundingBox coordinates

    ```python
    im = vipy.image.ImageDetection(filename=&#39;/path/to/dog_image.ext&#39;, category=&#39;dog&#39;, xmin=0, ymin=0, width=100, height=100)
    im = vipy.image.ImageDetection(filename=&#39;/path/to/dog_image.ext&#39;, category=&#39;dog&#39;, xmin=0, ymin=0, xmax=100, ymax=100)
    im = vipy.image.ImageDetection(filename=&#39;/path/to/dog_image.ext&#39;, category=&#39;dog&#39;, xcentroid=50, ycentroid=50, width=100, height=100)
    im = vipy.image.ImageDetection(filename=&#39;/path/to/dog_image.ext&#39;, category=&#39;dog&#39;, bbox=vipy.geometry.BoundingBox(xmin=0, ymin=0, width=100, height=100))
    im = vipy.image.ImageCategory(url=&#39;http://path/to/dog_image.ext&#39;, category=&#39;dog&#39;).boundingbox(xmin=0, ymin=0, width=100, height=100)
    im = vipy.image.ImageCategory(array=dog_img, colorspace=&#39;rgb&#39;, category=&#39;dog&#39;,  xmin=0, ymin=0, width=100, height=100)
    ```

    &#34;&#34;&#34;
    
    def __init__(self, filename=None, url=None, category=None, attributes=None,
                 xmin=None, xmax=None, ymin=None, ymax=None,
                 width=None, bbwidth=None, height=None, bbheight=None,
                 bbox=None, array=None, colorspace=None,
                 xcentroid=None, ycentroid=None):

        # Construction options
        (width, height) = (bbwidth if bbwidth is not None else width, bbheight if bbheight is not None else height)  # alias
        if bbox is not None:
            assert isinstance(bbox, BoundingBox), &#34;Invalid bounding box&#34;
            bbox = vipy.object.Detection.cast(bbox)
            bbox.category(category)
        elif xmin is not None and ymin is not None and xmax is not None and ymax is not None:
            bbox = vipy.object.Detection(xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax, category=category)
        elif xmin is not None and ymin is not None and width is not None and height is not None:
            bbox = vipy.object.Detection(xmin=xmin, ymin=ymin, width=width, height=height, category=category)
        elif xcentroid is not None and ycentroid is not None and width is not None and height is not None:
            bbox = vipy.object.Detection(xcentroid=xcentroid, ycentroid=ycentroid, width=width, height=height, category=category)
        elif (xmin is None and xmax is None and ymin is None and ymax is None and
              width is None and bbwidth is None and height is None and bbheight is None and
              bbox is None and xcentroid is None and ycentroid is None):
            # Empty box to be updated with boundingbox() method
            bbox = vipy.object.Detection(xmin=0, ymin=0, width=0, height=0, category=category)
        else:
            raise ValueError(&#39;Incomplete constructor&#39;)

        # ImageCategory class inheritance
        super().__init__(filename=filename,
                         url=url,
                         category=category,
                         attributes=attributes,
                         objects=[bbox],
                         array=array,
                         colorspace=colorspace)

        self._asbbox = False
        
    def __getattribute__(self, item):
        if item == &#39;bbox&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;
            return self._objectlist[0]
        elif item == &#39;_xmin&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;            
            return self._objectlist[0]._xmin
        elif item == &#39;_ymin&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;            
            return self._objectlist[0]._ymin
        elif item == &#39;_xmax&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;            
            return self._objectlist[0]._xmax
        elif item == &#39;_ymax&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;            
            return self._objectlist[0]._ymax        
        else:
            return super().__getattribute__(item)            

    def __getattr__(self, item):
        if item == &#39;bbox&#39;:
            assert len(self._objectlist) == 1, &#34;Invalid ImageDetection&#34;
            return self._objectlist[0]
        else:
            return super().__getattribute__(item)
    
    @classmethod
    def cast(cls, im, flush=True):
        imc = super().cast(im, flush=flush)
    
    def __repr__(self):
        strlist = []
        if self.isloaded():
            strlist.append(&#34;height=%d, width=%d, color=%s&#34; % (self.height(), self.width(), self.colorspace()))
        if self.filename() is not None:
            strlist.append(&#39;filename=&#34;%s&#34;&#39; % (self.filename() if self.hasfilename() else &#39;&lt;NOTFOUND&gt;%s&lt;/NOTFOUND&gt;&#39; % self.filename()))
        if self.hasurl():
            strlist.append(&#39;url=&#34;%s&#34;&#39; % self.url())
        if self.category() is not None:
            strlist.append(&#39;category=&#34;%s&#34;&#39; % self.category())
        if self.bbox.isvalid():
            strlist.append(&#39;bbox=(xmin=%1.1f, ymin=%1.1f, width=%1.1f, height=%1.1f)&#39; %
                           (self.bbox.xmin(), self.bbox.ymin(),self.bbox.width(), self.bbox.height()))
        return str(&#39;&lt;vipy.image.imagedetection: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    
    def __eq__(self, other):
        &#34;&#34;&#34;ImageDetection equality is defined as equivalent categories and boxes (not pixels)&#34;&#34;&#34;
        return self._category.lower() == other._category.lower() and self.bbox == other.bbox if isinstance(other, ImageDetection) else False

    def boundingbox(self, xmin=None, xmax=None, ymin=None, ymax=None,
                    bbox=None, width=None, height=None, dilate=None,
                    xcentroid=None, ycentroid=None):
        &#34;&#34;&#34;Modify the bounding box using the provided parameters, or return the box if no parameters provided&#34;&#34;&#34;
        if (xmin is None and xmax is None and ymin is None and ymax is None
            and bbox is None and width is None and height is None
                and dilate is None and xcentroid is None and ycentroid is None):
            return self.bbox
        elif (xmin is not None and xmax is not None
              and ymin is not None and ymax is not None):
            self.bbox.ulbr((xmin, ymin, xmax, ymax))
        elif bbox is not None:
            assert isinstance(bbox, BoundingBox)
            self.bbox.ulbr(bbox.ulbr())
        elif (xmin is not None and ymin is not None
              and width is not None and height is not None):
            self.bbox.xywh((xmin, ymin, width, height))
        elif (xcentroid is not None and ycentroid is not None
              and width is not None and height is not None):
            self.bbox.cxywh((xcentroid, ycentroid, width, height))
        elif (dilate is None):
            raise ValueError(&#39;Invalid bounding box&#39;)

        if dilate is not None:
            self.bbox.dilate(dilate)

        return self

    def asimage(self):
        self._asbbox = False
        return self

    def asbbox(self):
        self._asbbox = True
        return self

    def boxmap(self, f):
        &#34;&#34;&#34;Apply the lambda function f to the bounding box, and return the imagedetection&#34;&#34;&#34;
        assert callable(f)
        bb = f(self.bbox)
        assert isinstance(bb, BoundingBox), &#34;Lambda function must return BoundingBox()&#34;
        return self
    
    def crop(self, bbox=None):
        &#34;&#34;&#34;Crop the image using the bounding box&#34;&#34;&#34;
        return super().crop(self.boundingbox() if bbox is None else bbox)
    
    def append(self, im):
        raise ValueError(&#39;Unsupported for vipy.image.ImageDetection - use vipy.image.Scene instead&#39;)

    def detection(self):
        return self.boundingbox()

    def isinterior(self, W=None, H=None):
        &#34;&#34;&#34;Is the bounding box fully within the image rectangle?  Use provided image width and height (W,H) to avoid lots of reloads in some conditions&#34;&#34;&#34;
        (W, H) = (W if W is not None else self.width(),
                  H if H is not None else self.height())
        return (self.bbox.xmin() &gt;= 0 and self.bbox.ymin() &gt;= 0
                and self.bbox.xmax() &lt;= W and self.bbox.ymax() &lt;= H)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vipy.image.Scene" href="#vipy.image.Scene">Scene</a></li>
<li><a title="vipy.image.ImageCategory" href="#vipy.image.ImageCategory">ImageCategory</a></li>
<li><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></li>
<li><a title="vipy.geometry.BoundingBox" href="geometry.html#vipy.geometry.BoundingBox">BoundingBox</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="vipy.image.ImageDetection.asbbox"><code class="name flex">
<span>def <span class="ident">asbbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2340-L2342" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def asbbox(self):
    self._asbbox = True
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageDetection.asimage"><code class="name flex">
<span>def <span class="ident">asimage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2336-L2338" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def asimage(self):
    self._asbbox = False
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageDetection.boundingbox"><code class="name flex">
<span>def <span class="ident">boundingbox</span></span>(<span>self, xmin=None, xmax=None, ymin=None, ymax=None, bbox=None, width=None, height=None, dilate=None, xcentroid=None, ycentroid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Modify the bounding box using the provided parameters, or return the box if no parameters provided</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2308-L2334" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boundingbox(self, xmin=None, xmax=None, ymin=None, ymax=None,
                bbox=None, width=None, height=None, dilate=None,
                xcentroid=None, ycentroid=None):
    &#34;&#34;&#34;Modify the bounding box using the provided parameters, or return the box if no parameters provided&#34;&#34;&#34;
    if (xmin is None and xmax is None and ymin is None and ymax is None
        and bbox is None and width is None and height is None
            and dilate is None and xcentroid is None and ycentroid is None):
        return self.bbox
    elif (xmin is not None and xmax is not None
          and ymin is not None and ymax is not None):
        self.bbox.ulbr((xmin, ymin, xmax, ymax))
    elif bbox is not None:
        assert isinstance(bbox, BoundingBox)
        self.bbox.ulbr(bbox.ulbr())
    elif (xmin is not None and ymin is not None
          and width is not None and height is not None):
        self.bbox.xywh((xmin, ymin, width, height))
    elif (xcentroid is not None and ycentroid is not None
          and width is not None and height is not None):
        self.bbox.cxywh((xcentroid, ycentroid, width, height))
    elif (dilate is None):
        raise ValueError(&#39;Invalid bounding box&#39;)

    if dilate is not None:
        self.bbox.dilate(dilate)

    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageDetection.boxmap"><code class="name flex">
<span>def <span class="ident">boxmap</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the lambda function f to the bounding box, and return the imagedetection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2344-L2349" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boxmap(self, f):
    &#34;&#34;&#34;Apply the lambda function f to the bounding box, and return the imagedetection&#34;&#34;&#34;
    assert callable(f)
    bb = f(self.bbox)
    assert isinstance(bb, BoundingBox), &#34;Lambda function must return BoundingBox()&#34;
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageDetection.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>self, bbox=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop the image using the bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2351-L2353" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def crop(self, bbox=None):
    &#34;&#34;&#34;Crop the image using the bounding box&#34;&#34;&#34;
    return super().crop(self.boundingbox() if bbox is None else bbox)</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageDetection.detection"><code class="name flex">
<span>def <span class="ident">detection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2358-L2359" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detection(self):
    return self.boundingbox()</code></pre>
</details>
</dd>
<dt id="vipy.image.ImageDetection.isinterior"><code class="name flex">
<span>def <span class="ident">isinterior</span></span>(<span>self, W=None, H=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the bounding box fully within the image rectangle?
Use provided image width and height (W,H) to avoid lots of reloads in some conditions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2361-L2366" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isinterior(self, W=None, H=None):
    &#34;&#34;&#34;Is the bounding box fully within the image rectangle?  Use provided image width and height (W,H) to avoid lots of reloads in some conditions&#34;&#34;&#34;
    (W, H) = (W if W is not None else self.width(),
              H if H is not None else self.height())
    return (self.bbox.xmin() &gt;= 0 and self.bbox.ymin() &gt;= 0
            and self.bbox.xmax() &lt;= W and self.bbox.ymax() &lt;= H)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vipy.image.Scene" href="#vipy.image.Scene">Scene</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.image.Scene.abspath" href="#vipy.image.Image.abspath">abspath</a></code></li>
<li><code><a title="vipy.image.Scene.add" href="#vipy.image.Scene.add">add</a></code></li>
<li><code><a title="vipy.image.Scene.affine_transform" href="#vipy.image.Image.affine_transform">affine_transform</a></code></li>
<li><code><a title="vipy.image.Scene.alpha" href="#vipy.image.Image.alpha">alpha</a></code></li>
<li><code><a title="vipy.image.Scene.alphapad" href="#vipy.image.Image.alphapad">alphapad</a></code></li>
<li><code><a title="vipy.image.Scene.annotate" href="#vipy.image.Scene.annotate">annotate</a></code></li>
<li><code><a title="vipy.image.Scene.append" href="#vipy.image.Scene.append">append</a></code></li>
<li><code><a title="vipy.image.Scene.area" href="#vipy.image.Image.area">area</a></code></li>
<li><code><a title="vipy.image.Scene.array" href="#vipy.image.Image.array">array</a></code></li>
<li><code><a title="vipy.image.Scene.ascii" href="#vipy.image.Image.ascii">ascii</a></code></li>
<li><code><a title="vipy.image.Scene.aspectratio" href="#vipy.image.Image.aspectratio">aspectratio</a></code></li>
<li><code><a title="vipy.image.Scene.base64" href="#vipy.image.Image.base64">base64</a></code></li>
<li><code><a title="vipy.image.Scene.bghash" href="#vipy.image.Scene.bghash">bghash</a></code></li>
<li><code><a title="vipy.image.Scene.bgmask" href="#vipy.image.Scene.bgmask">bgmask</a></code></li>
<li><code><a title="vipy.image.Scene.bgr" href="#vipy.image.Image.bgr">bgr</a></code></li>
<li><code><a title="vipy.image.Scene.bgra" href="#vipy.image.Image.bgra">bgra</a></code></li>
<li><code><a title="vipy.image.Scene.bias" href="#vipy.image.Image.bias">bias</a></code></li>
<li><code><a title="vipy.image.Scene.binarymask" href="#vipy.image.Scene.binarymask">binarymask</a></code></li>
<li><code><a title="vipy.image.Scene.blue" href="#vipy.image.Image.blue">blue</a></code></li>
<li><code><a title="vipy.image.Scene.blur" href="#vipy.image.Image.blur">blur</a></code></li>
<li><code><a title="vipy.image.Scene.blurmask" href="#vipy.image.Scene.blurmask">blurmask</a></code></li>
<li><code><a title="vipy.image.Scene.bone" href="#vipy.image.Image.bone">bone</a></code></li>
<li><code><a title="vipy.image.Scene.border_mask" href="#vipy.image.Image.border_mask">border_mask</a></code></li>
<li><code><a title="vipy.image.Scene.canload" href="#vipy.image.Image.canload">canload</a></code></li>
<li><code><a title="vipy.image.Scene.cast" href="#vipy.image.Image.cast">cast</a></code></li>
<li><code><a title="vipy.image.Scene.categories" href="#vipy.image.Scene.categories">categories</a></code></li>
<li><code><a title="vipy.image.Scene.category" href="#vipy.image.ImageCategory.category">category</a></code></li>
<li><code><a title="vipy.image.Scene.centercrop" href="#vipy.image.Image.centercrop">centercrop</a></code></li>
<li><code><a title="vipy.image.Scene.centerpixel" href="#vipy.image.Image.centerpixel">centerpixel</a></code></li>
<li><code><a title="vipy.image.Scene.centersquare" href="#vipy.image.Scene.centersquare">centersquare</a></code></li>
<li><code><a title="vipy.image.Scene.centroid" href="#vipy.image.Image.centroid">centroid</a></code></li>
<li><code><a title="vipy.image.Scene.channel" href="#vipy.image.Image.channel">channel</a></code></li>
<li><code><a title="vipy.image.Scene.channels" href="#vipy.image.Image.channels">channels</a></code></li>
<li><code><a title="vipy.image.Scene.clear" href="#vipy.image.Scene.clear">clear</a></code></li>
<li><code><a title="vipy.image.Scene.clone" href="#vipy.image.Image.clone">clone</a></code></li>
<li><code><a title="vipy.image.Scene.close" href="#vipy.image.Image.close">close</a></code></li>
<li><code><a title="vipy.image.Scene.closeall" href="#vipy.image.Image.closeall">closeall</a></code></li>
<li><code><a title="vipy.image.Scene.colorspace" href="#vipy.image.Image.colorspace">colorspace</a></code></li>
<li><code><a title="vipy.image.Scene.cornercrop" href="#vipy.image.Scene.cornercrop">cornercrop</a></code></li>
<li><code><a title="vipy.image.Scene.cornerpadcrop" href="#vipy.image.Scene.cornerpadcrop">cornerpadcrop</a></code></li>
<li><code><a title="vipy.image.Scene.dict" href="#vipy.image.Image.dict">dict</a></code></li>
<li><code><a title="vipy.image.Scene.difference" href="#vipy.image.Scene.difference">difference</a></code></li>
<li><code><a title="vipy.image.Scene.dilate" href="#vipy.image.Scene.dilate">dilate</a></code></li>
<li><code><a title="vipy.image.Scene.downcast" href="#vipy.image.Image.downcast">downcast</a></code></li>
<li><code><a title="vipy.image.Scene.download" href="#vipy.image.Image.download">download</a></code></li>
<li><code><a title="vipy.image.Scene.fghash" href="#vipy.image.Scene.fghash">fghash</a></code></li>
<li><code><a title="vipy.image.Scene.fgmask" href="#vipy.image.Scene.fgmask">fgmask</a></code></li>
<li><code><a title="vipy.image.Scene.filename" href="#vipy.image.Image.filename">filename</a></code></li>
<li><code><a title="vipy.image.Scene.filesize" href="#vipy.image.Image.filesize">filesize</a></code></li>
<li><code><a title="vipy.image.Scene.fliplr" href="#vipy.image.Scene.fliplr">fliplr</a></code></li>
<li><code><a title="vipy.image.Scene.flipud" href="#vipy.image.Scene.flipud">flipud</a></code></li>
<li><code><a title="vipy.image.Scene.float" href="#vipy.image.Image.float">float</a></code></li>
<li><code><a title="vipy.image.Scene.flush" href="#vipy.image.Image.flush">flush</a></code></li>
<li><code><a title="vipy.image.Scene.from_json" href="#vipy.image.Image.from_json">from_json</a></code></li>
<li><code><a title="vipy.image.Scene.fromarray" href="#vipy.image.Image.fromarray">fromarray</a></code></li>
<li><code><a title="vipy.image.Scene.fromtorch" href="#vipy.image.Image.fromtorch">fromtorch</a></code></li>
<li><code><a title="vipy.image.Scene.gain" href="#vipy.image.Image.gain">gain</a></code></li>
<li><code><a title="vipy.image.Scene.getattribute" href="#vipy.image.Image.getattribute">getattribute</a></code></li>
<li><code><a title="vipy.image.Scene.gray" href="#vipy.image.Image.gray">gray</a></code></li>
<li><code><a title="vipy.image.Scene.grayscale" href="#vipy.image.Image.grayscale">grayscale</a></code></li>
<li><code><a title="vipy.image.Scene.green" href="#vipy.image.Image.green">green</a></code></li>
<li><code><a title="vipy.image.Scene.grey" href="#vipy.image.Image.grey">grey</a></code></li>
<li><code><a title="vipy.image.Scene.greyscale" href="#vipy.image.Image.greyscale">greyscale</a></code></li>
<li><code><a title="vipy.image.Scene.height" href="#vipy.image.Image.height">height</a></code></li>
<li><code><a title="vipy.image.Scene.hot" href="#vipy.image.Image.hot">hot</a></code></li>
<li><code><a title="vipy.image.Scene.hsv" href="#vipy.image.Image.hsv">hsv</a></code></li>
<li><code><a title="vipy.image.Scene.html" href="#vipy.image.Image.html">html</a></code></li>
<li><code><a title="vipy.image.Scene.imagebox" href="#vipy.image.Image.imagebox">imagebox</a></code></li>
<li><code><a title="vipy.image.Scene.imclip" href="#vipy.image.Scene.imclip">imclip</a></code></li>
<li><code><a title="vipy.image.Scene.intensity" href="#vipy.image.Image.intensity">intensity</a></code></li>
<li><code><a title="vipy.image.Scene.intersection" href="#vipy.image.Scene.intersection">intersection</a></code></li>
<li><code><a title="vipy.image.Scene.iscolor" href="#vipy.image.Image.iscolor">iscolor</a></code></li>
<li><code><a title="vipy.image.Scene.isduplicate" href="#vipy.image.Scene.isduplicate">isduplicate</a></code></li>
<li><code><a title="vipy.image.Scene.isgrey" href="#vipy.image.Image.isgrey">isgrey</a></code></li>
<li><code><a title="vipy.image.Scene.isloaded" href="#vipy.image.Image.isloaded">isloaded</a></code></li>
<li><code><a title="vipy.image.Scene.isluminance" href="#vipy.image.Image.isluminance">isluminance</a></code></li>
<li><code><a title="vipy.image.Scene.istransparent" href="#vipy.image.Image.istransparent">istransparent</a></code></li>
<li><code><a title="vipy.image.Scene.jet" href="#vipy.image.Image.jet">jet</a></code></li>
<li><code><a title="vipy.image.Scene.label" href="#vipy.image.ImageCategory.label">label</a></code></li>
<li><code><a title="vipy.image.Scene.load" href="#vipy.image.Image.load">load</a></code></li>
<li><code><a title="vipy.image.Scene.loader" href="#vipy.image.Image.loader">loader</a></code></li>
<li><code><a title="vipy.image.Scene.lum" href="#vipy.image.Image.lum">lum</a></code></li>
<li><code><a title="vipy.image.Scene.luminance" href="#vipy.image.Image.luminance">luminance</a></code></li>
<li><code><a title="vipy.image.Scene.map" href="#vipy.image.Image.map">map</a></code></li>
<li><code><a title="vipy.image.Scene.mat2gray" href="#vipy.image.Image.mat2gray">mat2gray</a></code></li>
<li><code><a title="vipy.image.Scene.maxdim" href="#vipy.image.Scene.maxdim">maxdim</a></code></li>
<li><code><a title="vipy.image.Scene.maxmatte" href="#vipy.image.Image.maxmatte">maxmatte</a></code></li>
<li><code><a title="vipy.image.Scene.maxsquare" href="#vipy.image.Image.maxsquare">maxsquare</a></code></li>
<li><code><a title="vipy.image.Scene.mean" href="#vipy.image.Image.mean">mean</a></code></li>
<li><code><a title="vipy.image.Scene.meanchannel" href="#vipy.image.Image.meanchannel">meanchannel</a></code></li>
<li><code><a title="vipy.image.Scene.meanmask" href="#vipy.image.Scene.meanmask">meanmask</a></code></li>
<li><code><a title="vipy.image.Scene.meanpad" href="#vipy.image.Scene.meanpad">meanpad</a></code></li>
<li><code><a title="vipy.image.Scene.mindim" href="#vipy.image.Scene.mindim">mindim</a></code></li>
<li><code><a title="vipy.image.Scene.minsquare" href="#vipy.image.Image.minsquare">minsquare</a></code></li>
<li><code><a title="vipy.image.Scene.nms" href="#vipy.image.Scene.nms">nms</a></code></li>
<li><code><a title="vipy.image.Scene.normalize" href="#vipy.image.Image.normalize">normalize</a></code></li>
<li><code><a title="vipy.image.Scene.numpy" href="#vipy.image.Image.numpy">numpy</a></code></li>
<li><code><a title="vipy.image.Scene.objectcrop" href="#vipy.image.Scene.objectcrop">objectcrop</a></code></li>
<li><code><a title="vipy.image.Scene.objectfilter" href="#vipy.image.Scene.objectfilter">objectfilter</a></code></li>
<li><code><a title="vipy.image.Scene.objectmap" href="#vipy.image.Scene.objectmap">objectmap</a></code></li>
<li><code><a title="vipy.image.Scene.padcrop" href="#vipy.image.Scene.padcrop">padcrop</a></code></li>
<li><code><a title="vipy.image.Scene.perceptualhash" href="#vipy.image.Scene.perceptualhash">perceptualhash</a></code></li>
<li><code><a title="vipy.image.Scene.perceptualhash_distance" href="#vipy.image.Image.perceptualhash_distance">perceptualhash_distance</a></code></li>
<li><code><a title="vipy.image.Scene.pil" href="#vipy.image.Image.pil">pil</a></code></li>
<li><code><a title="vipy.image.Scene.pixelate" href="#vipy.image.Scene.pixelate">pixelate</a></code></li>
<li><code><a title="vipy.image.Scene.pixelize" href="#vipy.image.Scene.pixelize">pixelize</a></code></li>
<li><code><a title="vipy.image.Scene.pixelmask" href="#vipy.image.Scene.pixelmask">pixelmask</a></code></li>
<li><code><a title="vipy.image.Scene.pkl" href="#vipy.image.Image.pkl">pkl</a></code></li>
<li><code><a title="vipy.image.Scene.pklif" href="#vipy.image.Image.pklif">pklif</a></code></li>
<li><code><a title="vipy.image.Scene.print" href="#vipy.image.Image.print">print</a></code></li>
<li><code><a title="vipy.image.Scene.probability" href="#vipy.image.ImageCategory.probability">probability</a></code></li>
<li><code><a title="vipy.image.Scene.rainbow" href="#vipy.image.Image.rainbow">rainbow</a></code></li>
<li><code><a title="vipy.image.Scene.rectangular_mask" href="#vipy.image.Scene.rectangular_mask">rectangular_mask</a></code></li>
<li><code><a title="vipy.image.Scene.red" href="#vipy.image.Image.red">red</a></code></li>
<li><code><a title="vipy.image.Scene.reload" href="#vipy.image.Image.reload">reload</a></code></li>
<li><code><a title="vipy.image.Scene.relpath" href="#vipy.image.Image.relpath">relpath</a></code></li>
<li><code><a title="vipy.image.Scene.replace" href="#vipy.image.Scene.replace">replace</a></code></li>
<li><code><a title="vipy.image.Scene.rescale" href="#vipy.image.Scene.rescale">rescale</a></code></li>
<li><code><a title="vipy.image.Scene.resize" href="#vipy.image.Scene.resize">resize</a></code></li>
<li><code><a title="vipy.image.Scene.resize_like" href="#vipy.image.Image.resize_like">resize_like</a></code></li>
<li><code><a title="vipy.image.Scene.restore" href="#vipy.image.Image.restore">restore</a></code></li>
<li><code><a title="vipy.image.Scene.rgb" href="#vipy.image.Image.rgb">rgb</a></code></li>
<li><code><a title="vipy.image.Scene.rgba" href="#vipy.image.Image.rgba">rgba</a></code></li>
<li><code><a title="vipy.image.Scene.rot90ccw" href="#vipy.image.Scene.rot90ccw">rot90ccw</a></code></li>
<li><code><a title="vipy.image.Scene.rot90cw" href="#vipy.image.Scene.rot90cw">rot90cw</a></code></li>
<li><code><a title="vipy.image.Scene.rotate" href="#vipy.image.Image.rotate">rotate</a></code></li>
<li><code><a title="vipy.image.Scene.sanitize" href="#vipy.image.Image.sanitize">sanitize</a></code></li>
<li><code><a title="vipy.image.Scene.saturate" href="#vipy.image.Image.saturate">saturate</a></code></li>
<li><code><a title="vipy.image.Scene.save" href="#vipy.image.Image.save">save</a></code></li>
<li><code><a title="vipy.image.Scene.saveas" href="#vipy.image.Image.saveas">saveas</a></code></li>
<li><code><a title="vipy.image.Scene.saveastmp" href="#vipy.image.Image.saveastmp">saveastmp</a></code></li>
<li><code><a title="vipy.image.Scene.savefig" href="#vipy.image.Scene.savefig">savefig</a></code></li>
<li><code><a title="vipy.image.Scene.savetmp" href="#vipy.image.Image.savetmp">savetmp</a></code></li>
<li><code><a title="vipy.image.Scene.score" href="#vipy.image.ImageCategory.score">score</a></code></li>
<li><code><a title="vipy.image.Scene.setattribute" href="#vipy.image.Image.setattribute">setattribute</a></code></li>
<li><code><a title="vipy.image.Scene.setattributes" href="#vipy.image.Image.setattributes">setattributes</a></code></li>
<li><code><a title="vipy.image.Scene.shape" href="#vipy.image.Image.shape">shape</a></code></li>
<li><code><a title="vipy.image.Scene.show" href="#vipy.image.Scene.show">show</a></code></li>
<li><code><a title="vipy.image.Scene.splat" href="#vipy.image.Image.splat">splat</a></code></li>
<li><code><a title="vipy.image.Scene.store" href="#vipy.image.Image.store">store</a></code></li>
<li><code><a title="vipy.image.Scene.tile" href="#vipy.image.Image.tile">tile</a></code></li>
<li><code><a title="vipy.image.Scene.tonumpy" href="#vipy.image.Image.tonumpy">tonumpy</a></code></li>
<li><code><a title="vipy.image.Scene.torch" href="#vipy.image.Image.torch">torch</a></code></li>
<li><code><a title="vipy.image.Scene.uncrop" href="#vipy.image.Scene.uncrop">uncrop</a></code></li>
<li><code><a title="vipy.image.Scene.union" href="#vipy.image.Scene.union">union</a></code></li>
<li><code><a title="vipy.image.Scene.unstore" href="#vipy.image.Image.unstore">unstore</a></code></li>
<li><code><a title="vipy.image.Scene.untile" href="#vipy.image.Image.untile">untile</a></code></li>
<li><code><a title="vipy.image.Scene.uri" href="#vipy.image.Image.uri">uri</a></code></li>
<li><code><a title="vipy.image.Scene.url" href="#vipy.image.Image.url">url</a></code></li>
<li><code><a title="vipy.image.Scene.width" href="#vipy.image.Image.width">width</a></code></li>
<li><code><a title="vipy.image.Scene.zeropad" href="#vipy.image.Scene.zeropad">zeropad</a></code></li>
<li><code><a title="vipy.image.Scene.zeropadlike" href="#vipy.image.Image.zeropadlike">zeropadlike</a></code></li>
<li><code><a title="vipy.image.Scene.zeros" href="#vipy.image.Image.zeros">zeros</a></code></li>
</ul>
</li>
<li><code><b><a title="vipy.geometry.BoundingBox" href="geometry.html#vipy.geometry.BoundingBox">BoundingBox</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.geometry.BoundingBox.affine" href="geometry.html#vipy.geometry.BoundingBox.affine">affine</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.area_of_intersection" href="geometry.html#vipy.geometry.BoundingBox.area_of_intersection">area_of_intersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.average" href="geometry.html#vipy.geometry.BoundingBox.average">average</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.averageshape" href="geometry.html#vipy.geometry.BoundingBox.averageshape">averageshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bl" href="geometry.html#vipy.geometry.BoundingBox.bl">bl</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.blx" href="geometry.html#vipy.geometry.BoundingBox.blx">blx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bly" href="geometry.html#vipy.geometry.BoundingBox.bly">bly</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottom" href="geometry.html#vipy.geometry.BoundingBox.bottom">bottom</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottomleft" href="geometry.html#vipy.geometry.BoundingBox.bottomleft">bottomleft</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottomright" href="geometry.html#vipy.geometry.BoundingBox.bottomright">bottomright</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.br" href="geometry.html#vipy.geometry.BoundingBox.br">br</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.brx" href="geometry.html#vipy.geometry.BoundingBox.brx">brx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bry" href="geometry.html#vipy.geometry.BoundingBox.bry">bry</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid_x" href="geometry.html#vipy.geometry.BoundingBox.centroid_x">centroid_x</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid_y" href="geometry.html#vipy.geometry.BoundingBox.centroid_y">centroid_y</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.confidence" href="geometry.html#vipy.geometry.BoundingBox.confidence">confidence</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.convexhull" href="geometry.html#vipy.geometry.BoundingBox.convexhull">convexhull</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.cover" href="geometry.html#vipy.geometry.BoundingBox.cover">cover</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.cxywh" href="geometry.html#vipy.geometry.BoundingBox.cxywh">cxywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate_height" href="geometry.html#vipy.geometry.BoundingBox.dilate_height">dilate_height</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate_width" href="geometry.html#vipy.geometry.BoundingBox.dilate_width">dilate_width</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilatepx" href="geometry.html#vipy.geometry.BoundingBox.dilatepx">dilatepx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dist" href="geometry.html#vipy.geometry.BoundingBox.dist">dist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dx" href="geometry.html#vipy.geometry.BoundingBox.dx">dx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dy" href="geometry.html#vipy.geometry.BoundingBox.dy">dy</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ellipse" href="geometry.html#vipy.geometry.BoundingBox.ellipse">ellipse</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.even" href="geometry.html#vipy.geometry.BoundingBox.even">even</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.grid" href="geometry.html#vipy.geometry.BoundingBox.grid">grid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.hasintersection" href="geometry.html#vipy.geometry.BoundingBox.hasintersection">hasintersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.hasoverlap" href="geometry.html#vipy.geometry.BoundingBox.hasoverlap">hasoverlap</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imclipshape" href="geometry.html#vipy.geometry.BoundingBox.imclipshape">imclipshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iminterior" href="geometry.html#vipy.geometry.BoundingBox.iminterior">iminterior</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imscale" href="geometry.html#vipy.geometry.BoundingBox.imscale">imscale</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.int" href="geometry.html#vipy.geometry.BoundingBox.int">int</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.intersection_over_union" href="geometry.html#vipy.geometry.BoundingBox.intersection_over_union">intersection_over_union</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.invalid" href="geometry.html#vipy.geometry.BoundingBox.invalid">invalid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iou" href="geometry.html#vipy.geometry.BoundingBox.iou">iou</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iseven" href="geometry.html#vipy.geometry.BoundingBox.iseven">iseven</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isinside" href="geometry.html#vipy.geometry.BoundingBox.isinside">isinside</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ispointinside" href="geometry.html#vipy.geometry.BoundingBox.ispointinside">ispointinside</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.left" href="geometry.html#vipy.geometry.BoundingBox.left">left</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ll" href="geometry.html#vipy.geometry.BoundingBox.ll">ll</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.lr" href="geometry.html#vipy.geometry.BoundingBox.lr">lr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxcover" href="geometry.html#vipy.geometry.BoundingBox.maxcover">maxcover</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.medianshape" href="geometry.html#vipy.geometry.BoundingBox.medianshape">medianshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.mindimension" href="geometry.html#vipy.geometry.BoundingBox.mindimension">mindimension</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.offset" href="geometry.html#vipy.geometry.BoundingBox.offset">offset</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.pdist" href="geometry.html#vipy.geometry.BoundingBox.pdist">pdist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.projective" href="geometry.html#vipy.geometry.BoundingBox.projective">projective</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.right" href="geometry.html#vipy.geometry.BoundingBox.right">right</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.scalex" href="geometry.html#vipy.geometry.BoundingBox.scalex">scalex</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.scaley" href="geometry.html#vipy.geometry.BoundingBox.scaley">scaley</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.set_origin" href="geometry.html#vipy.geometry.BoundingBox.set_origin">set_origin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.setheight" href="geometry.html#vipy.geometry.BoundingBox.setheight">setheight</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.setwidth" href="geometry.html#vipy.geometry.BoundingBox.setwidth">setwidth</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shapedist" href="geometry.html#vipy.geometry.BoundingBox.shapedist">shapedist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shapeiou" href="geometry.html#vipy.geometry.BoundingBox.shapeiou">shapeiou</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.significant_digits" href="geometry.html#vipy.geometry.BoundingBox.significant_digits">significant_digits</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.sqdist" href="geometry.html#vipy.geometry.BoundingBox.sqdist">sqdist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_origin" href="geometry.html#vipy.geometry.BoundingBox.to_origin">to_origin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_ulbr" href="geometry.html#vipy.geometry.BoundingBox.to_ulbr">to_ulbr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_xywh" href="geometry.html#vipy.geometry.BoundingBox.to_xywh">to_xywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.top" href="geometry.html#vipy.geometry.BoundingBox.top">top</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.translate" href="geometry.html#vipy.geometry.BoundingBox.translate">translate</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ul" href="geometry.html#vipy.geometry.BoundingBox.ul">ul</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ulbr" href="geometry.html#vipy.geometry.BoundingBox.ulbr">ulbr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ulx" href="geometry.html#vipy.geometry.BoundingBox.ulx">ulx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.uly" href="geometry.html#vipy.geometry.BoundingBox.uly">uly</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.upperleft" href="geometry.html#vipy.geometry.BoundingBox.upperleft">upperleft</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.upperright" href="geometry.html#vipy.geometry.BoundingBox.upperright">upperright</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ur" href="geometry.html#vipy.geometry.BoundingBox.ur">ur</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.urx" href="geometry.html#vipy.geometry.BoundingBox.urx">urx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ury" href="geometry.html#vipy.geometry.BoundingBox.ury">ury</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xcentroid" href="geometry.html#vipy.geometry.BoundingBox.xcentroid">xcentroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xmax" href="geometry.html#vipy.geometry.BoundingBox.xmax">xmax</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xmin" href="geometry.html#vipy.geometry.BoundingBox.xmin">xmin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xywh" href="geometry.html#vipy.geometry.BoundingBox.xywh">xywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ycentroid" href="geometry.html#vipy.geometry.BoundingBox.ycentroid">ycentroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ymax" href="geometry.html#vipy.geometry.BoundingBox.ymax">ymax</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ymin" href="geometry.html#vipy.geometry.BoundingBox.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vipy.image.Scene"><code class="flex name class">
<span>class <span class="ident">Scene</span></span>
<span>(</span><span>filename=None, url=None, category=None, attributes=None, objects=None, xywh=None, boxlabels=None, array=None, colorspace=None)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.image.Scene class</p>
<p>This class provides a representation of a vipy.image.ImageCategory with one or more vipy.object.Detections.
The goal of this class is to provide a unified representation for all objects in a scene.</p>
<p>Valid constructors include all provided by vipy.image.Image() and vipy.image.ImageCategory() with the additional kwarg 'objects', which is a list of vipy.object.Detections()</p>
<pre><code class="language-python">im = vipy.image.Scene(filename='/path/to/city_image.ext', category='city', objects=[vipy.object.Detection(category='vehicle', xmin=0, ymin=0, width=100, height=100)])
im = vipy.image.Scene(filename='/path/to/city_image.ext', category='city').objects([vipy.object.Detection(category='vehicle', xmin=0, ymin=0, width=100, height=100)])
im = vipy.image.Scene(filename='/path/to/city_image.ext', category='office', boxlabels='face', xywh=[0,0,100,100])
im = vipy.image.Scene(filename='/path/to/city_image.ext', category='office', boxlabels='face', xywh=[[0,0,100,100], [100,100,200,200]])
im = vipy.image.Scene(filename='/path/to/city_image.ext', category='office', boxlabels=['face', 'desk'] xywh=[[0,0,100,100], [200,200,300,300]])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1694-L2197" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Scene(ImageCategory):
    &#34;&#34;&#34;vipy.image.Scene class

    This class provides a representation of a vipy.image.ImageCategory with one or more vipy.object.Detections.  The goal of this class is to provide a unified representation for all objects in a scene.

    Valid constructors include all provided by vipy.image.Image() and vipy.image.ImageCategory() with the additional kwarg &#39;objects&#39;, which is a list of vipy.object.Detections()

    ```python
    im = vipy.image.Scene(filename=&#39;/path/to/city_image.ext&#39;, category=&#39;city&#39;, objects=[vipy.object.Detection(category=&#39;vehicle&#39;, xmin=0, ymin=0, width=100, height=100)])
    im = vipy.image.Scene(filename=&#39;/path/to/city_image.ext&#39;, category=&#39;city&#39;).objects([vipy.object.Detection(category=&#39;vehicle&#39;, xmin=0, ymin=0, width=100, height=100)])
    im = vipy.image.Scene(filename=&#39;/path/to/city_image.ext&#39;, category=&#39;office&#39;, boxlabels=&#39;face&#39;, xywh=[0,0,100,100])
    im = vipy.image.Scene(filename=&#39;/path/to/city_image.ext&#39;, category=&#39;office&#39;, boxlabels=&#39;face&#39;, xywh=[[0,0,100,100], [100,100,200,200]])
    im = vipy.image.Scene(filename=&#39;/path/to/city_image.ext&#39;, category=&#39;office&#39;, boxlabels=[&#39;face&#39;, &#39;desk&#39;] xywh=[[0,0,100,100], [200,200,300,300]])
    ```

    &#34;&#34;&#34;
    def __init__(self, filename=None, url=None, category=None, attributes=None, objects=None, xywh=None, boxlabels=None, array=None, colorspace=None):
        super().__init__(filename=filename, url=url, attributes=attributes, category=category, array=array, colorspace=colorspace)   # ImageCategory class inheritance
        self._objectlist = []

        if objects is not None:
            if not (isinstance(objects, list) and all([isinstance(bb, vipy.object.Detection) for bb in objects])):
                raise ValueError(&#34;Invalid object list - Input must be [vipy.object.Detection(), ...]&#34;)
            self._objectlist = objects

        detlist = []
        if xywh is not None:
            if (islistoflists(xywh) or istupleoftuples(xywh)) and all([len(bb)==4 for bb in xywh]):
                detlist = [vipy.object.Detection(category=None, xywh=bb) for bb in xywh]
            elif (islist(xywh) or istuple(xywh)) and len(xywh)==4 and all([isnumber(bb) for bb in xywh]):
                detlist = [vipy.object.Detection(category=None, xywh=xywh)]
            else:
                raise ValueError(&#34;Invalid xywh list - Input must be [[x1,y1,w1,h1], ...&#34;)            
        if boxlabels is not None:
            if isstring(boxlabels):
                label = boxlabels
                detlist = [d.category(label) for d in detlist]
            elif (istuple(boxlabels) or islist(boxlabels)) and len(boxlabels) == len(xywh):
                detlist = [d.category(label) for (d,label) in zip(detlist, boxlabels)]
            else:
                raise ValueError(&#34;Invalid boxlabels list - len(boxlabels) must be len(xywh) with corresponding labels for each xywh box  [label1, label2, ...]&#34;)

        self._objectlist = self._objectlist + detlist

    @classmethod
    def cast(cls, im):
        assert isinstance(im, vipy.image.Image), &#34;Invalid input - must be derived from vipy.image.Image&#34;
        if im.__class__ != vipy.image.Image:
            im.__class__ = vipy.image.Image
            im._category = None if not hasattr(im, &#39;_category&#39;) else im._category
            im._objectlist = [] if not hasattr(im, &#39;_objectlist&#39;) else im._objectlist  
        return im
        
    @classmethod
    def from_json(obj, s):
        im = super().from_json(s)
        d = json.loads(s)
        im._objectlist = [vipy.object.Detection.from_json(s) for s in d[&#39;_objectlist&#39;]]        
        return im

    def json(self, s=None, encode=True):
        if s is None:
            d = json.loads(super().json())
            d[&#39;_objectlist&#39;] = [bb.json(encode=False) for bb in self._objectlist]
            return json.dumps(d) if encode else d
        else:
            super().json(s)
            d = json.loads(s)            
            self._objectlist = [vipy.object.Detection.from_json(s) for s in d[&#39;_objectlist&#39;]]
            return self
    
    def __eq__(self, other):
        &#34;&#34;&#34;Scene equality requires equality of all objects in the scene, assumes a total order of objects&#34;&#34;&#34;
        return isinstance(other, Scene) and len(self)==len(other) and all([obj1 == obj2 for (obj1, obj2) in zip(self, other)])

    def __repr__(self):
        strlist = []
        if self.isloaded():
            strlist.append(&#34;height=%d, width=%d, color=%s&#34; % (self.height(), self.width(), self.colorspace()))
        if self.filename() is not None:
            strlist.append(&#39;filename=&#34;%s&#34;&#39; % (self.filename() if self.hasfilename() else &#39;&lt;NOTFOUND&gt;%s&lt;/NOTFOUND&gt;&#39; % self.filename()))
        if self.hasurl():
            strlist.append(&#39;url=%s&#39; % self.url())
        if self.category() is not None:
            strlist.append(&#39;category=&#34;%s&#34;&#39; % self.category())
        if len(self.objects()) &gt; 0:
            strlist.append(&#39;objects=%d&#39; % len(self.objects()))
        return str(&#39;&lt;vipy.image.scene: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def __len__(self):
        &#34;&#34;&#34;The length of a scene is equal to the number of objects present in the scene&#34;&#34;&#34;
        return len(self._objectlist)

    def __iter__(self):
        &#34;&#34;&#34;Iterate over each ImageDetection() in the scene&#34;&#34;&#34;
        for (k, im) in enumerate(self._objectlist):
            yield self.__getitem__(k)

    def __getitem__(self, k):
        &#34;&#34;&#34;Return the kth object in the scene as an ImageDetection&#34;&#34;&#34;
        assert isinstance(k, int), &#34;Indexing by object in scene must be integer&#34;
        obj = self._objectlist[k].clone()
        return (ImageDetection(array=self.array(), filename=self.filename(), url=self.url(), colorspace=self.colorspace(), bbox=obj, category=obj.category(), attributes=obj.attributes))

    def append(self, imdet):
        &#34;&#34;&#34;Append the provided vipy.object.Detection object to the scene object list&#34;&#34;&#34;
        assert isinstance(imdet, vipy.object.Detection), &#34;Invalid input&#34;
        self._objectlist.append(imdet)
        return self

    def add(self, imdet):
        &#34;&#34;&#34;Alias for append&#34;&#34;&#34;        
        return self.append(imdet)
    
    def objects(self, objectlist=None):
        if objectlist is None:
            return self._objectlist
        else:
            assert isinstance(objectlist, list) and (len(objectlist) == 0 or all([isinstance(bb, vipy.object.Detection) for bb in objectlist])), &#34;Invalid object list&#34;
            self._objectlist = objectlist
            return self

    def objectmap(self, f):
        &#34;&#34;&#34;Apply lambda function f to each object.  If f is a list of lambda, apply one to one with the objects&#34;&#34;&#34;
        assert callable(f)
        self._objectlist = [f(obj)  for obj in self._objectlist] if not isinstance(f, list) else [g(obj) for (g,obj) in zip(f, self._objectlist)]
        assert all([isinstance(a, vipy.object.Detection) for a in self.objects()]), &#34;Lambda function must return vipy.object.Detection&#34;
        return self

    def objectfilter(self, f):
        &#34;&#34;&#34;Apply lambda function f to each object and keep if filter is True&#34;&#34;&#34;
        assert callable(f)
        self._objectlist = [obj for obj in self._objectlist if f(obj) is True]
        return self

    def nms(self, conf, iou, cover=0.8):
        &#34;&#34;&#34;Non-maximum supporession of objects() by category based on confidence and spatial IoU and cover thresholds&#34;&#34;&#34;
        return self.objects( vipy.object.non_maximum_suppression(self.objects(), conf=conf, iou=iou, cover=cover, bycategory=True) )

    def intersection(self, other, miniou, bycategory=True):
        &#34;&#34;&#34;Return a Scene() containing the objects in both self and other, that overlap by miniou with greedy assignment&#34;&#34;&#34;
        assert isinstance(other, Scene), &#34;Invalid input&#34;
        v = self.clone()
        v._objectlist = [v._objectlist[k] for (k,d) in enumerate(greedy_assignment(v.objects(), other.objects(), miniou, bycategory=bycategory)) if d is not None]
        return v

    def difference(self, other, miniou):
        &#34;&#34;&#34;Return a Scene() containing the objects in self but not other, that overlap by miniou with greedy assignment&#34;&#34;&#34;
        assert isinstance(other, Scene), &#34;Invalid input&#34;
        v = self.clone()
        v._objectlist = [v._objectlist[k] for (k,d) in enumerate(greedy_assignment(self.objects(), other.objects(), miniou, bycategory=True)) if d is None]
        return v
        
    def union(self, other, miniou=None):
        &#34;&#34;&#34;Combine the objects of the scene with other and self with no duplicate checking unless miniou is not None&#34;&#34;&#34;
        if isinstance(other, Scene):
            self.objects(self.objects()+other.objects())
        return self

    def uncrop(self, bb, shape):
        &#34;&#34;&#34;Uncrop a previous crop(bb) called with the supplied bb=BoundingBox(), and zeropad to shape=(H,W)&#34;&#34;&#34;
        super().uncrop(bb, shape)
        return self.objectmap(lambda o: o.translate(bb.xmin(), bb.ymin()))
        
    def clear(self):
        &#34;&#34;&#34;Remove all objects from this scene.&#34;&#34;&#34;
        return self.objects([])
    
    def boundingbox(self):
        &#34;&#34;&#34;The boundingbox of a scene is the union of all object bounding boxes, or None if there are no objects&#34;&#34;&#34;
        boxes = self.objects()
        bb = boxes[0].clone() if len(boxes) &gt;= 1 else None
        return bb.union(boxes[1:]) if len(boxes) &gt;= 2 else bb

    def categories(self):
        &#34;&#34;&#34;Return list of unique object categories in scene&#34;&#34;&#34;
        return list(set([obj.category() for obj in self._objectlist]))
    
    # Spatial transformation
    def imclip(self):
        &#34;&#34;&#34;Clip all bounding boxes to the image rectangle, silently rejecting those boxes that are degenerate or outside the image&#34;&#34;&#34;
        self._objectlist = [bb.imclip(self.numpy()) for bb in self._objectlist if bb.hasoverlap(self.numpy())]
        return self

    def rescale(self, scale=1, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Rescale image buffer and all bounding boxes - Not idempotent&#34;&#34;&#34;
        self = super().rescale(scale, interp=interp)
        self._objectlist = [bb.rescale(scale) for bb in self._objectlist]
        return self

    def resize(self, cols=None, rows=None, height=None, width=None, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize image buffer to (height=rows, width=cols) and transform all bounding boxes accordingly.  If cols or rows is None, then scale isotropically&#34;&#34;&#34;
        assert not (cols is not None and width is not None), &#34;Define either width or cols&#34;
        assert not (rows is not None and height is not None), &#34;Define either height or rows&#34;
        rows = rows if height is None else height
        cols = cols if width is None else width        
        assert cols is not None or rows is not None, &#34;Invalid input&#34;
        
        sx = (float(cols) / self.width()) if cols is not None else None
        sy = (float(rows) / self.height()) if rows is not None else None
        sx = sy if sx is None else sx
        sy = sx if sy is None else sy        
        self._objectlist = [bb.scalex(sx).scaley(sy) for bb in self._objectlist]        
        if sx == sy:
            self = super().rescale(sx, interp=interp)  # FIXME: if we call resize here, inheritance is screweed up
        else:
            self = super().resize(cols, rows, interp=interp)
        return self

    def centersquare(self):
        &#34;&#34;&#34;Crop the image of size (H,W) to be centersquare (min(H,W), min(H,W)) preserving center, and update bounding boxes&#34;&#34;&#34;
        (H,W) = self.shape()
        self = super().centersquare()
        (dy, dx) = ((H - self.height())/2.0, (W - self.width())/2.0)
        self._objectlist = [bb.translate(-dx, -dy) for bb in self._objectlist]
        return self
    
    def fliplr(self):
        &#34;&#34;&#34;Mirror buffer and all bounding box around vertical axis&#34;&#34;&#34;
        self._objectlist = [bb.fliplr(self.numpy()) for bb in self._objectlist]
        self = super().fliplr()
        return self

    def flipud(self):
        &#34;&#34;&#34;Mirror buffer and all bounding box around vertical axis&#34;&#34;&#34;
        self._objectlist = [bb.flipud(self.numpy()) for bb in self._objectlist]
        self = super().flipud()
        return self
    
    def dilate(self, s):
        &#34;&#34;&#34;Dilate all bounding boxes by scale factor, dilated boxes may be outside image rectangle&#34;&#34;&#34;
        self._objectlist = [bb.dilate(s) for bb in self._objectlist]
        return self

    def zeropad(self, padwidth, padheight):
        &#34;&#34;&#34;Zero pad image with padwidth cols before and after and padheight rows before and after, then update bounding box offsets&#34;&#34;&#34;
        self = super().zeropad(padwidth, padheight)
        dx = padwidth[0] if isinstance(padwidth, tuple) and len(padwidth) == 2 else padwidth
        dy = padheight[0] if isinstance(padheight, tuple) and len(padheight) == 2 else padheight
        self._objectlist = [bb.translate(dx, dy) for bb in self._objectlist]
        return self

    def meanpad(self, padwidth, padheight, mu=None):
        &#34;&#34;&#34;Mean pad (image color mean) image with padwidth cols before and after and padheight rows before and after, then update bounding box offsets&#34;&#34;&#34;
        self = super().meanpad(padwidth, padheight, mu=mu)
        dx = padwidth[0] if isinstance(padwidth, tuple) and len(padwidth) == 2 else padwidth
        dy = padheight[0] if isinstance(padheight, tuple) and len(padheight) == 2 else padheight
        self._objectlist = [bb.translate(dx, dy) for bb in self._objectlist]
        return self

    def rot90cw(self):
        &#34;&#34;&#34;Rotate the scene 90 degrees clockwise, and update objects&#34;&#34;&#34;
        (H,W) = self.shape()        
        self.array(np.rot90(self.numpy(), 3))
        self._objectlist = [bb.rot90cw(H, W) for bb in self._objectlist]
        return self

    def rot90ccw(self):
        &#34;&#34;&#34;Rotate the scene 90 degrees counterclockwise, and update objects&#34;&#34;&#34;
        (H,W) = self.shape()
        self.array(np.rot90(self.numpy(), 1))
        self._objectlist = [bb.rot90ccw(H, W) for bb in self._objectlist]
        return self

    def maxdim(self, dim=None, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize scene preserving aspect ratio so that maximum dimension of image = dim, update all objects&#34;&#34;&#34;
        return super().maxdim(dim, interp=interp) if dim is not None else max(self.shape())  # will call self.rescale() which will update boxes

    def mindim(self, dim=None, interp=&#39;bilinear&#39;):
        &#34;&#34;&#34;Resize scene preserving aspect ratio so that minimum dimension of image = dim, update all objects&#34;&#34;&#34;
        return super().mindim(dim, interp=interp) if dim is not None else min(self.shape())  # will call self.rescale() which will update boxes

    def crop(self, bbox=None):
        &#34;&#34;&#34;Crop the image buffer using the supplied bounding box object (or the only object if bbox=None), clipping the box to the image rectangle, update all scene objects&#34;&#34;&#34;
        assert bbox is not None or (len(self) == 1), &#34;Bounding box must be provided if number of objects != 1&#34;
        bbox = bbox if bbox is not None else self._objectlist[0]
        self = super()._crop(bbox)        
        (dx, dy) = (bbox.xmin(), bbox.ymin())
        self._objectlist = [bb.translate(-dx, -dy) for bb in self._objectlist]
        return self

    def objectcrop(self, dilate=1.0, maxsquare=False):
        &#34;&#34;&#34;Crop image using the `vipy.image.Scene.boundingbox` with dilation factor, setting to maxsquare prior to crop as requested.  Crop will be zeropadded if outside the image rectangle.&#34;&#34;&#34;
        bb = self.boundingbox()
        return self.padcrop(bb.dilate(dilate).maxsquareif(maxsquare)) if bb is not None else self
    
    def centercrop(self, height, width):
        &#34;&#34;&#34;Crop image of size (height x width) in the center, keeping the image centroid constant&#34;&#34;&#34;
        return self.crop(BoundingBox(xcentroid=float(self.width() / 2.0), ycentroid=float(self.height() / 2.0), width=int(width), height=int(height)))

    def cornercrop(self, height, width):
        &#34;&#34;&#34;Crop image of size (height x width) from the upper left corner, returning valid pixels only&#34;&#34;&#34;
        return self.crop(BoundingBox(xmin=0, ymin=0, width=int(width), height=int(height)))
    
    def padcrop(self, bbox):
        &#34;&#34;&#34;Crop the image buffer using the supplied bounding box object, zero padding if box is outside image rectangle, update all scene objects&#34;&#34;&#34;
        self.zeropad(bbox.int().width(), bbox.int().height())  # FIXME: this is inefficient
        (dx, dy) = (bbox.width(), bbox.height())
        bbox = bbox.translate(dx, dy)
        self._objectlist = [bb.translate(-dx, -dy) for bb in self._objectlist]        
        self = super()._crop(bbox)        
        (dx, dy) = (bbox.xmin(), bbox.ymin())
        return self

    def cornerpadcrop(self, height, width):
        &#34;&#34;&#34;Crop image of size (height x width) from the upper left corner, returning zero padded result out to (height, width)&#34;&#34;&#34;
        return self.padcrop(BoundingBox(xmin=0, ymin=0, width=width, height=height))
    
    # Image export
    def rectangular_mask(self, W=None, H=None):
        &#34;&#34;&#34;Return a binary array of the same size as the image (or using the
        provided image width and height (W,H) size to avoid an image load),
        with ones inside the bounding box&#34;&#34;&#34;
        if (W is None or H is None):
            (H, W) = (int(np.round(self.height())),
                      int(np.round(self.width())))
        immask = np.zeros((H, W)).astype(np.uint8)
        for bb in self._objectlist:
            if bb.hasoverlap(immask):
                bbm = bb.clone().imclip(self.numpy()).int()
                immask[bbm.ymin():bbm.ymax(), bbm.xmin():bbm.xmax()] = 1
        return immask

    def binarymask(self):
        &#34;&#34;&#34;Alias for rectangular_mask with in-place update&#34;&#34;&#34;
        mask = self.rectangular_mask() if self.channels() == 1 else np.expand_dims(self.rectangular_mask(), axis=2)
        img = self.numpy()
        img[:] = mask[:]  # in-place update
        return self
        
    def bgmask(self):
        &#34;&#34;&#34;Set all pixels outside the bounding box to zero&#34;&#34;&#34;
        mask = self.rectangular_mask() if self.channels() == 1 else np.expand_dims(self.rectangular_mask(), axis=2)
        img = self.numpy()
        img[:] = np.multiply(img, mask)  # in-place update
        return self  

    def fgmask(self):
        &#34;&#34;&#34;Set all pixels inside the bounding box to zero&#34;&#34;&#34;
        mask = self.rectangular_mask() if self.channels() == 1 else np.expand_dims(self.rectangular_mask(), axis=2)
        img = self.numpy()
        img[:] = np.multiply(img, 1.0-mask)  # in-place update
        return self
    
    def setzero(self):
        return self.fgmask()
    
    def pixelmask(self, pixelsize=8):
        &#34;&#34;&#34;Replace pixels within all foreground objects with a privacy preserving pixelated foreground with larger pixels (e.g. like privacy glass)&#34;&#34;&#34;
        assert pixelsize &gt; 1, &#34;Pixelsize is a scale factor such that pixels within the foreground are pixelsize times larger than the background&#34;
        (img, mask) = (self.numpy(), self.rectangular_mask())  # force writeable
        img[mask &gt; 0] = self.clone().rescale(1.0/pixelsize, interp=&#39;nearest&#39;).resize_like(self, interp=&#39;nearest&#39;).numpy()[mask &gt; 0]  # in-place update
        return self

    def pixelize(self, radius=16):
        &#34;&#34;&#34;Alias for pixelmask&#34;&#34;&#34;
        return self.pixelmask(pixelsize=radius)
    def pixelate(self, radius=16):
        &#34;&#34;&#34;Alias for pixelmask&#34;&#34;&#34;
        return self.pixelmask(pixelsize=radius)
        
    
    def blurmask(self, radius=7):
        &#34;&#34;&#34;Replace pixels within all foreground objects with a privacy preserving blurred foreground&#34;&#34;&#34;
        assert radius &gt; 1, &#34;Pixelsize is a scale factor such that pixels within the foreground are pixelsize times larger than the background&#34;
        (img, mask) = (self.numpy(), self.rectangular_mask())  # force writeable
        img[mask &gt; 0] = self.clone().blur(radius).numpy()[mask &gt; 0]  # in-place update
        return self

    def replace(self, newim, broadcast=False):
        &#34;&#34;&#34;Set all image values within the bounding box equal to the provided img, triggers load() and imclip()&#34;&#34;&#34;
        assert isinstance(newim, vipy.image.Image), &#34;Invalid replacement image - Must be vipy.image.Image&#34;
        img = self.numpy()        
        newimg = newim.array()
        for d in self._objectlist:
            d.imclip(newimg).imclip(img)
            img[int(d.ymin()):int(d.ymax()),
                int(d.xmin()):int(d.xmax())] = newimg[int(d.ymin()):int(d.ymax()),
                                                      int(d.xmin()):int(d.xmax())] if not broadcast else newim.clone().resize(int(d.width()), int(d.height())).array()
        return self
    
    def meanmask(self):
        &#34;&#34;&#34;Replace pixels within the foreground objects with the mean pixel color&#34;&#34;&#34;
        img = self.numpy()  # force writeable
        img[self.rectangular_mask() &gt; 0] = self.meanchannel()  # in-place update
        return self

    def perceptualhash(self, bits=128, asbinary=False, asbytes=False, objmask=False):
        &#34;&#34;&#34;Perceptual differential hash function.

        This function sets foreground objects to mean color, convert to greyscale, resize with linear interpolation to small image based on desired bit encoding, compute vertical and horizontal gradient signs.
        
        Args:
            bits: [int]  longer hashes have lower TAR (true accept rate, some near dupes are missed), but lower FAR (false accept rate), shorter hashes have higher TAR (fewer near-dupes are missed) but higher FAR (more non-dupes are declared as dupes).
            objmask: [bool] if true, replace the foreground object masks with the mean color prior to computing
            asbinary: [bool] If true, return a binary array
            asbytes: [bool] if true return a byte array

        Returns:
            A hash string encoding the perceptual hash such that `vipy.image.Image.perceptualhash_distance` can be used to compute a hash distance
            asbytes: a bytes array
            asbinary: a numpy binary array            

        .. notes::
            - Can be used for near duplicate detection of background scenes by unpacking the returned hex string to binary and computing hamming distance, or performing hamming based nearest neighbor indexing.  Equivalently, `vipy.image.Image.perceptualhash_distance`.
            - The default packed hex output can be converted to binary as: np.unpackbits(bytearray().fromhex( bghash() )) which is equivalent to perceptualhash(asbinary=True)
       
        &#34;&#34;&#34;        
        allowablebits = [2*k*k for k in range(2, 17)]
        assert bits in allowablebits, &#34;Bits must be in %s&#34; % str(allowablebits)
        sq = int(np.ceil(np.sqrt(bits/2.0)))
        im = self.clone() if not objmask else self.clone().meanmask()        
        b = (np.dstack(np.gradient(im.resize(cols=sq+1, rows=sq+1).greyscale().numpy()))[0:-1, 0:-1] &gt; 0).flatten()
        return bytes(np.packbits(b)).hex() if not (asbytes or asbinary) else bytes(np.packbits(b)) if asbytes else b

    def fghash(self, bits=8, asbinary=False, asbytes=False):
        &#34;&#34;&#34;Perceptual differential hash function, computed for each foreground region independently&#34;&#34;&#34;
        return [im.crop().perceptualhash(bits=bits, asbinary=asbinary, asbytes=asbytes, objmask=False)  for im in self]

    
    def bghash(self, bits=128, asbinary=False, asbytes=False):
        &#34;&#34;&#34;Percetual differential hash function, masking out foreground regions&#34;&#34;&#34;
        return self.clone().greyscale().perceptualhash(bits=bits, asbinary=asbinary, asbytes=asbytes, objmask=True)
        
    def isduplicate(self, im, threshold, bits=128):
        &#34;&#34;&#34;Background hash near duplicate detection, returns true if self and im are near duplicate images using bghash&#34;&#34;&#34;
        assert isinstance(im, Image), &#34;Invalid input&#34;
        return vipy.image.Image.perceptualhash_distance(self.bghash(bits=bits), im.bghash(bits=bits)) &lt; threshold 
    
        
    def show(self, categories=None, figure=1, nocaption=False, nocaption_withstring=[], fontsize=10, boxalpha=0.25, d_category2color={&#39;Person&#39;:&#39;green&#39;, &#39;Vehicle&#39;:&#39;blue&#39;, &#39;Object&#39;:&#39;red&#39;}, captionoffset=(0,0), nowindow=False, textfacecolor=&#39;white&#39;, textfacealpha=1.0, shortlabel=True, timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None, timestampoffset=(0,0)):
        &#34;&#34;&#34;Show scene detection 

        Args:
           - categories: [list]  List of category (or shortlabel) names in the scene to show
           - fontsize: [int] or [str]: Size of the font, fontsize=int for points, fontsize=&#39;NN:scaled&#39; to scale the font relative to the image size
           - figure: [int] Figure number, show the image in the provided figure=int numbered window
           - nocaption: [bool]  Show or do not show the text caption in the upper left of the box 
           - nocaption_withstring: [list]:  Do not show captions for those detection categories (or shortlabels) containing any of the strings in the provided list
           - boxalpha (float, [0,1]):  Set the text box background to be semi-transparent with an alpha
           - d_category2color (dict):  Define a dictionary of required mapping of specific category() to box colors.  Non-specified categories are assigned a random named color from vipy.show.colorlist()
           - caption_offset (int, int): The relative position of the caption to the upper right corner of the box.
           - nowindow (bool):  Display or not display the image
           - textfacecolor (str): One of the named colors from vipy.show.colorlist() for the color of the textbox background
           - textfacealpha (float, [0,1]):  The textbox background transparency
           - shortlabel (bool):  Whether to show the shortlabel or the full category name in the caption
           - mutator (lambda):  A lambda function with signature lambda im: f(im) which will modify this image prior to show.  Useful for changing labels on the fly
           - timestampoffset (tuple): (x,y) coordinate offsets to shift the upper left corner timestamp
        &#34;&#34;&#34;
        colors = vipy.show.colorlist()
        im = self.clone() if not mutator else mutator(self.clone())
        valid_detections = [obj.clone() for obj in im._objectlist if categories is None or obj.category() in tolist(categories)]  # Detections with valid category
        valid_detections = [obj.imclip(self.numpy()) for obj in valid_detections if obj.hasoverlap(self.numpy())]  # Detections within image rectangle
        valid_detections = [obj.category(obj.shortlabel()) for obj in valid_detections] if shortlabel else valid_detections  # Display name as shortlabel?               
        d_categories2color = {d.category():colors[int(hashlib.sha1(d.category().split(&#39; &#39;)[-1].encode(&#39;utf-8&#39;)).hexdigest(), 16) % len(colors)] for d in valid_detections}   # consistent color mapping by category suffix (space separated)
        d_categories2color.update(d_category2color)  # requested color mapping
        detection_color = [d_categories2color[d.category()] for d in valid_detections]                
        valid_detections = [d if not any([c in d.category() for c in tolist(nocaption_withstring)]) else d.nocategory() for d in valid_detections]  # Detections requested to show without caption
        imdisplay = self.clone().rgb() if self.colorspace() != &#39;rgb&#39; else self  # convert to RGB for show() if necessary
        fontsize_scaled = float(fontsize.split(&#39;:&#39;)[0])*(min(imdisplay.shape())/640.0) if isstring(fontsize) else fontsize
        imdisplay = mutator(imdisplay) if mutator is not None else imdisplay        
        vipy.show.imdetection(imdisplay._array, valid_detections, bboxcolor=detection_color, textcolor=detection_color, fignum=figure, do_caption=(nocaption==False), facealpha=boxalpha, fontsize=fontsize_scaled,
                              captionoffset=captionoffset, nowindow=nowindow, textfacecolor=textfacecolor, textfacealpha=textfacealpha, timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, timestampoffset=timestampoffset)
        return self

    def annotate(self, outfile=None, categories=None, figure=1, nocaption=False, fontsize=10, boxalpha=0.25, d_category2color={&#39;person&#39;:&#39;green&#39;, &#39;vehicle&#39;:&#39;blue&#39;, &#39;object&#39;:&#39;red&#39;}, captionoffset=(0,0), dpi=200, textfacecolor=&#39;white&#39;, textfacealpha=1.0, shortlabel=True, nocaption_withstring=[], timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None, timestampoffset=(0,0)):
        &#34;&#34;&#34;Alias for savefig&#34;&#34;&#34;
        return self.savefig(outfile=outfile, 
                            categories=categories, 
                            figure=figure, 
                            nocaption=nocaption, 
                            fontsize=fontsize, 
                            boxalpha=boxalpha, 
                            d_category2color=d_category2color,
                            captionoffset=captionoffset, 
                            dpi=dpi, 
                            textfacecolor=textfacecolor, 
                            textfacealpha=textfacealpha, 
                            shortlabel=shortlabel, 
                            nocaption_withstring=nocaption_withstring, 
                            timestamp=timestamp, 
                            timestampcolor=timestampcolor, 
                            timestampfacecolor=timestampfacecolor,
                            timestampoffset=timestampoffset,
                            mutator=mutator)

    def savefig(self, outfile=None, categories=None, figure=1, nocaption=False, fontsize=10, boxalpha=0.25, d_category2color={&#39;person&#39;:&#39;green&#39;, &#39;vehicle&#39;:&#39;blue&#39;, &#39;object&#39;:&#39;red&#39;}, captionoffset=(0,0), dpi=200, textfacecolor=&#39;white&#39;, textfacealpha=1.0, shortlabel=True, nocaption_withstring=[], timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None, timestampoffset=(0,0)):
        &#34;&#34;&#34;Save show() output to given file or return buffer without popping up a window&#34;&#34;&#34;
        fignum = figure if figure is not None else 1        
        self.show(categories=categories, figure=fignum, nocaption=nocaption, fontsize=fontsize, boxalpha=boxalpha, 
                  d_category2color=d_category2color, captionoffset=captionoffset, nowindow=True, textfacecolor=textfacecolor, 
                  textfacealpha=textfacealpha, shortlabel=shortlabel, nocaption_withstring=nocaption_withstring, timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, mutator=mutator, timestampoffset=timestampoffset)
        
        if outfile is None:
            buf = io.BytesIO()
            (W,H) = plt.figure(num=fignum).canvas.get_width_height()  # fast(ish)
            plt.figure(num=fignum).canvas.print_raw(buf)  # fast(ish)
            img = np.frombuffer(buf.getbuffer(), dtype=np.uint8).reshape((H, W, 4))
            if figure is None:
                vipy.show.close(plt.gcf().number)   # memory cleanup (useful for video annotation on last frame)
            return vipy.image.Image(array=img, colorspace=&#39;rgba&#39;)
        else:
            vipy.show.savefig(os.path.abspath(os.path.expanduser(outfile)), figure, dpi=dpi, bbox_inches=&#39;tight&#39;, pad_inches=0)
            return outfile</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vipy.image.ImageCategory" href="#vipy.image.ImageCategory">ImageCategory</a></li>
<li><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vipy.image.ImageDetection" href="#vipy.image.ImageDetection">ImageDetection</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="vipy.image.Scene.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, imdet)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for append</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1804-L1806" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add(self, imdet):
    &#34;&#34;&#34;Alias for append&#34;&#34;&#34;        
    return self.append(imdet)</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.annotate"><code class="name flex">
<span>def <span class="ident">annotate</span></span>(<span>self, outfile=None, categories=None, figure=1, nocaption=False, fontsize=10, boxalpha=0.25, d_category2color={'person': 'green', 'vehicle': 'blue', 'object': 'red'}, captionoffset=(0, 0), dpi=200, textfacecolor='white', textfacealpha=1.0, shortlabel=True, nocaption_withstring=[], timestamp=None, timestampcolor='black', timestampfacecolor='white', mutator=None, timestampoffset=(0, 0))</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for savefig</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2159-L2178" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def annotate(self, outfile=None, categories=None, figure=1, nocaption=False, fontsize=10, boxalpha=0.25, d_category2color={&#39;person&#39;:&#39;green&#39;, &#39;vehicle&#39;:&#39;blue&#39;, &#39;object&#39;:&#39;red&#39;}, captionoffset=(0,0), dpi=200, textfacecolor=&#39;white&#39;, textfacealpha=1.0, shortlabel=True, nocaption_withstring=[], timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None, timestampoffset=(0,0)):
    &#34;&#34;&#34;Alias for savefig&#34;&#34;&#34;
    return self.savefig(outfile=outfile, 
                        categories=categories, 
                        figure=figure, 
                        nocaption=nocaption, 
                        fontsize=fontsize, 
                        boxalpha=boxalpha, 
                        d_category2color=d_category2color,
                        captionoffset=captionoffset, 
                        dpi=dpi, 
                        textfacecolor=textfacecolor, 
                        textfacealpha=textfacealpha, 
                        shortlabel=shortlabel, 
                        nocaption_withstring=nocaption_withstring, 
                        timestamp=timestamp, 
                        timestampcolor=timestampcolor, 
                        timestampfacecolor=timestampfacecolor,
                        timestampoffset=timestampoffset,
                        mutator=mutator)</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, imdet)</span>
</code></dt>
<dd>
<div class="desc"><p>Append the provided vipy.object.Detection object to the scene object list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1798-L1802" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def append(self, imdet):
    &#34;&#34;&#34;Append the provided vipy.object.Detection object to the scene object list&#34;&#34;&#34;
    assert isinstance(imdet, vipy.object.Detection), &#34;Invalid input&#34;
    self._objectlist.append(imdet)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.bghash"><code class="name flex">
<span>def <span class="ident">bghash</span></span>(<span>self, bits=128, asbinary=False, asbytes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Percetual differential hash function, masking out foreground regions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2114-L2116" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bghash(self, bits=128, asbinary=False, asbytes=False):
    &#34;&#34;&#34;Percetual differential hash function, masking out foreground regions&#34;&#34;&#34;
    return self.clone().greyscale().perceptualhash(bits=bits, asbinary=asbinary, asbytes=asbytes, objmask=True)</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.bgmask"><code class="name flex">
<span>def <span class="ident">bgmask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all pixels outside the bounding box to zero</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2024-L2029" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bgmask(self):
    &#34;&#34;&#34;Set all pixels outside the bounding box to zero&#34;&#34;&#34;
    mask = self.rectangular_mask() if self.channels() == 1 else np.expand_dims(self.rectangular_mask(), axis=2)
    img = self.numpy()
    img[:] = np.multiply(img, mask)  # in-place update
    return self  </code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.binarymask"><code class="name flex">
<span>def <span class="ident">binarymask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for rectangular_mask with in-place update</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2017-L2022" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def binarymask(self):
    &#34;&#34;&#34;Alias for rectangular_mask with in-place update&#34;&#34;&#34;
    mask = self.rectangular_mask() if self.channels() == 1 else np.expand_dims(self.rectangular_mask(), axis=2)
    img = self.numpy()
    img[:] = mask[:]  # in-place update
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.blurmask"><code class="name flex">
<span>def <span class="ident">blurmask</span></span>(<span>self, radius=7)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace pixels within all foreground objects with a privacy preserving blurred foreground</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2056-L2061" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def blurmask(self, radius=7):
    &#34;&#34;&#34;Replace pixels within all foreground objects with a privacy preserving blurred foreground&#34;&#34;&#34;
    assert radius &gt; 1, &#34;Pixelsize is a scale factor such that pixels within the foreground are pixelsize times larger than the background&#34;
    (img, mask) = (self.numpy(), self.rectangular_mask())  # force writeable
    img[mask &gt; 0] = self.clone().blur(radius).numpy()[mask &gt; 0]  # in-place update
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.boundingbox"><code class="name flex">
<span>def <span class="ident">boundingbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The boundingbox of a scene is the union of all object bounding boxes, or None if there are no objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1862-L1866" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boundingbox(self):
    &#34;&#34;&#34;The boundingbox of a scene is the union of all object bounding boxes, or None if there are no objects&#34;&#34;&#34;
    boxes = self.objects()
    bb = boxes[0].clone() if len(boxes) &gt;= 1 else None
    return bb.union(boxes[1:]) if len(boxes) &gt;= 2 else bb</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.categories"><code class="name flex">
<span>def <span class="ident">categories</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return list of unique object categories in scene</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1868-L1870" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def categories(self):
    &#34;&#34;&#34;Return list of unique object categories in scene&#34;&#34;&#34;
    return list(set([obj.category() for obj in self._objectlist]))</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.centersquare"><code class="name flex">
<span>def <span class="ident">centersquare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop the image of size (H,W) to be centersquare (min(H,W), min(H,W)) preserving center, and update bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1903-L1909" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centersquare(self):
    &#34;&#34;&#34;Crop the image of size (H,W) to be centersquare (min(H,W), min(H,W)) preserving center, and update bounding boxes&#34;&#34;&#34;
    (H,W) = self.shape()
    self = super().centersquare()
    (dy, dx) = ((H - self.height())/2.0, (W - self.width())/2.0)
    self._objectlist = [bb.translate(-dx, -dy) for bb in self._objectlist]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all objects from this scene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1858-L1860" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Remove all objects from this scene.&#34;&#34;&#34;
    return self.objects([])</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.cornercrop"><code class="name flex">
<span>def <span class="ident">cornercrop</span></span>(<span>self, height, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop image of size (height x width) from the upper left corner, returning valid pixels only</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1984-L1986" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cornercrop(self, height, width):
    &#34;&#34;&#34;Crop image of size (height x width) from the upper left corner, returning valid pixels only&#34;&#34;&#34;
    return self.crop(BoundingBox(xmin=0, ymin=0, width=int(width), height=int(height)))</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.cornerpadcrop"><code class="name flex">
<span>def <span class="ident">cornerpadcrop</span></span>(<span>self, height, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop image of size (height x width) from the upper left corner, returning zero padded result out to (height, width)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1998-L2000" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cornerpadcrop(self, height, width):
    &#34;&#34;&#34;Crop image of size (height x width) from the upper left corner, returning zero padded result out to (height, width)&#34;&#34;&#34;
    return self.padcrop(BoundingBox(xmin=0, ymin=0, width=width, height=height))</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>self, bbox=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop the image buffer using the supplied bounding box object (or the only object if bbox=None), clipping the box to the image rectangle, update all scene objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1966-L1973" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def crop(self, bbox=None):
    &#34;&#34;&#34;Crop the image buffer using the supplied bounding box object (or the only object if bbox=None), clipping the box to the image rectangle, update all scene objects&#34;&#34;&#34;
    assert bbox is not None or (len(self) == 1), &#34;Bounding box must be provided if number of objects != 1&#34;
    bbox = bbox if bbox is not None else self._objectlist[0]
    self = super()._crop(bbox)        
    (dx, dy) = (bbox.xmin(), bbox.ymin())
    self._objectlist = [bb.translate(-dx, -dy) for bb in self._objectlist]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.difference"><code class="name flex">
<span>def <span class="ident">difference</span></span>(<span>self, other, miniou)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Scene() containing the objects in self but not other, that overlap by miniou with greedy assignment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1840-L1845" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def difference(self, other, miniou):
    &#34;&#34;&#34;Return a Scene() containing the objects in self but not other, that overlap by miniou with greedy assignment&#34;&#34;&#34;
    assert isinstance(other, Scene), &#34;Invalid input&#34;
    v = self.clone()
    v._objectlist = [v._objectlist[k] for (k,d) in enumerate(greedy_assignment(self.objects(), other.objects(), miniou, bycategory=True)) if d is None]
    return v</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.dilate"><code class="name flex">
<span>def <span class="ident">dilate</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Dilate all bounding boxes by scale factor, dilated boxes may be outside image rectangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1923-L1926" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilate(self, s):
    &#34;&#34;&#34;Dilate all bounding boxes by scale factor, dilated boxes may be outside image rectangle&#34;&#34;&#34;
    self._objectlist = [bb.dilate(s) for bb in self._objectlist]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.fghash"><code class="name flex">
<span>def <span class="ident">fghash</span></span>(<span>self, bits=8, asbinary=False, asbytes=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perceptual differential hash function, computed for each foreground region independently</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2109-L2111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fghash(self, bits=8, asbinary=False, asbytes=False):
    &#34;&#34;&#34;Perceptual differential hash function, computed for each foreground region independently&#34;&#34;&#34;
    return [im.crop().perceptualhash(bits=bits, asbinary=asbinary, asbytes=asbytes, objmask=False)  for im in self]</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.fgmask"><code class="name flex">
<span>def <span class="ident">fgmask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all pixels inside the bounding box to zero</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2031-L2036" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fgmask(self):
    &#34;&#34;&#34;Set all pixels inside the bounding box to zero&#34;&#34;&#34;
    mask = self.rectangular_mask() if self.channels() == 1 else np.expand_dims(self.rectangular_mask(), axis=2)
    img = self.numpy()
    img[:] = np.multiply(img, 1.0-mask)  # in-place update
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.fliplr"><code class="name flex">
<span>def <span class="ident">fliplr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mirror buffer and all bounding box around vertical axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1911-L1915" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fliplr(self):
    &#34;&#34;&#34;Mirror buffer and all bounding box around vertical axis&#34;&#34;&#34;
    self._objectlist = [bb.fliplr(self.numpy()) for bb in self._objectlist]
    self = super().fliplr()
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.flipud"><code class="name flex">
<span>def <span class="ident">flipud</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Mirror buffer and all bounding box around vertical axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1917-L1921" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flipud(self):
    &#34;&#34;&#34;Mirror buffer and all bounding box around vertical axis&#34;&#34;&#34;
    self._objectlist = [bb.flipud(self.numpy()) for bb in self._objectlist]
    self = super().flipud()
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.imclip"><code class="name flex">
<span>def <span class="ident">imclip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clip all bounding boxes to the image rectangle, silently rejecting those boxes that are degenerate or outside the image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1873-L1876" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imclip(self):
    &#34;&#34;&#34;Clip all bounding boxes to the image rectangle, silently rejecting those boxes that are degenerate or outside the image&#34;&#34;&#34;
    self._objectlist = [bb.imclip(self.numpy()) for bb in self._objectlist if bb.hasoverlap(self.numpy())]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self, other, miniou, bycategory=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Scene() containing the objects in both self and other, that overlap by miniou with greedy assignment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1833-L1838" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def intersection(self, other, miniou, bycategory=True):
    &#34;&#34;&#34;Return a Scene() containing the objects in both self and other, that overlap by miniou with greedy assignment&#34;&#34;&#34;
    assert isinstance(other, Scene), &#34;Invalid input&#34;
    v = self.clone()
    v._objectlist = [v._objectlist[k] for (k,d) in enumerate(greedy_assignment(v.objects(), other.objects(), miniou, bycategory=bycategory)) if d is not None]
    return v</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.isduplicate"><code class="name flex">
<span>def <span class="ident">isduplicate</span></span>(<span>self, im, threshold, bits=128)</span>
</code></dt>
<dd>
<div class="desc"><p>Background hash near duplicate detection, returns true if self and im are near duplicate images using bghash</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2118-L2121" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isduplicate(self, im, threshold, bits=128):
    &#34;&#34;&#34;Background hash near duplicate detection, returns true if self and im are near duplicate images using bghash&#34;&#34;&#34;
    assert isinstance(im, Image), &#34;Invalid input&#34;
    return vipy.image.Image.perceptualhash_distance(self.bghash(bits=bits), im.bghash(bits=bits)) &lt; threshold </code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, s=None, encode=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1754-L1763" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self, s=None, encode=True):
    if s is None:
        d = json.loads(super().json())
        d[&#39;_objectlist&#39;] = [bb.json(encode=False) for bb in self._objectlist]
        return json.dumps(d) if encode else d
    else:
        super().json(s)
        d = json.loads(s)            
        self._objectlist = [vipy.object.Detection.from_json(s) for s in d[&#39;_objectlist&#39;]]
        return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.maxdim"><code class="name flex">
<span>def <span class="ident">maxdim</span></span>(<span>self, dim=None, interp='bilinear')</span>
</code></dt>
<dd>
<div class="desc"><p>Resize scene preserving aspect ratio so that maximum dimension of image = dim, update all objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1958-L1960" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxdim(self, dim=None, interp=&#39;bilinear&#39;):
    &#34;&#34;&#34;Resize scene preserving aspect ratio so that maximum dimension of image = dim, update all objects&#34;&#34;&#34;
    return super().maxdim(dim, interp=interp) if dim is not None else max(self.shape())  # will call self.rescale() which will update boxes</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.meanmask"><code class="name flex">
<span>def <span class="ident">meanmask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace pixels within the foreground objects with the mean pixel color</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2075-L2079" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def meanmask(self):
    &#34;&#34;&#34;Replace pixels within the foreground objects with the mean pixel color&#34;&#34;&#34;
    img = self.numpy()  # force writeable
    img[self.rectangular_mask() &gt; 0] = self.meanchannel()  # in-place update
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.meanpad"><code class="name flex">
<span>def <span class="ident">meanpad</span></span>(<span>self, padwidth, padheight, mu=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Mean pad (image color mean) image with padwidth cols before and after and padheight rows before and after, then update bounding box offsets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1936-L1942" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def meanpad(self, padwidth, padheight, mu=None):
    &#34;&#34;&#34;Mean pad (image color mean) image with padwidth cols before and after and padheight rows before and after, then update bounding box offsets&#34;&#34;&#34;
    self = super().meanpad(padwidth, padheight, mu=mu)
    dx = padwidth[0] if isinstance(padwidth, tuple) and len(padwidth) == 2 else padwidth
    dy = padheight[0] if isinstance(padheight, tuple) and len(padheight) == 2 else padheight
    self._objectlist = [bb.translate(dx, dy) for bb in self._objectlist]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.mindim"><code class="name flex">
<span>def <span class="ident">mindim</span></span>(<span>self, dim=None, interp='bilinear')</span>
</code></dt>
<dd>
<div class="desc"><p>Resize scene preserving aspect ratio so that minimum dimension of image = dim, update all objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1962-L1964" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mindim(self, dim=None, interp=&#39;bilinear&#39;):
    &#34;&#34;&#34;Resize scene preserving aspect ratio so that minimum dimension of image = dim, update all objects&#34;&#34;&#34;
    return super().mindim(dim, interp=interp) if dim is not None else min(self.shape())  # will call self.rescale() which will update boxes</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.nms"><code class="name flex">
<span>def <span class="ident">nms</span></span>(<span>self, conf, iou, cover=0.8)</span>
</code></dt>
<dd>
<div class="desc"><p>Non-maximum supporession of objects() by category based on confidence and spatial IoU and cover thresholds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1829-L1831" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nms(self, conf, iou, cover=0.8):
    &#34;&#34;&#34;Non-maximum supporession of objects() by category based on confidence and spatial IoU and cover thresholds&#34;&#34;&#34;
    return self.objects( vipy.object.non_maximum_suppression(self.objects(), conf=conf, iou=iou, cover=cover, bycategory=True) )</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.objectcrop"><code class="name flex">
<span>def <span class="ident">objectcrop</span></span>(<span>self, dilate=1.0, maxsquare=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop image using the <code><a title="vipy.image.Scene.boundingbox" href="#vipy.image.Scene.boundingbox">Scene.boundingbox()</a></code> with dilation factor, setting to maxsquare prior to crop as requested.
Crop will be zeropadded if outside the image rectangle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1975-L1978" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def objectcrop(self, dilate=1.0, maxsquare=False):
    &#34;&#34;&#34;Crop image using the `vipy.image.Scene.boundingbox` with dilation factor, setting to maxsquare prior to crop as requested.  Crop will be zeropadded if outside the image rectangle.&#34;&#34;&#34;
    bb = self.boundingbox()
    return self.padcrop(bb.dilate(dilate).maxsquareif(maxsquare)) if bb is not None else self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.objectfilter"><code class="name flex">
<span>def <span class="ident">objectfilter</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply lambda function f to each object and keep if filter is True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1823-L1827" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def objectfilter(self, f):
    &#34;&#34;&#34;Apply lambda function f to each object and keep if filter is True&#34;&#34;&#34;
    assert callable(f)
    self._objectlist = [obj for obj in self._objectlist if f(obj) is True]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.objectmap"><code class="name flex">
<span>def <span class="ident">objectmap</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply lambda function f to each object.
If f is a list of lambda, apply one to one with the objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1816-L1821" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def objectmap(self, f):
    &#34;&#34;&#34;Apply lambda function f to each object.  If f is a list of lambda, apply one to one with the objects&#34;&#34;&#34;
    assert callable(f)
    self._objectlist = [f(obj)  for obj in self._objectlist] if not isinstance(f, list) else [g(obj) for (g,obj) in zip(f, self._objectlist)]
    assert all([isinstance(a, vipy.object.Detection) for a in self.objects()]), &#34;Lambda function must return vipy.object.Detection&#34;
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.objects"><code class="name flex">
<span>def <span class="ident">objects</span></span>(<span>self, objectlist=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1808-L1814" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def objects(self, objectlist=None):
    if objectlist is None:
        return self._objectlist
    else:
        assert isinstance(objectlist, list) and (len(objectlist) == 0 or all([isinstance(bb, vipy.object.Detection) for bb in objectlist])), &#34;Invalid object list&#34;
        self._objectlist = objectlist
        return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.padcrop"><code class="name flex">
<span>def <span class="ident">padcrop</span></span>(<span>self, bbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop the image buffer using the supplied bounding box object, zero padding if box is outside image rectangle, update all scene objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1988-L1996" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def padcrop(self, bbox):
    &#34;&#34;&#34;Crop the image buffer using the supplied bounding box object, zero padding if box is outside image rectangle, update all scene objects&#34;&#34;&#34;
    self.zeropad(bbox.int().width(), bbox.int().height())  # FIXME: this is inefficient
    (dx, dy) = (bbox.width(), bbox.height())
    bbox = bbox.translate(dx, dy)
    self._objectlist = [bb.translate(-dx, -dy) for bb in self._objectlist]        
    self = super()._crop(bbox)        
    (dx, dy) = (bbox.xmin(), bbox.ymin())
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.perceptualhash"><code class="name flex">
<span>def <span class="ident">perceptualhash</span></span>(<span>self, bits=128, asbinary=False, asbytes=False, objmask=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perceptual differential hash function.</p>
<p>This function sets foreground objects to mean color, convert to greyscale, resize with linear interpolation to small image based on desired bit encoding, compute vertical and horizontal gradient signs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bits</code></strong></dt>
<dd>[int]
longer hashes have lower TAR (true accept rate, some near dupes are missed), but lower FAR (false accept rate), shorter hashes have higher TAR (fewer near-dupes are missed) but higher FAR (more non-dupes are declared as dupes).</dd>
<dt><strong><code>objmask</code></strong></dt>
<dd>[bool] if true, replace the foreground object masks with the mean color prior to computing</dd>
<dt><strong><code>asbinary</code></strong></dt>
<dd>[bool] If true, return a binary array</dd>
<dt><strong><code>asbytes</code></strong></dt>
<dd>[bool] if true return a byte array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>A hash string encoding the perceptual hash such that <code><a title="vipy.image.Image.perceptualhash_distance" href="#vipy.image.Image.perceptualhash_distance">Image.perceptualhash_distance()</a></code> can be used to compute a hash distance</dt>
<dt><code>asbytes</code></dt>
<dd>a bytes array</dd>
<dt><code>asbinary</code></dt>
<dd>a numpy binary array
</dd>
</dl>
<div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>Can be used for near duplicate detection of background scenes by unpacking the returned hex string to binary and computing hamming distance, or performing hamming based nearest neighbor indexing.
Equivalently, <code><a title="vipy.image.Image.perceptualhash_distance" href="#vipy.image.Image.perceptualhash_distance">Image.perceptualhash_distance()</a></code>.</li>
<li>The default packed hex output can be converted to binary as: np.unpackbits(bytearray().fromhex( bghash() )) which is equivalent to perceptualhash(asbinary=True)</li>
</ul>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2081-L2107" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def perceptualhash(self, bits=128, asbinary=False, asbytes=False, objmask=False):
    &#34;&#34;&#34;Perceptual differential hash function.

    This function sets foreground objects to mean color, convert to greyscale, resize with linear interpolation to small image based on desired bit encoding, compute vertical and horizontal gradient signs.
    
    Args:
        bits: [int]  longer hashes have lower TAR (true accept rate, some near dupes are missed), but lower FAR (false accept rate), shorter hashes have higher TAR (fewer near-dupes are missed) but higher FAR (more non-dupes are declared as dupes).
        objmask: [bool] if true, replace the foreground object masks with the mean color prior to computing
        asbinary: [bool] If true, return a binary array
        asbytes: [bool] if true return a byte array

    Returns:
        A hash string encoding the perceptual hash such that `vipy.image.Image.perceptualhash_distance` can be used to compute a hash distance
        asbytes: a bytes array
        asbinary: a numpy binary array            

    .. notes::
        - Can be used for near duplicate detection of background scenes by unpacking the returned hex string to binary and computing hamming distance, or performing hamming based nearest neighbor indexing.  Equivalently, `vipy.image.Image.perceptualhash_distance`.
        - The default packed hex output can be converted to binary as: np.unpackbits(bytearray().fromhex( bghash() )) which is equivalent to perceptualhash(asbinary=True)
   
    &#34;&#34;&#34;        
    allowablebits = [2*k*k for k in range(2, 17)]
    assert bits in allowablebits, &#34;Bits must be in %s&#34; % str(allowablebits)
    sq = int(np.ceil(np.sqrt(bits/2.0)))
    im = self.clone() if not objmask else self.clone().meanmask()        
    b = (np.dstack(np.gradient(im.resize(cols=sq+1, rows=sq+1).greyscale().numpy()))[0:-1, 0:-1] &gt; 0).flatten()
    return bytes(np.packbits(b)).hex() if not (asbytes or asbinary) else bytes(np.packbits(b)) if asbytes else b</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.pixelate"><code class="name flex">
<span>def <span class="ident">pixelate</span></span>(<span>self, radius=16)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for pixelmask</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2051-L2053" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pixelate(self, radius=16):
    &#34;&#34;&#34;Alias for pixelmask&#34;&#34;&#34;
    return self.pixelmask(pixelsize=radius)</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.pixelize"><code class="name flex">
<span>def <span class="ident">pixelize</span></span>(<span>self, radius=16)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for pixelmask</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2048-L2050" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pixelize(self, radius=16):
    &#34;&#34;&#34;Alias for pixelmask&#34;&#34;&#34;
    return self.pixelmask(pixelsize=radius)</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.pixelmask"><code class="name flex">
<span>def <span class="ident">pixelmask</span></span>(<span>self, pixelsize=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace pixels within all foreground objects with a privacy preserving pixelated foreground with larger pixels (e.g. like privacy glass)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2041-L2046" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pixelmask(self, pixelsize=8):
    &#34;&#34;&#34;Replace pixels within all foreground objects with a privacy preserving pixelated foreground with larger pixels (e.g. like privacy glass)&#34;&#34;&#34;
    assert pixelsize &gt; 1, &#34;Pixelsize is a scale factor such that pixels within the foreground are pixelsize times larger than the background&#34;
    (img, mask) = (self.numpy(), self.rectangular_mask())  # force writeable
    img[mask &gt; 0] = self.clone().rescale(1.0/pixelsize, interp=&#39;nearest&#39;).resize_like(self, interp=&#39;nearest&#39;).numpy()[mask &gt; 0]  # in-place update
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.rectangular_mask"><code class="name flex">
<span>def <span class="ident">rectangular_mask</span></span>(<span>self, W=None, H=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a binary array of the same size as the image (or using the
provided image width and height (W,H) size to avoid an image load),
with ones inside the bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2003-L2015" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rectangular_mask(self, W=None, H=None):
    &#34;&#34;&#34;Return a binary array of the same size as the image (or using the
    provided image width and height (W,H) size to avoid an image load),
    with ones inside the bounding box&#34;&#34;&#34;
    if (W is None or H is None):
        (H, W) = (int(np.round(self.height())),
                  int(np.round(self.width())))
    immask = np.zeros((H, W)).astype(np.uint8)
    for bb in self._objectlist:
        if bb.hasoverlap(immask):
            bbm = bb.clone().imclip(self.numpy()).int()
            immask[bbm.ymin():bbm.ymax(), bbm.xmin():bbm.xmax()] = 1
    return immask</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, newim, broadcast=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all image values within the bounding box equal to the provided img, triggers load() and imclip()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2063-L2073" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def replace(self, newim, broadcast=False):
    &#34;&#34;&#34;Set all image values within the bounding box equal to the provided img, triggers load() and imclip()&#34;&#34;&#34;
    assert isinstance(newim, vipy.image.Image), &#34;Invalid replacement image - Must be vipy.image.Image&#34;
    img = self.numpy()        
    newimg = newim.array()
    for d in self._objectlist:
        d.imclip(newimg).imclip(img)
        img[int(d.ymin()):int(d.ymax()),
            int(d.xmin()):int(d.xmax())] = newimg[int(d.ymin()):int(d.ymax()),
                                                  int(d.xmin()):int(d.xmax())] if not broadcast else newim.clone().resize(int(d.width()), int(d.height())).array()
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.rescale"><code class="name flex">
<span>def <span class="ident">rescale</span></span>(<span>self, scale=1, interp='bilinear')</span>
</code></dt>
<dd>
<div class="desc"><p>Rescale image buffer and all bounding boxes - Not idempotent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1878-L1882" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rescale(self, scale=1, interp=&#39;bilinear&#39;):
    &#34;&#34;&#34;Rescale image buffer and all bounding boxes - Not idempotent&#34;&#34;&#34;
    self = super().rescale(scale, interp=interp)
    self._objectlist = [bb.rescale(scale) for bb in self._objectlist]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, cols=None, rows=None, height=None, width=None, interp='bilinear')</span>
</code></dt>
<dd>
<div class="desc"><p>Resize image buffer to (height=rows, width=cols) and transform all bounding boxes accordingly.
If cols or rows is None, then scale isotropically</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1884-L1901" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resize(self, cols=None, rows=None, height=None, width=None, interp=&#39;bilinear&#39;):
    &#34;&#34;&#34;Resize image buffer to (height=rows, width=cols) and transform all bounding boxes accordingly.  If cols or rows is None, then scale isotropically&#34;&#34;&#34;
    assert not (cols is not None and width is not None), &#34;Define either width or cols&#34;
    assert not (rows is not None and height is not None), &#34;Define either height or rows&#34;
    rows = rows if height is None else height
    cols = cols if width is None else width        
    assert cols is not None or rows is not None, &#34;Invalid input&#34;
    
    sx = (float(cols) / self.width()) if cols is not None else None
    sy = (float(rows) / self.height()) if rows is not None else None
    sx = sy if sx is None else sx
    sy = sx if sy is None else sy        
    self._objectlist = [bb.scalex(sx).scaley(sy) for bb in self._objectlist]        
    if sx == sy:
        self = super().rescale(sx, interp=interp)  # FIXME: if we call resize here, inheritance is screweed up
    else:
        self = super().resize(cols, rows, interp=interp)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.rot90ccw"><code class="name flex">
<span>def <span class="ident">rot90ccw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate the scene 90 degrees counterclockwise, and update objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1951-L1956" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90ccw(self):
    &#34;&#34;&#34;Rotate the scene 90 degrees counterclockwise, and update objects&#34;&#34;&#34;
    (H,W) = self.shape()
    self.array(np.rot90(self.numpy(), 1))
    self._objectlist = [bb.rot90ccw(H, W) for bb in self._objectlist]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.rot90cw"><code class="name flex">
<span>def <span class="ident">rot90cw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate the scene 90 degrees clockwise, and update objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1944-L1949" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90cw(self):
    &#34;&#34;&#34;Rotate the scene 90 degrees clockwise, and update objects&#34;&#34;&#34;
    (H,W) = self.shape()        
    self.array(np.rot90(self.numpy(), 3))
    self._objectlist = [bb.rot90cw(H, W) for bb in self._objectlist]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.savefig"><code class="name flex">
<span>def <span class="ident">savefig</span></span>(<span>self, outfile=None, categories=None, figure=1, nocaption=False, fontsize=10, boxalpha=0.25, d_category2color={'person': 'green', 'vehicle': 'blue', 'object': 'red'}, captionoffset=(0, 0), dpi=200, textfacecolor='white', textfacealpha=1.0, shortlabel=True, nocaption_withstring=[], timestamp=None, timestampcolor='black', timestampfacecolor='white', mutator=None, timestampoffset=(0, 0))</span>
</code></dt>
<dd>
<div class="desc"><p>Save show() output to given file or return buffer without popping up a window</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2180-L2197" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def savefig(self, outfile=None, categories=None, figure=1, nocaption=False, fontsize=10, boxalpha=0.25, d_category2color={&#39;person&#39;:&#39;green&#39;, &#39;vehicle&#39;:&#39;blue&#39;, &#39;object&#39;:&#39;red&#39;}, captionoffset=(0,0), dpi=200, textfacecolor=&#39;white&#39;, textfacealpha=1.0, shortlabel=True, nocaption_withstring=[], timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None, timestampoffset=(0,0)):
    &#34;&#34;&#34;Save show() output to given file or return buffer without popping up a window&#34;&#34;&#34;
    fignum = figure if figure is not None else 1        
    self.show(categories=categories, figure=fignum, nocaption=nocaption, fontsize=fontsize, boxalpha=boxalpha, 
              d_category2color=d_category2color, captionoffset=captionoffset, nowindow=True, textfacecolor=textfacecolor, 
              textfacealpha=textfacealpha, shortlabel=shortlabel, nocaption_withstring=nocaption_withstring, timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, mutator=mutator, timestampoffset=timestampoffset)
    
    if outfile is None:
        buf = io.BytesIO()
        (W,H) = plt.figure(num=fignum).canvas.get_width_height()  # fast(ish)
        plt.figure(num=fignum).canvas.print_raw(buf)  # fast(ish)
        img = np.frombuffer(buf.getbuffer(), dtype=np.uint8).reshape((H, W, 4))
        if figure is None:
            vipy.show.close(plt.gcf().number)   # memory cleanup (useful for video annotation on last frame)
        return vipy.image.Image(array=img, colorspace=&#39;rgba&#39;)
    else:
        vipy.show.savefig(os.path.abspath(os.path.expanduser(outfile)), figure, dpi=dpi, bbox_inches=&#39;tight&#39;, pad_inches=0)
        return outfile</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.setzero"><code class="name flex">
<span>def <span class="ident">setzero</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2038-L2039" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setzero(self):
    return self.fgmask()</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, categories=None, figure=1, nocaption=False, nocaption_withstring=[], fontsize=10, boxalpha=0.25, d_category2color={'Person': 'green', 'Vehicle': 'blue', 'Object': 'red'}, captionoffset=(0, 0), nowindow=False, textfacecolor='white', textfacealpha=1.0, shortlabel=True, timestamp=None, timestampcolor='black', timestampfacecolor='white', mutator=None, timestampoffset=(0, 0))</span>
</code></dt>
<dd>
<div class="desc"><p>Show scene detection </p>
<h2 id="args">Args</h2>
<ul>
<li>categories: [list]
List of category (or shortlabel) names in the scene to show</li>
<li>fontsize: [int] or [str]: Size of the font, fontsize=int for points, fontsize='NN:scaled' to scale the font relative to the image size</li>
<li>figure: [int] Figure number, show the image in the provided figure=int numbered window</li>
<li>nocaption: [bool]
Show or do not show the text caption in the upper left of the box </li>
<li>nocaption_withstring: [list]:
Do not show captions for those detection categories (or shortlabels) containing any of the strings in the provided list</li>
<li>boxalpha (float, [0,1]):
Set the text box background to be semi-transparent with an alpha</li>
<li>d_category2color (dict):
Define a dictionary of required mapping of specific category() to box colors.
Non-specified categories are assigned a random named color from vipy.show.colorlist()</li>
<li>caption_offset (int, int): The relative position of the caption to the upper right corner of the box.</li>
<li>nowindow (bool):
Display or not display the image</li>
<li>textfacecolor (str): One of the named colors from vipy.show.colorlist() for the color of the textbox background</li>
<li>textfacealpha (float, [0,1]):
The textbox background transparency</li>
<li>shortlabel (bool):
Whether to show the shortlabel or the full category name in the caption</li>
<li>mutator (lambda):
A lambda function with signature lambda im: f(im) which will modify this image prior to show.
Useful for changing labels on the fly</li>
<li>timestampoffset (tuple): (x,y) coordinate offsets to shift the upper left corner timestamp</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L2124-L2157" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def show(self, categories=None, figure=1, nocaption=False, nocaption_withstring=[], fontsize=10, boxalpha=0.25, d_category2color={&#39;Person&#39;:&#39;green&#39;, &#39;Vehicle&#39;:&#39;blue&#39;, &#39;Object&#39;:&#39;red&#39;}, captionoffset=(0,0), nowindow=False, textfacecolor=&#39;white&#39;, textfacealpha=1.0, shortlabel=True, timestamp=None, timestampcolor=&#39;black&#39;, timestampfacecolor=&#39;white&#39;, mutator=None, timestampoffset=(0,0)):
    &#34;&#34;&#34;Show scene detection 

    Args:
       - categories: [list]  List of category (or shortlabel) names in the scene to show
       - fontsize: [int] or [str]: Size of the font, fontsize=int for points, fontsize=&#39;NN:scaled&#39; to scale the font relative to the image size
       - figure: [int] Figure number, show the image in the provided figure=int numbered window
       - nocaption: [bool]  Show or do not show the text caption in the upper left of the box 
       - nocaption_withstring: [list]:  Do not show captions for those detection categories (or shortlabels) containing any of the strings in the provided list
       - boxalpha (float, [0,1]):  Set the text box background to be semi-transparent with an alpha
       - d_category2color (dict):  Define a dictionary of required mapping of specific category() to box colors.  Non-specified categories are assigned a random named color from vipy.show.colorlist()
       - caption_offset (int, int): The relative position of the caption to the upper right corner of the box.
       - nowindow (bool):  Display or not display the image
       - textfacecolor (str): One of the named colors from vipy.show.colorlist() for the color of the textbox background
       - textfacealpha (float, [0,1]):  The textbox background transparency
       - shortlabel (bool):  Whether to show the shortlabel or the full category name in the caption
       - mutator (lambda):  A lambda function with signature lambda im: f(im) which will modify this image prior to show.  Useful for changing labels on the fly
       - timestampoffset (tuple): (x,y) coordinate offsets to shift the upper left corner timestamp
    &#34;&#34;&#34;
    colors = vipy.show.colorlist()
    im = self.clone() if not mutator else mutator(self.clone())
    valid_detections = [obj.clone() for obj in im._objectlist if categories is None or obj.category() in tolist(categories)]  # Detections with valid category
    valid_detections = [obj.imclip(self.numpy()) for obj in valid_detections if obj.hasoverlap(self.numpy())]  # Detections within image rectangle
    valid_detections = [obj.category(obj.shortlabel()) for obj in valid_detections] if shortlabel else valid_detections  # Display name as shortlabel?               
    d_categories2color = {d.category():colors[int(hashlib.sha1(d.category().split(&#39; &#39;)[-1].encode(&#39;utf-8&#39;)).hexdigest(), 16) % len(colors)] for d in valid_detections}   # consistent color mapping by category suffix (space separated)
    d_categories2color.update(d_category2color)  # requested color mapping
    detection_color = [d_categories2color[d.category()] for d in valid_detections]                
    valid_detections = [d if not any([c in d.category() for c in tolist(nocaption_withstring)]) else d.nocategory() for d in valid_detections]  # Detections requested to show without caption
    imdisplay = self.clone().rgb() if self.colorspace() != &#39;rgb&#39; else self  # convert to RGB for show() if necessary
    fontsize_scaled = float(fontsize.split(&#39;:&#39;)[0])*(min(imdisplay.shape())/640.0) if isstring(fontsize) else fontsize
    imdisplay = mutator(imdisplay) if mutator is not None else imdisplay        
    vipy.show.imdetection(imdisplay._array, valid_detections, bboxcolor=detection_color, textcolor=detection_color, fignum=figure, do_caption=(nocaption==False), facealpha=boxalpha, fontsize=fontsize_scaled,
                          captionoffset=captionoffset, nowindow=nowindow, textfacecolor=textfacecolor, textfacealpha=textfacealpha, timestamp=timestamp, timestampcolor=timestampcolor, timestampfacecolor=timestampfacecolor, timestampoffset=timestampoffset)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.uncrop"><code class="name flex">
<span>def <span class="ident">uncrop</span></span>(<span>self, bb, shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Uncrop a previous crop(bb) called with the supplied bb=BoundingBox(), and zeropad to shape=(H,W)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1853-L1856" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def uncrop(self, bb, shape):
    &#34;&#34;&#34;Uncrop a previous crop(bb) called with the supplied bb=BoundingBox(), and zeropad to shape=(H,W)&#34;&#34;&#34;
    super().uncrop(bb, shape)
    return self.objectmap(lambda o: o.translate(bb.xmin(), bb.ymin()))</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, other, miniou=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine the objects of the scene with other and self with no duplicate checking unless miniou is not None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1847-L1851" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def union(self, other, miniou=None):
    &#34;&#34;&#34;Combine the objects of the scene with other and self with no duplicate checking unless miniou is not None&#34;&#34;&#34;
    if isinstance(other, Scene):
        self.objects(self.objects()+other.objects())
    return self</code></pre>
</details>
</dd>
<dt id="vipy.image.Scene.zeropad"><code class="name flex">
<span>def <span class="ident">zeropad</span></span>(<span>self, padwidth, padheight)</span>
</code></dt>
<dd>
<div class="desc"><p>Zero pad image with padwidth cols before and after and padheight rows before and after, then update bounding box offsets</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/2ff555b8a23b3e6299d0a41de1f179f6005da60c/vipy/image.py#L1928-L1934" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def zeropad(self, padwidth, padheight):
    &#34;&#34;&#34;Zero pad image with padwidth cols before and after and padheight rows before and after, then update bounding box offsets&#34;&#34;&#34;
    self = super().zeropad(padwidth, padheight)
    dx = padwidth[0] if isinstance(padwidth, tuple) and len(padwidth) == 2 else padwidth
    dy = padheight[0] if isinstance(padheight, tuple) and len(padheight) == 2 else padheight
    self._objectlist = [bb.translate(dx, dy) for bb in self._objectlist]
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vipy.image.ImageCategory" href="#vipy.image.ImageCategory">ImageCategory</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.image.ImageCategory.abspath" href="#vipy.image.Image.abspath">abspath</a></code></li>
<li><code><a title="vipy.image.ImageCategory.affine_transform" href="#vipy.image.Image.affine_transform">affine_transform</a></code></li>
<li><code><a title="vipy.image.ImageCategory.alpha" href="#vipy.image.Image.alpha">alpha</a></code></li>
<li><code><a title="vipy.image.ImageCategory.alphapad" href="#vipy.image.Image.alphapad">alphapad</a></code></li>
<li><code><a title="vipy.image.ImageCategory.area" href="#vipy.image.Image.area">area</a></code></li>
<li><code><a title="vipy.image.ImageCategory.array" href="#vipy.image.Image.array">array</a></code></li>
<li><code><a title="vipy.image.ImageCategory.ascii" href="#vipy.image.Image.ascii">ascii</a></code></li>
<li><code><a title="vipy.image.ImageCategory.aspectratio" href="#vipy.image.Image.aspectratio">aspectratio</a></code></li>
<li><code><a title="vipy.image.ImageCategory.base64" href="#vipy.image.Image.base64">base64</a></code></li>
<li><code><a title="vipy.image.ImageCategory.bgr" href="#vipy.image.Image.bgr">bgr</a></code></li>
<li><code><a title="vipy.image.ImageCategory.bgra" href="#vipy.image.Image.bgra">bgra</a></code></li>
<li><code><a title="vipy.image.ImageCategory.bias" href="#vipy.image.Image.bias">bias</a></code></li>
<li><code><a title="vipy.image.ImageCategory.blue" href="#vipy.image.Image.blue">blue</a></code></li>
<li><code><a title="vipy.image.ImageCategory.blur" href="#vipy.image.Image.blur">blur</a></code></li>
<li><code><a title="vipy.image.ImageCategory.bone" href="#vipy.image.Image.bone">bone</a></code></li>
<li><code><a title="vipy.image.ImageCategory.border_mask" href="#vipy.image.Image.border_mask">border_mask</a></code></li>
<li><code><a title="vipy.image.ImageCategory.canload" href="#vipy.image.Image.canload">canload</a></code></li>
<li><code><a title="vipy.image.ImageCategory.cast" href="#vipy.image.Image.cast">cast</a></code></li>
<li><code><a title="vipy.image.ImageCategory.category" href="#vipy.image.ImageCategory.category">category</a></code></li>
<li><code><a title="vipy.image.ImageCategory.centercrop" href="#vipy.image.Image.centercrop">centercrop</a></code></li>
<li><code><a title="vipy.image.ImageCategory.centerpixel" href="#vipy.image.Image.centerpixel">centerpixel</a></code></li>
<li><code><a title="vipy.image.ImageCategory.centroid" href="#vipy.image.Image.centroid">centroid</a></code></li>
<li><code><a title="vipy.image.ImageCategory.channel" href="#vipy.image.Image.channel">channel</a></code></li>
<li><code><a title="vipy.image.ImageCategory.channels" href="#vipy.image.Image.channels">channels</a></code></li>
<li><code><a title="vipy.image.ImageCategory.clone" href="#vipy.image.Image.clone">clone</a></code></li>
<li><code><a title="vipy.image.ImageCategory.close" href="#vipy.image.Image.close">close</a></code></li>
<li><code><a title="vipy.image.ImageCategory.closeall" href="#vipy.image.Image.closeall">closeall</a></code></li>
<li><code><a title="vipy.image.ImageCategory.colorspace" href="#vipy.image.Image.colorspace">colorspace</a></code></li>
<li><code><a title="vipy.image.ImageCategory.dict" href="#vipy.image.Image.dict">dict</a></code></li>
<li><code><a title="vipy.image.ImageCategory.downcast" href="#vipy.image.Image.downcast">downcast</a></code></li>
<li><code><a title="vipy.image.ImageCategory.download" href="#vipy.image.Image.download">download</a></code></li>
<li><code><a title="vipy.image.ImageCategory.filename" href="#vipy.image.Image.filename">filename</a></code></li>
<li><code><a title="vipy.image.ImageCategory.filesize" href="#vipy.image.Image.filesize">filesize</a></code></li>
<li><code><a title="vipy.image.ImageCategory.float" href="#vipy.image.Image.float">float</a></code></li>
<li><code><a title="vipy.image.ImageCategory.flush" href="#vipy.image.Image.flush">flush</a></code></li>
<li><code><a title="vipy.image.ImageCategory.from_json" href="#vipy.image.Image.from_json">from_json</a></code></li>
<li><code><a title="vipy.image.ImageCategory.fromarray" href="#vipy.image.Image.fromarray">fromarray</a></code></li>
<li><code><a title="vipy.image.ImageCategory.fromtorch" href="#vipy.image.Image.fromtorch">fromtorch</a></code></li>
<li><code><a title="vipy.image.ImageCategory.gain" href="#vipy.image.Image.gain">gain</a></code></li>
<li><code><a title="vipy.image.ImageCategory.getattribute" href="#vipy.image.Image.getattribute">getattribute</a></code></li>
<li><code><a title="vipy.image.ImageCategory.gray" href="#vipy.image.Image.gray">gray</a></code></li>
<li><code><a title="vipy.image.ImageCategory.grayscale" href="#vipy.image.Image.grayscale">grayscale</a></code></li>
<li><code><a title="vipy.image.ImageCategory.green" href="#vipy.image.Image.green">green</a></code></li>
<li><code><a title="vipy.image.ImageCategory.grey" href="#vipy.image.Image.grey">grey</a></code></li>
<li><code><a title="vipy.image.ImageCategory.greyscale" href="#vipy.image.Image.greyscale">greyscale</a></code></li>
<li><code><a title="vipy.image.ImageCategory.height" href="#vipy.image.Image.height">height</a></code></li>
<li><code><a title="vipy.image.ImageCategory.hot" href="#vipy.image.Image.hot">hot</a></code></li>
<li><code><a title="vipy.image.ImageCategory.hsv" href="#vipy.image.Image.hsv">hsv</a></code></li>
<li><code><a title="vipy.image.ImageCategory.html" href="#vipy.image.Image.html">html</a></code></li>
<li><code><a title="vipy.image.ImageCategory.imagebox" href="#vipy.image.Image.imagebox">imagebox</a></code></li>
<li><code><a title="vipy.image.ImageCategory.intensity" href="#vipy.image.Image.intensity">intensity</a></code></li>
<li><code><a title="vipy.image.ImageCategory.iscolor" href="#vipy.image.Image.iscolor">iscolor</a></code></li>
<li><code><a title="vipy.image.ImageCategory.isgrey" href="#vipy.image.Image.isgrey">isgrey</a></code></li>
<li><code><a title="vipy.image.ImageCategory.isloaded" href="#vipy.image.Image.isloaded">isloaded</a></code></li>
<li><code><a title="vipy.image.ImageCategory.isluminance" href="#vipy.image.Image.isluminance">isluminance</a></code></li>
<li><code><a title="vipy.image.ImageCategory.istransparent" href="#vipy.image.Image.istransparent">istransparent</a></code></li>
<li><code><a title="vipy.image.ImageCategory.jet" href="#vipy.image.Image.jet">jet</a></code></li>
<li><code><a title="vipy.image.ImageCategory.label" href="#vipy.image.ImageCategory.label">label</a></code></li>
<li><code><a title="vipy.image.ImageCategory.load" href="#vipy.image.Image.load">load</a></code></li>
<li><code><a title="vipy.image.ImageCategory.loader" href="#vipy.image.Image.loader">loader</a></code></li>
<li><code><a title="vipy.image.ImageCategory.lum" href="#vipy.image.Image.lum">lum</a></code></li>
<li><code><a title="vipy.image.ImageCategory.luminance" href="#vipy.image.Image.luminance">luminance</a></code></li>
<li><code><a title="vipy.image.ImageCategory.map" href="#vipy.image.Image.map">map</a></code></li>
<li><code><a title="vipy.image.ImageCategory.mat2gray" href="#vipy.image.Image.mat2gray">mat2gray</a></code></li>
<li><code><a title="vipy.image.ImageCategory.maxmatte" href="#vipy.image.Image.maxmatte">maxmatte</a></code></li>
<li><code><a title="vipy.image.ImageCategory.maxsquare" href="#vipy.image.Image.maxsquare">maxsquare</a></code></li>
<li><code><a title="vipy.image.ImageCategory.mean" href="#vipy.image.Image.mean">mean</a></code></li>
<li><code><a title="vipy.image.ImageCategory.meanchannel" href="#vipy.image.Image.meanchannel">meanchannel</a></code></li>
<li><code><a title="vipy.image.ImageCategory.minsquare" href="#vipy.image.Image.minsquare">minsquare</a></code></li>
<li><code><a title="vipy.image.ImageCategory.normalize" href="#vipy.image.Image.normalize">normalize</a></code></li>
<li><code><a title="vipy.image.ImageCategory.numpy" href="#vipy.image.Image.numpy">numpy</a></code></li>
<li><code><a title="vipy.image.ImageCategory.perceptualhash_distance" href="#vipy.image.Image.perceptualhash_distance">perceptualhash_distance</a></code></li>
<li><code><a title="vipy.image.ImageCategory.pil" href="#vipy.image.Image.pil">pil</a></code></li>
<li><code><a title="vipy.image.ImageCategory.pkl" href="#vipy.image.Image.pkl">pkl</a></code></li>
<li><code><a title="vipy.image.ImageCategory.pklif" href="#vipy.image.Image.pklif">pklif</a></code></li>
<li><code><a title="vipy.image.ImageCategory.print" href="#vipy.image.Image.print">print</a></code></li>
<li><code><a title="vipy.image.ImageCategory.probability" href="#vipy.image.ImageCategory.probability">probability</a></code></li>
<li><code><a title="vipy.image.ImageCategory.rainbow" href="#vipy.image.Image.rainbow">rainbow</a></code></li>
<li><code><a title="vipy.image.ImageCategory.red" href="#vipy.image.Image.red">red</a></code></li>
<li><code><a title="vipy.image.ImageCategory.reload" href="#vipy.image.Image.reload">reload</a></code></li>
<li><code><a title="vipy.image.ImageCategory.relpath" href="#vipy.image.Image.relpath">relpath</a></code></li>
<li><code><a title="vipy.image.ImageCategory.resize_like" href="#vipy.image.Image.resize_like">resize_like</a></code></li>
<li><code><a title="vipy.image.ImageCategory.restore" href="#vipy.image.Image.restore">restore</a></code></li>
<li><code><a title="vipy.image.ImageCategory.rgb" href="#vipy.image.Image.rgb">rgb</a></code></li>
<li><code><a title="vipy.image.ImageCategory.rgba" href="#vipy.image.Image.rgba">rgba</a></code></li>
<li><code><a title="vipy.image.ImageCategory.rotate" href="#vipy.image.Image.rotate">rotate</a></code></li>
<li><code><a title="vipy.image.ImageCategory.sanitize" href="#vipy.image.Image.sanitize">sanitize</a></code></li>
<li><code><a title="vipy.image.ImageCategory.saturate" href="#vipy.image.Image.saturate">saturate</a></code></li>
<li><code><a title="vipy.image.ImageCategory.save" href="#vipy.image.Image.save">save</a></code></li>
<li><code><a title="vipy.image.ImageCategory.saveas" href="#vipy.image.Image.saveas">saveas</a></code></li>
<li><code><a title="vipy.image.ImageCategory.saveastmp" href="#vipy.image.Image.saveastmp">saveastmp</a></code></li>
<li><code><a title="vipy.image.ImageCategory.savetmp" href="#vipy.image.Image.savetmp">savetmp</a></code></li>
<li><code><a title="vipy.image.ImageCategory.score" href="#vipy.image.ImageCategory.score">score</a></code></li>
<li><code><a title="vipy.image.ImageCategory.setattribute" href="#vipy.image.Image.setattribute">setattribute</a></code></li>
<li><code><a title="vipy.image.ImageCategory.setattributes" href="#vipy.image.Image.setattributes">setattributes</a></code></li>
<li><code><a title="vipy.image.ImageCategory.shape" href="#vipy.image.Image.shape">shape</a></code></li>
<li><code><a title="vipy.image.ImageCategory.splat" href="#vipy.image.Image.splat">splat</a></code></li>
<li><code><a title="vipy.image.ImageCategory.store" href="#vipy.image.Image.store">store</a></code></li>
<li><code><a title="vipy.image.ImageCategory.tile" href="#vipy.image.Image.tile">tile</a></code></li>
<li><code><a title="vipy.image.ImageCategory.tonumpy" href="#vipy.image.Image.tonumpy">tonumpy</a></code></li>
<li><code><a title="vipy.image.ImageCategory.torch" href="#vipy.image.Image.torch">torch</a></code></li>
<li><code><a title="vipy.image.ImageCategory.unstore" href="#vipy.image.Image.unstore">unstore</a></code></li>
<li><code><a title="vipy.image.ImageCategory.untile" href="#vipy.image.Image.untile">untile</a></code></li>
<li><code><a title="vipy.image.ImageCategory.uri" href="#vipy.image.Image.uri">uri</a></code></li>
<li><code><a title="vipy.image.ImageCategory.url" href="#vipy.image.Image.url">url</a></code></li>
<li><code><a title="vipy.image.ImageCategory.width" href="#vipy.image.Image.width">width</a></code></li>
<li><code><a title="vipy.image.ImageCategory.zeropadlike" href="#vipy.image.Image.zeropadlike">zeropadlike</a></code></li>
<li><code><a title="vipy.image.ImageCategory.zeros" href="#vipy.image.Image.zeros">zeros</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="VIPY" href="https://github.com/visym/vipy/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="60">
</a>
<h1 style="font-size:200%;"><b>VIPY:</b> Visual Dataset Transformation</h1>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = './doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vipy" href="index.html">vipy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vipy.image.Owl" href="#vipy.image.Owl">Owl</a></code></li>
<li><code><a title="vipy.image.RandomImage" href="#vipy.image.RandomImage">RandomImage</a></code></li>
<li><code><a title="vipy.image.RandomImageDetection" href="#vipy.image.RandomImageDetection">RandomImageDetection</a></code></li>
<li><code><a title="vipy.image.RandomScene" href="#vipy.image.RandomScene">RandomScene</a></code></li>
<li><code><a title="vipy.image.mutator_capitalize" href="#vipy.image.mutator_capitalize">mutator_capitalize</a></code></li>
<li><code><a title="vipy.image.mutator_show_activityonly" href="#vipy.image.mutator_show_activityonly">mutator_show_activityonly</a></code></li>
<li><code><a title="vipy.image.mutator_show_jointlabel" href="#vipy.image.mutator_show_jointlabel">mutator_show_jointlabel</a></code></li>
<li><code><a title="vipy.image.mutator_show_noun_only" href="#vipy.image.mutator_show_noun_only">mutator_show_noun_only</a></code></li>
<li><code><a title="vipy.image.mutator_show_noun_or_verb" href="#vipy.image.mutator_show_noun_or_verb">mutator_show_noun_or_verb</a></code></li>
<li><code><a title="vipy.image.mutator_show_nounonly" href="#vipy.image.mutator_show_nounonly">mutator_show_nounonly</a></code></li>
<li><code><a title="vipy.image.mutator_show_trackid" href="#vipy.image.mutator_show_trackid">mutator_show_trackid</a></code></li>
<li><code><a title="vipy.image.mutator_show_trackindex" href="#vipy.image.mutator_show_trackindex">mutator_show_trackindex</a></code></li>
<li><code><a title="vipy.image.mutator_show_trackindex_activityonly" href="#vipy.image.mutator_show_trackindex_activityonly">mutator_show_trackindex_activityonly</a></code></li>
<li><code><a title="vipy.image.mutator_show_trackindex_verbonly" href="#vipy.image.mutator_show_trackindex_verbonly">mutator_show_trackindex_verbonly</a></code></li>
<li><code><a title="vipy.image.mutator_show_trackonly" href="#vipy.image.mutator_show_trackonly">mutator_show_trackonly</a></code></li>
<li><code><a title="vipy.image.mutator_show_userstring" href="#vipy.image.mutator_show_userstring">mutator_show_userstring</a></code></li>
<li><code><a title="vipy.image.mutator_show_verb_only" href="#vipy.image.mutator_show_verb_only">mutator_show_verb_only</a></code></li>
<li><code><a title="vipy.image.owl" href="#vipy.image.owl">owl</a></code></li>
<li><code><a title="vipy.image.people" href="#vipy.image.people">people</a></code></li>
<li><code><a title="vipy.image.show" href="#vipy.image.show">show</a></code></li>
<li><code><a title="vipy.image.squareowl" href="#vipy.image.squareowl">squareowl</a></code></li>
<li><code><a title="vipy.image.vehicles" href="#vipy.image.vehicles">vehicles</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vipy.image.Image" href="#vipy.image.Image">Image</a></code></h4>
<ul class="">
<li><code><a title="vipy.image.Image.abspath" href="#vipy.image.Image.abspath">abspath</a></code></li>
<li><code><a title="vipy.image.Image.affine_transform" href="#vipy.image.Image.affine_transform">affine_transform</a></code></li>
<li><code><a title="vipy.image.Image.alpha" href="#vipy.image.Image.alpha">alpha</a></code></li>
<li><code><a title="vipy.image.Image.alphapad" href="#vipy.image.Image.alphapad">alphapad</a></code></li>
<li><code><a title="vipy.image.Image.annotate" href="#vipy.image.Image.annotate">annotate</a></code></li>
<li><code><a title="vipy.image.Image.area" href="#vipy.image.Image.area">area</a></code></li>
<li><code><a title="vipy.image.Image.array" href="#vipy.image.Image.array">array</a></code></li>
<li><code><a title="vipy.image.Image.ascii" href="#vipy.image.Image.ascii">ascii</a></code></li>
<li><code><a title="vipy.image.Image.aspectratio" href="#vipy.image.Image.aspectratio">aspectratio</a></code></li>
<li><code><a title="vipy.image.Image.base64" href="#vipy.image.Image.base64">base64</a></code></li>
<li><code><a title="vipy.image.Image.bgr" href="#vipy.image.Image.bgr">bgr</a></code></li>
<li><code><a title="vipy.image.Image.bgra" href="#vipy.image.Image.bgra">bgra</a></code></li>
<li><code><a title="vipy.image.Image.bias" href="#vipy.image.Image.bias">bias</a></code></li>
<li><code><a title="vipy.image.Image.blue" href="#vipy.image.Image.blue">blue</a></code></li>
<li><code><a title="vipy.image.Image.blur" href="#vipy.image.Image.blur">blur</a></code></li>
<li><code><a title="vipy.image.Image.bone" href="#vipy.image.Image.bone">bone</a></code></li>
<li><code><a title="vipy.image.Image.border_mask" href="#vipy.image.Image.border_mask">border_mask</a></code></li>
<li><code><a title="vipy.image.Image.canload" href="#vipy.image.Image.canload">canload</a></code></li>
<li><code><a title="vipy.image.Image.cast" href="#vipy.image.Image.cast">cast</a></code></li>
<li><code><a title="vipy.image.Image.centercrop" href="#vipy.image.Image.centercrop">centercrop</a></code></li>
<li><code><a title="vipy.image.Image.centerpixel" href="#vipy.image.Image.centerpixel">centerpixel</a></code></li>
<li><code><a title="vipy.image.Image.centersquare" href="#vipy.image.Image.centersquare">centersquare</a></code></li>
<li><code><a title="vipy.image.Image.centroid" href="#vipy.image.Image.centroid">centroid</a></code></li>
<li><code><a title="vipy.image.Image.channel" href="#vipy.image.Image.channel">channel</a></code></li>
<li><code><a title="vipy.image.Image.channels" href="#vipy.image.Image.channels">channels</a></code></li>
<li><code><a title="vipy.image.Image.clone" href="#vipy.image.Image.clone">clone</a></code></li>
<li><code><a title="vipy.image.Image.close" href="#vipy.image.Image.close">close</a></code></li>
<li><code><a title="vipy.image.Image.closeall" href="#vipy.image.Image.closeall">closeall</a></code></li>
<li><code><a title="vipy.image.Image.colorspace" href="#vipy.image.Image.colorspace">colorspace</a></code></li>
<li><code><a title="vipy.image.Image.cornercrop" href="#vipy.image.Image.cornercrop">cornercrop</a></code></li>
<li><code><a title="vipy.image.Image.crop" href="#vipy.image.Image.crop">crop</a></code></li>
<li><code><a title="vipy.image.Image.delattribute" href="#vipy.image.Image.delattribute">delattribute</a></code></li>
<li><code><a title="vipy.image.Image.dict" href="#vipy.image.Image.dict">dict</a></code></li>
<li><code><a title="vipy.image.Image.downcast" href="#vipy.image.Image.downcast">downcast</a></code></li>
<li><code><a title="vipy.image.Image.download" href="#vipy.image.Image.download">download</a></code></li>
<li><code><a title="vipy.image.Image.filename" href="#vipy.image.Image.filename">filename</a></code></li>
<li><code><a title="vipy.image.Image.filesize" href="#vipy.image.Image.filesize">filesize</a></code></li>
<li><code><a title="vipy.image.Image.fliplr" href="#vipy.image.Image.fliplr">fliplr</a></code></li>
<li><code><a title="vipy.image.Image.flipud" href="#vipy.image.Image.flipud">flipud</a></code></li>
<li><code><a title="vipy.image.Image.float" href="#vipy.image.Image.float">float</a></code></li>
<li><code><a title="vipy.image.Image.flush" href="#vipy.image.Image.flush">flush</a></code></li>
<li><code><a title="vipy.image.Image.from_json" href="#vipy.image.Image.from_json">from_json</a></code></li>
<li><code><a title="vipy.image.Image.fromarray" href="#vipy.image.Image.fromarray">fromarray</a></code></li>
<li><code><a title="vipy.image.Image.fromtorch" href="#vipy.image.Image.fromtorch">fromtorch</a></code></li>
<li><code><a title="vipy.image.Image.gain" href="#vipy.image.Image.gain">gain</a></code></li>
<li><code><a title="vipy.image.Image.getattribute" href="#vipy.image.Image.getattribute">getattribute</a></code></li>
<li><code><a title="vipy.image.Image.gray" href="#vipy.image.Image.gray">gray</a></code></li>
<li><code><a title="vipy.image.Image.grayscale" href="#vipy.image.Image.grayscale">grayscale</a></code></li>
<li><code><a title="vipy.image.Image.green" href="#vipy.image.Image.green">green</a></code></li>
<li><code><a title="vipy.image.Image.grey" href="#vipy.image.Image.grey">grey</a></code></li>
<li><code><a title="vipy.image.Image.greyscale" href="#vipy.image.Image.greyscale">greyscale</a></code></li>
<li><code><a title="vipy.image.Image.hasattribute" href="#vipy.image.Image.hasattribute">hasattribute</a></code></li>
<li><code><a title="vipy.image.Image.hasfilename" href="#vipy.image.Image.hasfilename">hasfilename</a></code></li>
<li><code><a title="vipy.image.Image.hasurl" href="#vipy.image.Image.hasurl">hasurl</a></code></li>
<li><code><a title="vipy.image.Image.height" href="#vipy.image.Image.height">height</a></code></li>
<li><code><a title="vipy.image.Image.hot" href="#vipy.image.Image.hot">hot</a></code></li>
<li><code><a title="vipy.image.Image.hsv" href="#vipy.image.Image.hsv">hsv</a></code></li>
<li><code><a title="vipy.image.Image.html" href="#vipy.image.Image.html">html</a></code></li>
<li><code><a title="vipy.image.Image.imagebox" href="#vipy.image.Image.imagebox">imagebox</a></code></li>
<li><code><a title="vipy.image.Image.intensity" href="#vipy.image.Image.intensity">intensity</a></code></li>
<li><code><a title="vipy.image.Image.iscolor" href="#vipy.image.Image.iscolor">iscolor</a></code></li>
<li><code><a title="vipy.image.Image.isgrey" href="#vipy.image.Image.isgrey">isgrey</a></code></li>
<li><code><a title="vipy.image.Image.isloaded" href="#vipy.image.Image.isloaded">isloaded</a></code></li>
<li><code><a title="vipy.image.Image.isluminance" href="#vipy.image.Image.isluminance">isluminance</a></code></li>
<li><code><a title="vipy.image.Image.istransparent" href="#vipy.image.Image.istransparent">istransparent</a></code></li>
<li><code><a title="vipy.image.Image.jet" href="#vipy.image.Image.jet">jet</a></code></li>
<li><code><a title="vipy.image.Image.json" href="#vipy.image.Image.json">json</a></code></li>
<li><code><a title="vipy.image.Image.load" href="#vipy.image.Image.load">load</a></code></li>
<li><code><a title="vipy.image.Image.loader" href="#vipy.image.Image.loader">loader</a></code></li>
<li><code><a title="vipy.image.Image.lum" href="#vipy.image.Image.lum">lum</a></code></li>
<li><code><a title="vipy.image.Image.luminance" href="#vipy.image.Image.luminance">luminance</a></code></li>
<li><code><a title="vipy.image.Image.map" href="#vipy.image.Image.map">map</a></code></li>
<li><code><a title="vipy.image.Image.mat2gray" href="#vipy.image.Image.mat2gray">mat2gray</a></code></li>
<li><code><a title="vipy.image.Image.max" href="#vipy.image.Image.max">max</a></code></li>
<li><code><a title="vipy.image.Image.maxdim" href="#vipy.image.Image.maxdim">maxdim</a></code></li>
<li><code><a title="vipy.image.Image.maxmatte" href="#vipy.image.Image.maxmatte">maxmatte</a></code></li>
<li><code><a title="vipy.image.Image.maxsquare" href="#vipy.image.Image.maxsquare">maxsquare</a></code></li>
<li><code><a title="vipy.image.Image.mean" href="#vipy.image.Image.mean">mean</a></code></li>
<li><code><a title="vipy.image.Image.meanchannel" href="#vipy.image.Image.meanchannel">meanchannel</a></code></li>
<li><code><a title="vipy.image.Image.meanpad" href="#vipy.image.Image.meanpad">meanpad</a></code></li>
<li><code><a title="vipy.image.Image.min" href="#vipy.image.Image.min">min</a></code></li>
<li><code><a title="vipy.image.Image.mindim" href="#vipy.image.Image.mindim">mindim</a></code></li>
<li><code><a title="vipy.image.Image.minsquare" href="#vipy.image.Image.minsquare">minsquare</a></code></li>
<li><code><a title="vipy.image.Image.nofilename" href="#vipy.image.Image.nofilename">nofilename</a></code></li>
<li><code><a title="vipy.image.Image.normalize" href="#vipy.image.Image.normalize">normalize</a></code></li>
<li><code><a title="vipy.image.Image.nourl" href="#vipy.image.Image.nourl">nourl</a></code></li>
<li><code><a title="vipy.image.Image.numpy" href="#vipy.image.Image.numpy">numpy</a></code></li>
<li><code><a title="vipy.image.Image.perceptualhash" href="#vipy.image.Image.perceptualhash">perceptualhash</a></code></li>
<li><code><a title="vipy.image.Image.perceptualhash_distance" href="#vipy.image.Image.perceptualhash_distance">perceptualhash_distance</a></code></li>
<li><code><a title="vipy.image.Image.pil" href="#vipy.image.Image.pil">pil</a></code></li>
<li><code><a title="vipy.image.Image.pkl" href="#vipy.image.Image.pkl">pkl</a></code></li>
<li><code><a title="vipy.image.Image.pklif" href="#vipy.image.Image.pklif">pklif</a></code></li>
<li><code><a title="vipy.image.Image.print" href="#vipy.image.Image.print">print</a></code></li>
<li><code><a title="vipy.image.Image.rainbow" href="#vipy.image.Image.rainbow">rainbow</a></code></li>
<li><code><a title="vipy.image.Image.red" href="#vipy.image.Image.red">red</a></code></li>
<li><code><a title="vipy.image.Image.reload" href="#vipy.image.Image.reload">reload</a></code></li>
<li><code><a title="vipy.image.Image.relpath" href="#vipy.image.Image.relpath">relpath</a></code></li>
<li><code><a title="vipy.image.Image.rescale" href="#vipy.image.Image.rescale">rescale</a></code></li>
<li><code><a title="vipy.image.Image.resize" href="#vipy.image.Image.resize">resize</a></code></li>
<li><code><a title="vipy.image.Image.resize_like" href="#vipy.image.Image.resize_like">resize_like</a></code></li>
<li><code><a title="vipy.image.Image.restore" href="#vipy.image.Image.restore">restore</a></code></li>
<li><code><a title="vipy.image.Image.rgb" href="#vipy.image.Image.rgb">rgb</a></code></li>
<li><code><a title="vipy.image.Image.rgba" href="#vipy.image.Image.rgba">rgba</a></code></li>
<li><code><a title="vipy.image.Image.rot90ccw" href="#vipy.image.Image.rot90ccw">rot90ccw</a></code></li>
<li><code><a title="vipy.image.Image.rot90cw" href="#vipy.image.Image.rot90cw">rot90cw</a></code></li>
<li><code><a title="vipy.image.Image.rotate" href="#vipy.image.Image.rotate">rotate</a></code></li>
<li><code><a title="vipy.image.Image.sanitize" href="#vipy.image.Image.sanitize">sanitize</a></code></li>
<li><code><a title="vipy.image.Image.saturate" href="#vipy.image.Image.saturate">saturate</a></code></li>
<li><code><a title="vipy.image.Image.save" href="#vipy.image.Image.save">save</a></code></li>
<li><code><a title="vipy.image.Image.saveas" href="#vipy.image.Image.saveas">saveas</a></code></li>
<li><code><a title="vipy.image.Image.saveastmp" href="#vipy.image.Image.saveastmp">saveastmp</a></code></li>
<li><code><a title="vipy.image.Image.savefig" href="#vipy.image.Image.savefig">savefig</a></code></li>
<li><code><a title="vipy.image.Image.savetmp" href="#vipy.image.Image.savetmp">savetmp</a></code></li>
<li><code><a title="vipy.image.Image.setattribute" href="#vipy.image.Image.setattribute">setattribute</a></code></li>
<li><code><a title="vipy.image.Image.setattributes" href="#vipy.image.Image.setattributes">setattributes</a></code></li>
<li><code><a title="vipy.image.Image.shape" href="#vipy.image.Image.shape">shape</a></code></li>
<li><code><a title="vipy.image.Image.show" href="#vipy.image.Image.show">show</a></code></li>
<li><code><a title="vipy.image.Image.splat" href="#vipy.image.Image.splat">splat</a></code></li>
<li><code><a title="vipy.image.Image.stats" href="#vipy.image.Image.stats">stats</a></code></li>
<li><code><a title="vipy.image.Image.store" href="#vipy.image.Image.store">store</a></code></li>
<li><code><a title="vipy.image.Image.sum" href="#vipy.image.Image.sum">sum</a></code></li>
<li><code><a title="vipy.image.Image.tile" href="#vipy.image.Image.tile">tile</a></code></li>
<li><code><a title="vipy.image.Image.tonumpy" href="#vipy.image.Image.tonumpy">tonumpy</a></code></li>
<li><code><a title="vipy.image.Image.torch" href="#vipy.image.Image.torch">torch</a></code></li>
<li><code><a title="vipy.image.Image.uncrop" href="#vipy.image.Image.uncrop">uncrop</a></code></li>
<li><code><a title="vipy.image.Image.union" href="#vipy.image.Image.union">union</a></code></li>
<li><code><a title="vipy.image.Image.unstore" href="#vipy.image.Image.unstore">unstore</a></code></li>
<li><code><a title="vipy.image.Image.untile" href="#vipy.image.Image.untile">untile</a></code></li>
<li><code><a title="vipy.image.Image.uri" href="#vipy.image.Image.uri">uri</a></code></li>
<li><code><a title="vipy.image.Image.url" href="#vipy.image.Image.url">url</a></code></li>
<li><code><a title="vipy.image.Image.width" href="#vipy.image.Image.width">width</a></code></li>
<li><code><a title="vipy.image.Image.zeropad" href="#vipy.image.Image.zeropad">zeropad</a></code></li>
<li><code><a title="vipy.image.Image.zeropadlike" href="#vipy.image.Image.zeropadlike">zeropadlike</a></code></li>
<li><code><a title="vipy.image.Image.zeros" href="#vipy.image.Image.zeros">zeros</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.image.ImageCategory" href="#vipy.image.ImageCategory">ImageCategory</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.image.ImageCategory.category" href="#vipy.image.ImageCategory.category">category</a></code></li>
<li><code><a title="vipy.image.ImageCategory.is_" href="#vipy.image.ImageCategory.is_">is_</a></code></li>
<li><code><a title="vipy.image.ImageCategory.is_not" href="#vipy.image.ImageCategory.is_not">is_not</a></code></li>
<li><code><a title="vipy.image.ImageCategory.json" href="#vipy.image.ImageCategory.json">json</a></code></li>
<li><code><a title="vipy.image.ImageCategory.label" href="#vipy.image.ImageCategory.label">label</a></code></li>
<li><code><a title="vipy.image.ImageCategory.nocategory" href="#vipy.image.ImageCategory.nocategory">nocategory</a></code></li>
<li><code><a title="vipy.image.ImageCategory.probability" href="#vipy.image.ImageCategory.probability">probability</a></code></li>
<li><code><a title="vipy.image.ImageCategory.score" href="#vipy.image.ImageCategory.score">score</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.image.ImageDetection" href="#vipy.image.ImageDetection">ImageDetection</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.image.ImageDetection.asbbox" href="#vipy.image.ImageDetection.asbbox">asbbox</a></code></li>
<li><code><a title="vipy.image.ImageDetection.asimage" href="#vipy.image.ImageDetection.asimage">asimage</a></code></li>
<li><code><a title="vipy.image.ImageDetection.boundingbox" href="#vipy.image.ImageDetection.boundingbox">boundingbox</a></code></li>
<li><code><a title="vipy.image.ImageDetection.boxmap" href="#vipy.image.ImageDetection.boxmap">boxmap</a></code></li>
<li><code><a title="vipy.image.ImageDetection.crop" href="#vipy.image.ImageDetection.crop">crop</a></code></li>
<li><code><a title="vipy.image.ImageDetection.detection" href="#vipy.image.ImageDetection.detection">detection</a></code></li>
<li><code><a title="vipy.image.ImageDetection.isinterior" href="#vipy.image.ImageDetection.isinterior">isinterior</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.image.Scene" href="#vipy.image.Scene">Scene</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.image.Scene.add" href="#vipy.image.Scene.add">add</a></code></li>
<li><code><a title="vipy.image.Scene.annotate" href="#vipy.image.Scene.annotate">annotate</a></code></li>
<li><code><a title="vipy.image.Scene.append" href="#vipy.image.Scene.append">append</a></code></li>
<li><code><a title="vipy.image.Scene.bghash" href="#vipy.image.Scene.bghash">bghash</a></code></li>
<li><code><a title="vipy.image.Scene.bgmask" href="#vipy.image.Scene.bgmask">bgmask</a></code></li>
<li><code><a title="vipy.image.Scene.binarymask" href="#vipy.image.Scene.binarymask">binarymask</a></code></li>
<li><code><a title="vipy.image.Scene.blurmask" href="#vipy.image.Scene.blurmask">blurmask</a></code></li>
<li><code><a title="vipy.image.Scene.boundingbox" href="#vipy.image.Scene.boundingbox">boundingbox</a></code></li>
<li><code><a title="vipy.image.Scene.categories" href="#vipy.image.Scene.categories">categories</a></code></li>
<li><code><a title="vipy.image.Scene.centersquare" href="#vipy.image.Scene.centersquare">centersquare</a></code></li>
<li><code><a title="vipy.image.Scene.clear" href="#vipy.image.Scene.clear">clear</a></code></li>
<li><code><a title="vipy.image.Scene.cornercrop" href="#vipy.image.Scene.cornercrop">cornercrop</a></code></li>
<li><code><a title="vipy.image.Scene.cornerpadcrop" href="#vipy.image.Scene.cornerpadcrop">cornerpadcrop</a></code></li>
<li><code><a title="vipy.image.Scene.crop" href="#vipy.image.Scene.crop">crop</a></code></li>
<li><code><a title="vipy.image.Scene.difference" href="#vipy.image.Scene.difference">difference</a></code></li>
<li><code><a title="vipy.image.Scene.dilate" href="#vipy.image.Scene.dilate">dilate</a></code></li>
<li><code><a title="vipy.image.Scene.fghash" href="#vipy.image.Scene.fghash">fghash</a></code></li>
<li><code><a title="vipy.image.Scene.fgmask" href="#vipy.image.Scene.fgmask">fgmask</a></code></li>
<li><code><a title="vipy.image.Scene.fliplr" href="#vipy.image.Scene.fliplr">fliplr</a></code></li>
<li><code><a title="vipy.image.Scene.flipud" href="#vipy.image.Scene.flipud">flipud</a></code></li>
<li><code><a title="vipy.image.Scene.imclip" href="#vipy.image.Scene.imclip">imclip</a></code></li>
<li><code><a title="vipy.image.Scene.intersection" href="#vipy.image.Scene.intersection">intersection</a></code></li>
<li><code><a title="vipy.image.Scene.isduplicate" href="#vipy.image.Scene.isduplicate">isduplicate</a></code></li>
<li><code><a title="vipy.image.Scene.json" href="#vipy.image.Scene.json">json</a></code></li>
<li><code><a title="vipy.image.Scene.maxdim" href="#vipy.image.Scene.maxdim">maxdim</a></code></li>
<li><code><a title="vipy.image.Scene.meanmask" href="#vipy.image.Scene.meanmask">meanmask</a></code></li>
<li><code><a title="vipy.image.Scene.meanpad" href="#vipy.image.Scene.meanpad">meanpad</a></code></li>
<li><code><a title="vipy.image.Scene.mindim" href="#vipy.image.Scene.mindim">mindim</a></code></li>
<li><code><a title="vipy.image.Scene.nms" href="#vipy.image.Scene.nms">nms</a></code></li>
<li><code><a title="vipy.image.Scene.objectcrop" href="#vipy.image.Scene.objectcrop">objectcrop</a></code></li>
<li><code><a title="vipy.image.Scene.objectfilter" href="#vipy.image.Scene.objectfilter">objectfilter</a></code></li>
<li><code><a title="vipy.image.Scene.objectmap" href="#vipy.image.Scene.objectmap">objectmap</a></code></li>
<li><code><a title="vipy.image.Scene.objects" href="#vipy.image.Scene.objects">objects</a></code></li>
<li><code><a title="vipy.image.Scene.padcrop" href="#vipy.image.Scene.padcrop">padcrop</a></code></li>
<li><code><a title="vipy.image.Scene.perceptualhash" href="#vipy.image.Scene.perceptualhash">perceptualhash</a></code></li>
<li><code><a title="vipy.image.Scene.pixelate" href="#vipy.image.Scene.pixelate">pixelate</a></code></li>
<li><code><a title="vipy.image.Scene.pixelize" href="#vipy.image.Scene.pixelize">pixelize</a></code></li>
<li><code><a title="vipy.image.Scene.pixelmask" href="#vipy.image.Scene.pixelmask">pixelmask</a></code></li>
<li><code><a title="vipy.image.Scene.rectangular_mask" href="#vipy.image.Scene.rectangular_mask">rectangular_mask</a></code></li>
<li><code><a title="vipy.image.Scene.replace" href="#vipy.image.Scene.replace">replace</a></code></li>
<li><code><a title="vipy.image.Scene.rescale" href="#vipy.image.Scene.rescale">rescale</a></code></li>
<li><code><a title="vipy.image.Scene.resize" href="#vipy.image.Scene.resize">resize</a></code></li>
<li><code><a title="vipy.image.Scene.rot90ccw" href="#vipy.image.Scene.rot90ccw">rot90ccw</a></code></li>
<li><code><a title="vipy.image.Scene.rot90cw" href="#vipy.image.Scene.rot90cw">rot90cw</a></code></li>
<li><code><a title="vipy.image.Scene.savefig" href="#vipy.image.Scene.savefig">savefig</a></code></li>
<li><code><a title="vipy.image.Scene.setzero" href="#vipy.image.Scene.setzero">setzero</a></code></li>
<li><code><a title="vipy.image.Scene.show" href="#vipy.image.Scene.show">show</a></code></li>
<li><code><a title="vipy.image.Scene.uncrop" href="#vipy.image.Scene.uncrop">uncrop</a></code></li>
<li><code><a title="vipy.image.Scene.union" href="#vipy.image.Scene.union">union</a></code></li>
<li><code><a title="vipy.image.Scene.zeropad" href="#vipy.image.Scene.zeropad">zeropad</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>